<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  <subtitle>世界好大，修行好难</subtitle>
  <link href="https://onlyonemomo.github.io/atom.xml" rel="self"/>
  
  <link href="https://onlyonemomo.github.io/"/>
  <updated>2022-08-26T10:56:51.303Z</updated>
  <id>https://onlyonemomo.github.io/</id>
  
  <author>
    <name>onlyone Mo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自定义简单的Starter启动器</title>
    <link href="https://onlyonemomo.github.io/2022/08/26/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E7%9A%84Starter%E5%90%AF%E5%8A%A8%E5%99%A8/"/>
    <id>https://onlyonemomo.github.io/2022/08/26/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E7%9A%84Starter%E5%90%AF%E5%8A%A8%E5%99%A8/</id>
    <published>2022-08-26T10:56:36.000Z</published>
    <updated>2022-08-26T10:56:51.303Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语</strong>：在《通往java之路》这个栏目，我不想表现出更多的功利主义。我希望在这个栏目中每一篇文章都有很强的可读性和趣味性，能让我闲暇之时也能好好的阅读。</p><h5 id="1、创建一个Maven工程"><a href="#1、创建一个Maven工程" class="headerlink" title="1、创建一个Maven工程"></a>1、创建一个Maven工程</h5><p><img src="https://img-blog.csdnimg.cn/3c684a5c63f04e1ea8efdada6e934eee.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2、导入Spring的关键必要的依赖"><a href="#2、导入Spring的关键必要的依赖" class="headerlink" title="2、导入Spring的关键必要的依赖"></a>2、导入Spring的关键必要的依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入父依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注解处理器:生成配置元数据--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3、创建类完成相关逻辑"><a href="#3、创建类完成相关逻辑" class="headerlink" title="3、创建类完成相关逻辑"></a>3、创建类完成相关逻辑</h5><p><img src="https://img-blog.csdnimg.cn/1442da26e63b4dc08dc3440c7ad87464.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、定义配置类完成Bean的初始化"><a href="#4、定义配置类完成Bean的初始化" class="headerlink" title="4、定义配置类完成Bean的初始化"></a>4、定义配置类完成Bean的初始化</h5><p><img src="https://img-blog.csdnimg.cn/84335c4ddd4d4af994a7fac230841ca8.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HelloWorld <span class="title function_">helloWord</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、设置spring-factories配置文件"><a href="#5、设置spring-factories配置文件" class="headerlink" title="5、设置spring.factories配置文件"></a>5、设置spring.factories配置文件</h5><p><img src="https://img-blog.csdnimg.cn/4adf7a711567451bb8ebb0459cff19a7.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.only.config.HelloWorldConfiguration</span><br></pre></td></tr></table></figure><h5 id="6、打包安装即可-导入依赖即可使用"><a href="#6、打包安装即可-导入依赖即可使用" class="headerlink" title="6、打包安装即可,导入依赖即可使用"></a>6、打包安装即可,导入依赖即可使用</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mvn</span> package<span class="comment">//打包</span></span><br><span class="line"><span class="keyword">mvn</span> install <span class="comment">//安装依赖</span></span><br></pre></td></tr></table></figure><h6 id="在Maven-仓库可以看到这个包"><a href="#在Maven-仓库可以看到这个包" class="headerlink" title="在Maven 仓库可以看到这个包"></a>在Maven 仓库可以看到这个包</h6><p><img src="https://img-blog.csdnimg.cn/5c78eed3fb684cec83e88c354a997b68.png#pic_center" alt="在这里插入图片描述"></p><h6 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h6><p><img src="https://img-blog.csdnimg.cn/b21686ba90de483fb017e5e919fa4298.png#pic_center" alt="在这里插入图片描述"></p><h6 id="注入依赖"><a href="#注入依赖" class="headerlink" title="注入依赖"></a>注入依赖</h6><p><img src="https://img-blog.csdnimg.cn/330d895b74754645b4c4a0ca4010289e.png#pic_center" alt="在这里插入图片描述"></p><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><p><img src="https://img-blog.csdnimg.cn/ba6c99eddd8c419f94033bf4b35e1c61.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;：在《通往java之路》这个栏目，我不想表现出更多的功利主义。我希望在这个栏目中每一篇文章都有很强的可读性和趣味性，能让我闲暇之时也能好好的阅读。&lt;/p&gt;
&lt;h5 id=&quot;1、创建一个Maven工程&quot;&gt;&lt;a href=&quot;#1、创建一个M</summary>
      
    
    
    
    <category term="通往java之路" scheme="https://onlyonemomo.github.io/categories/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>德鲁克谈【自我管理】史上最受欢迎的文章</title>
    <link href="https://onlyonemomo.github.io/2022/08/26/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD/%E5%BE%B7%E9%B2%81%E5%85%8B%E8%B0%88%E3%80%90%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86%E3%80%91%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <id>https://onlyonemomo.github.io/2022/08/26/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD/%E5%BE%B7%E9%B2%81%E5%85%8B%E8%B0%88%E3%80%90%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86%E3%80%91%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E6%96%87%E7%AB%A0/</id>
    <published>2022-08-26T08:52:39.000Z</published>
    <updated>2022-08-26T11:37:31.311Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导读</strong>：本文最早刊登于《哈佛商业评论》，是其历史最佳文章之一。作者彼得·德鲁克是现代管理学之父，其著作影响了数代追求创新以及最佳管理实践的学者和企业家们，各类商业管理课程也都深受彼得·德鲁克思想的影响。本文后被收录在德鲁克的著作《21 世纪的管理挑战》中。非常值得一读再读。</p><p>我们生活的时代充满着前所未有的机会：<strong>如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。</strong></p><p>不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达 50 年的职业生涯中不断努力、干出实绩。</p><p>要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。</p><p>因为<strong>只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。</strong></p><p>历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。</p><p>而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。</p><p>我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达 50 年的职业生涯中保持着高度的警觉和投入。</p><p>1</p><p><strong>我们的长处是什么</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/a917c3d3472841509b65b02401932e20.jpeg" alt="img"></p><p>多数人都以为他们知道自己擅长什么。其实不然，更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。</p><p>然而，<strong>一个人要有所作为，只能靠发挥自己的长处</strong>，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情了。</p><p><strong>我们需要知己所长，才能知己所属。</strong></p><p><strong>要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。</strong>每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9 到 12 个月后，再将实际结果与自己的预期比较。</p><p>我本人采用这种方法已有 15 到 20 年了，而每次使用都有意外的收获。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/7f4bca92ee5f456099480e4e535b1e4e.jpeg" alt="img"></p><p>我们只要持之以恒地运用这个简单的方法，就能在较短的时间内，发现自己的长处。在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。</p><p>同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。</p><p>根据回馈分析的启示，你需要在几方面采取行动。</p><p><strong>首先最重要的是，专注于你的长处，</strong>把自己放到那些能发挥长处的地方。</p><p><strong>其次，加强你的长处。</strong>回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。</p><p><strong>第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。</strong>有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。</p><p>比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。</p><p>不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，<strong>要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。</strong></p><p><strong>另外一点也同样重要——纠正你的不良习惯。</strong>所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。</p><p>与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。</p><p><strong>礼貌，其实也很简单。****无非是说声「请」和「谢谢」，记住别人的名字，或问候对方家人这样的小事。</strong>许多聪明人，尤其是聪明的年轻人，没有意识到这一点。</p><p>如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。</p><p><strong>把预期和实际结果进行比较，也会发现自己不能做什么。</strong>我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为从无能到平庸要比从一流到卓越需要人们付出多得多的努力。</p><p>2</p><p><strong>我们的工作方式是怎样的</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/2c7c5d4b42e646c087d153a9926356da.jpeg" alt="img"></p><p>很少有人知道自己平时是怎样把事情给做成的。</p><p>实际上，我们当中的大多数人甚至不知道，不同人有着不同的工作方式和表现。</p><p><strong>许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。</strong></p><p>对于知识工作者来说，「我的工作方式是怎样的？」可能比「我的长处是什么？」这个问题更加重要。</p><p>同一个人的长处一样，一个人的工作方式也是独一无二的，这由人的个性决定。</p><p>通常，几个常见的个性特征就决定了一个人的工作方式。</p><p>我属于读者型，还是听者型？</p><p>首先，<strong>你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。</strong>绝大多数人甚至都不知道还有读者型和听者型之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。</p><p>没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力，反之亦然。<strong>不了解你的工作方式不可能发挥才干或取得成就。</strong></p><p>3</p><p><strong>我们如何学习</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/df8b460bb3c548ef8e6c53b5d50f3a17.jpeg" alt="img"></p><p>要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。</p><p>许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。</p><p>有关这个问题的解释是，<strong>笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。</strong>学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。</p><p>实际上，<strong>学习大概有六七种不同的方式。</strong></p><p><strong>像邱吉尔这样的人靠写来学习，还有些人以详尽的笔记来学习。有些人在实干中学习，另一些人通过听自己讲话学习。</strong></p><p>我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。</p><p>但光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/dfe0002a710a43cbb3ecba4850b1e56e.jpeg" alt="img"></p><p>有些人最适合当部属。</p><blockquote><p>二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长、可能也是美国历史上最成功的伯乐，乔治·马歇尔将军说：「巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。」</p></blockquote><p><strong>一些人作为团队成员工作最出色。另一些人单独工作最出色。一些人当教练和导师特别有天赋，另一些人却没能力做导师。</strong></p><p>另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。</p><p>顺便说一下，<strong>一个组织的二号人物在提升到一号职位时常常失败</strong>，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。</p><p>其他有助于认识自我的重要问题包括：</p><blockquote><p>我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？</p><p>我是在一个大公司还是在一个小公司中工作表现最佳？</p></blockquote><p>我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。</p><p>反过来也是如此。</p><p>下面这个结论值得我们反复强调：<strong>不要试图改变自我，因为这样你不大可能成功。但是，你****应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。</strong></p><p>4</p><p><strong>我们的价值观是什么</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/92a9c64f448d4d8db8c5eb2460f6346e.jpeg" alt="img"></p><p>要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单，我把它称为<strong>「镜子测试」</strong>。</p><blockquote><p>20 世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。</p><p>然而，在 1906 年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：「我不想早晨刮脸时在镜子里看到一个皮条客。」</p></blockquote><p>这就是镜子测试。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/31b302e81ac5435c916964acd1b03fb1.jpeg" alt="img"></p><p>我们所尊从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。</p><p><strong>如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。</strong></p><p>一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，<strong>一个人的价值观有时会与他的长处发生冲突。</strong></p><p>5</p><p><strong>我们属于何处</strong></p><p>少数人很早就知道他们属于何处。</p><p>比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。</p><p>但是，大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。</p><p>然而，到这个时候，他们应该知道上面所谈的三个问题的答案：</p><blockquote><p>我的长处是什么？</p><p>我的工作方式是怎样的？</p><p>我的价值观是什么？</p></blockquote><p>随后，他们就能够并且应该决定自己该向何处投入精力。或者，他们应该能够决定自己不属于何处。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/6939ccf2fb6b4dfdbfd76f5f60bd1dd7.jpeg" alt="img"></p><p>已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。</p><p><strong>成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。</strong></p><p>6</p><p><strong>我该做什么贡献</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/0c5382aa1d5142d6a6524ae8c13b116d.jpeg" alt="img"></p><p>综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。</p><p>对于知识工作者来说，他们不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？</p><p>要回答这个问题，他们必须考虑三个不同的因素：</p><blockquote><p>当前形势的要求是什么？</p><p>鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？</p><p>最后，必须取得什么结果才能产生重要影响？</p></blockquote><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/35696f4e893d47e9986701976a6e3a79.jpeg" alt="img"></p><p>一般来说，<strong>一项计划的时间跨度如果超过了 18 个月，就很难做到明确和具体。</strong></p><p>因此，在多数情况下我们应该提出的问题是：</p><blockquote><p>我在哪些方面能取得将在今后一年半内见效的结果？</p><p>如何取得这样的结果？</p></blockquote><p>回答这个问题时必须对几个方面进行权衡。</p><p>首先，<strong>这些结果应该是比较难实现的，要有「张力」 （stretching）。</strong>但这些结果也应该是能力所及的。</p><p>其次，<strong>这些结果应该富有意义，要能够产生一定影响。</strong></p><p>最后，结果应该明显可见，如果可能的话，还应当能够衡量。<strong>确定了要实现的结****果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。</strong></p><p>7</p><p><strong>对人际关系负责</strong></p><p>除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。<strong>不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。</strong>要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。</p><p><strong>首先要接受别人是和你一样的个体这个事实。</strong></p><p>他们有自己的长处，自己的做事方式和价值观。因此，<strong>要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。</strong></p><p>这个道理听起来让人很容易明白，但是没有几个人真正会去注意。</p><p>一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。</p><p><strong>老板既不是组织结构图上的一个头衔，也不是一个「职能」。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，去适应老板最有效的工作方式。</strong></p><p>事实上，这就是「管理」上司的秘诀。</p><p>这种方法适用于所有与你共事的人。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。</p><p><strong>人际关系责任的第二部分内容是沟通责任。</strong></p><p>在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。</p><p>即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。</p><p>因为我们看到，每当有人找到他的同事说「这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果」，这个人总会得到如此回答：「这太有帮助了，可你为什么不早点告诉我？」</p><p>如果一个人继续问道：「那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？」他也会得到类似的答复——据我的经验，无一例外。</p><p>事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。</p><p><strong>组织已不再建立在强权的基础上，而是建立在信任的基础上。</strong>人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。<strong>因此，人们绝对有必要对自己的人际关系负责****。</strong></p><p>这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。</p><p>8</p><p><strong>管理后半生</strong></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/33e6344cbc9f4cd393a0f727949091ae.jpeg" alt="img"></p><p>我们听到了许多有关经理人中年危机的谈论，「厌倦」这个词在其中频频出现。</p><p>45 岁时，多数经理人的职业生涯达到了顶峰。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。在他们面前，还有 20 到 25 年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。</p><p>发展第二职业有三种方式：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180519/8f00c5c2d0284fa3875a696105ea4908.jpeg" alt="img"></p><p><strong>第一种是完全投身于新工作。</strong></p><p>这常常只需要从一种组织转到另一种组织。</p><p>例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。</p><p>但是也有越来越多的人转入完全不同的职业。还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。</p><p><strong>为后半生做准备的第二种方式是，发展一个平行的职业。</strong></p><p>许多人的第一职业十分成功，他们还会继续从事原有工作。除此之外，他们会开创一项平行的工作，通常是在非营利机构。</p><p><strong>最后一种方法是社会创业。</strong></p><p>社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。</p><p>他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。</p><p>管理好自己后半生的人可能总是少数。多数人可能数着年头一年一年过去，直至退休。<strong>但正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的人，才会成为领袖和模范。</strong></p><p><strong>管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。</strong>当 30 年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在 40 岁之前就开始做志愿者，那他 60 岁之后也不会去做志愿者。</p><p>同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。</p><p><strong>发展第二兴趣还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。</strong>在这样的时刻，第二兴趣——不仅仅是业余爱好——可能发挥重要作用。</p><p><strong>在一个崇尚成功的社会里，拥有各种选择变得越来越重要。</strong>在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。</p><p>对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为「大人物」的领域，这不仅对个人十分重要，对个人的家庭也同样重要。</p><p>这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业。</p><p>自我管理中面临的挑战看上去比较明显。但自我管理需要我们做出以前从未做过的事情。自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。</p><p>更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。</p><p>历史上每一个社会，甚至是个人主义倾向最强的社会，都认为两件事情理所当然（即使只是下意识的）：</p><blockquote><p>第一，组织比员工更长寿；</p><p>第二，大多数人从不挪地方。</p></blockquote><p>如今，情况恰恰相反。<strong>知识工作者的寿命超过了组织寿命，而且他们来去自如。</strong></p><p>于是，人们对自我管理的需要在人类事务中掀起了一场革命。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导读&lt;/strong&gt;：本文最早刊登于《哈佛商业评论》，是其历史最佳文章之一。作者彼得·德鲁克是现代管理学之父，其著作影响了数代追求创新以及最佳管理实践的学者和企业家们，各类商业管理课程也都深受彼得·德鲁克思想的影响。本文后被收录在德鲁克的著作《21 世纪的</summary>
      
    
    
    
    <category term="每周转载" scheme="https://onlyonemomo.github.io/categories/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="每周转载" scheme="https://onlyonemomo.github.io/tags/%E6%AF%8F%E5%91%A8%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Linux搭建java环境SOP</title>
    <link href="https://onlyonemomo.github.io/2022/08/25/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/Linux%E6%90%AD%E5%BB%BAjava%E7%8E%AF%E5%A2%83SOP/"/>
    <id>https://onlyonemomo.github.io/2022/08/25/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/Linux%E6%90%AD%E5%BB%BAjava%E7%8E%AF%E5%A2%83SOP/</id>
    <published>2022-08-25T12:39:51.000Z</published>
    <updated>2022-08-25T12:42:49.442Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语</strong>：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助于快速配置相关属性，提高开发效率。</p><ul><li><p>软件安装</p></li><li><p>项目部署</p></li></ul><h2 id="1-防火墙配置【重点】"><a href="#1-防火墙配置【重点】" class="headerlink" title="1. 防火墙配置【重点】"></a>1. 防火墙配置【重点】</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol><li>防火墙的管理命令</li><li>开放端口允许外部连接，移除端口不允许外部连接</li></ol><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>linux默认防火墙是开启，而且所有的端口对外都是不可访问的。这么做的目的：安全。 问题：比如我等会在linux上安装tomcat的软件的。 tomcat软件需要使用8080端口。但是由于端口对外都是不可访问的，所以windows没法访问linux的tomcat。</p><p>&#x3D;&#x3D;解决上述问题的方案有两种：&#x3D;&#x3D;</p><ol><li><p>直接关闭防火墙，释放所有的端口，允许外界去访问全部的端口 ， 方便省心，弊端不安全(开发阶段)</p></li><li><p>只开放8080端口。开放指定的端口  (生产阶段，项目上线)</p></li></ol><p>防火墙类似于一个关卡检查人员，当你访问其他人的电脑，或者其他人访问你的电脑，都要进行拦截并进行处理，有的阻止，有的放行，有的转发。默认情况下防火墙在开机以后就自动启动了。</p><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><p>操作服务命令： systemctl  动作命令    服务的名称</p><p>防火墙服务</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>systemctl start   firewalld</td><td>开启</td></tr><tr><td>systemctl stop   firewalld</td><td>关闭</td></tr><tr><td>systemctl   enable firewalld</td><td>开机自启动&#x3D;&#x3D;(默认状态)&#x3D;&#x3D;</td></tr><tr><td>systemctl   disable firewalld</td><td>关闭开机自启</td></tr><tr><td>systemctl   status firewalld</td><td>查看当前防火墙状态</td></tr></tbody></table><h3 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h3><ol><li>确认当前是管理员的账户，查看防火墙当前的状态</li><li>关闭防火墙，再查看防火墙的状态</li><li>再次开启防火墙，查看防火墙的状态</li></ol><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p><img src="https://img-blog.csdnimg.cn/ef01ab4467c844c5b6b871177bd8a4f2.png#pic_center" alt="在这里插入图片描述"></p><h3 id="firewall-cmd"><a href="#firewall-cmd" class="headerlink" title="firewall-cmd"></a><font color="red">firewall-cmd</font></h3><p> 外网或内网需要连接到当前系统内的程序进行操作，需要linux系统开放程序端口，否则无法访问。</p><table><thead><tr><th>firewall-cmd</th><th>参数说明</th></tr></thead><tbody><tr><td>–zone&#x3D;public</td><td>开放哪个网络，默认是public</td></tr><tr><td>–add-port&#x3D;端口&#x2F;tcp</td><td>添加到防火墙中端口号，对外是打开的</td></tr><tr><td>–remove-port&#x3D;端口&#x2F;tcp</td><td>从防火墙的规则中删除端口号</td></tr><tr><td>–permanent</td><td>永久添加规则</td></tr><tr><td>–list-all</td><td>显示现有的规则，展示所有开放端口</td></tr><tr><td>–reload</td><td>重新加载规则，让新加的端口号起作用，重启防火墙的服务 systemctl restart firewalld</td></tr></tbody></table><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>永久开放443端口，添加到公开区域，允许外部连接</li><li>重新加载防火墙的规则</li><li>显示所有打开的端口号 </li><li>从公共区域中，永久移除443端口，不允许外部连接</li><li>重新加载防火墙规则</li><li>显示打开的端口号</li></ol><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://img-blog.csdnimg.cn/b04dcab908fa4207bbe090cee7edc9ba.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/d4ee1ca87ae3442e8ea628de02a85b53.png#pic_center" alt="在这里插入图片描述"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>说说下面代码的作用</p><ol><li><p>关闭、开启防火墙、设置自启、关闭自启服务命令？</p><blockquote><p>systemctl  stop|start|enable|disable   firewalld</p></blockquote></li><li><p>开放(添加)指定端口命令</p><blockquote><p>firewall-cmd  –zone&#x3D;public –add-port&#x3D;端口&#x2F;tcp   –permanent</p></blockquote></li><li><p>删除开放端口命令：</p><blockquote><p>firewall-cmd  –zone&#x3D;public –remove-port&#x3D;端口&#x2F;tcp   –permanent</p></blockquote></li><li><p>重新加载，展示列表</p><blockquote><p>firewall-cmd –reload</p><p>firewall-cmd –list-all</p></blockquote></li></ol><h2 id="2-软件安装"><a href="#2-软件安装" class="headerlink" title="2. 软件安装"></a>2. 软件安装</h2><h3 id="2-1-软件安装方式"><a href="#2-1-软件安装方式" class="headerlink" title="2.1 软件安装方式"></a>2.1 软件安装方式</h3><p>在Linux系统中，安装软件的方式主要有四种，这四种安装方式的特点如下：</p><table><thead><tr><th>安装方式</th><th>特点</th></tr></thead><tbody><tr><td>二进制发布包安装</td><td>软件已经针对具体平台编译打包发布，只要解压，修改配置即可 , tomcat\jdk</td></tr><tr><td>rpm安装（ 软件管家）</td><td>软件已经按照redhat的包管理规范进行打包，使用rpm命令进行安装，&#x3D;&#x3D;不能自行解决库依赖问题&#x3D;&#x3D;</td></tr><tr><td>yum安装</td><td>一种在线软件安装方式，本质上还是rpm安装，自动下载安装包并安装，安装过程中自动解决库依赖问题(安装过程需要联网)</td></tr><tr><td>源码编译安装</td><td>软件以源码工程的形式发布，需要自己编译打包 , redis</td></tr></tbody></table><h3 id="2-2-安装JDK"><a href="#2-2-安装JDK" class="headerlink" title="2.2 安装JDK"></a>2.2 安装JDK</h3><p>上述我们介绍了Linux系统软件安装的四种形式，接下来我们就通过第一种(二进制发布包)形式来安装JDK。 JDK对应的二进制发布包，在课程资料中已经提供，如下：<img src="https://img-blog.csdnimg.cn/87d2177dd1b54950a1b6b72e96c3736a.png#pic_center" alt="在这里插入图片描述"></p><p>JDK具体安装步骤如下： </p><p><strong>1). 上传安装包</strong></p><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><p>在Linux下安装JDK </p><h4 id="JDK安装步骤"><a href="#JDK安装步骤" class="headerlink" title="JDK安装步骤"></a>JDK安装步骤</h4><ol><li><p>在&#x2F;下创建soft目录，将提供的”软件”复制到Linux的soft目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /soft</span><br><span class="line"><span class="built_in">cd</span> /soft</span><br></pre></td></tr></table></figure></li><li><p>进入“&#x2F;soft”目录，解压jdk到指定目录&#x2F;usr&#x2F;local下</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf jdk-<span class="number">8</span>u221-linux-x64.tar.gz -C <span class="regexp">/usr/</span>local/</span><br></pre></td></tr></table></figure><ol start="3"><li>查看解压后的目录,目录中有jdk1.8.0_221为jdk解压的目录</li></ol><p><img src="https://img-blog.csdnimg.cn/8eea1a75e4554727b62d05462617f349.png#pic_center" alt="在这里插入图片描述"></p><ol start="4"><li>编辑&#x2F;etc&#x2F;profile文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><ol><li><p>配置jdk环境变量，打开&#x2F;etc&#x2F;profile配置文件，将下面配置拷贝进去，注：放在文件的最后面。</p><p>export命令用于将shell变量输出为环境变量</p></li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set java environment</span></span><br><span class="line"><span class="attribute">JAVA_HOME</span>=/usr/local/jdk1.8.0_221</span><br><span class="line"><span class="attribute">PATH</span>=<span class="variable">$JAVA_HOME</span>/bin:$PATH</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME PATH</span><br></pre></td></tr></table></figure><p> 命令1：vim &#x2F;etc&#x2F;profile</p><p> 命令2：在文件末尾处，输入o(表示在光标下插入新行)，复制上面的环境变量配置粘贴，并写入保存</p><ol start="5"><li>重新加载&#x2F;etc&#x2F;profile配置文件</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure><ol start="6"><li>判断JDK是否安装成功</li></ol><p><img src="https://img-blog.csdnimg.cn/7458cdf8c5be4bc8b0ea31817f16c78b.png#pic_center" alt="在这里插入图片描述"></p><h4 id="JDK安装小结"><a href="#JDK安装小结" class="headerlink" title="JDK安装小结"></a>JDK安装小结</h4><ol><li>解压</li><li>配置环境变量</li><li>source 命令重新在家 &#x2F;etc&#x2F;profile</li></ol><h3 id="2-3-安装Tomcat"><a href="#2-3-安装Tomcat" class="headerlink" title="2.3 安装Tomcat"></a>2.3 安装Tomcat</h3><h4 id="2-3-1-Tomcat安装"><a href="#2-3-1-Tomcat安装" class="headerlink" title="2.3.1 Tomcat安装"></a>2.3.1 Tomcat安装</h4><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><p>在Linux上安装Tomcat</p><h4 id="安装Tomcat的步骤"><a href="#安装Tomcat的步骤" class="headerlink" title="安装Tomcat的步骤"></a>安装Tomcat的步骤</h4><ol><li>进入soft文件夹，解压Tomcat到&#x2F;usr&#x2F;local下</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf apache-tomcat-<span class="number">8</span>.<span class="number">5</span>.<span class="number">51</span>.tar.gz  -C /usr/local</span><br></pre></td></tr></table></figure><ol start="2"><li>开放Linux的对外访问的端口8080</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=8080/tcp --permanent</span><br></pre></td></tr></table></figure><ol start="3"><li>重启防火墙</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl restart firewalld</span></span><br></pre></td></tr></table></figure><ol start="4"><li>进入&#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.51&#x2F;bin目录，启动Tomcat</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./startup.sh</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b08154217fca4a9999af206486224b41.png#pic_center" alt="在这里插入图片描述"></p><ol start="5"><li>在Windows下打开浏览器访问Linux的8080端口</li></ol><p><img src="https://img-blog.csdnimg.cn/1ebaa8df9e2b4af48af7d4d4f0eff936.png#pic_center" alt="在这里插入图片描述"></p><ol start="6"><li>进入bin目录下，关闭服务器。关闭服务器以后，浏览器不能再访问。</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d8c99f6ceb9f49b0848f2968f4908c21.png#pic_center" alt="在这里插入图片描述"></p><h4 id="2-3-4-停止Tomcat"><a href="#2-3-4-停止Tomcat" class="headerlink" title="2.3.4 停止Tomcat"></a>2.3.4 停止Tomcat</h4><p>在Linux系统中，停止Tomcat服务的方式主要有两种： </p><p><strong>1). 运行Tomcat提供的脚本文件</strong></p><p>在Tomcat安装目录下有一个bin目录，这个目录中存放的是tomcat的运行脚本文件，其中有一个脚本就是用于停止tomcat服务的。</p><p><img src="https://img-blog.csdnimg.cn/32620420f0b643dba59a733414d08d17.png#pic_center" alt="在这里插入图片描述"></p><p>我们可以切换到bin目录，并执行如下指令，来停止Tomcat服务：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sh</span> shutdown.<span class="keyword">sh</span></span><br><span class="line">./shutdown.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p><strong>2). 结束Tomcat进程</strong></p><p>我们可以先通过 <code>ps -ef|grep tomcat</code> 指令查看tomcat进程的信息，从进程信息中获取tomcat服务的进程号。然后通过kill -9 的形式，来杀死系统进程。</p><p><img src="https://img-blog.csdnimg.cn/26e4f74eeca94ba78b2628b57d4174d4.png#pic_center" alt="在这里插入图片描述"></p><p>通过上述的指令，我们可以获取到tomcat的进程号为 79947。接下来，我们就可以通过指令 ，来杀死tomcat的进程 ：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kill</span> -<span class="number">9</span> <span class="number">79947</span> </span><br></pre></td></tr></table></figure><p>执行完上述指令之后，我们再访问Linux系统中的Tomcat，就访问不到了。</p><blockquote><p>注意：</p><p>​kill命令是Linux提供的用于结束进程的命令，-9表示强制结束</p></blockquote><blockquote><p>注意 ： </p><p>​虽然上述讲解的两种方式，都可以停止Tomcat服务，但是推荐使用第一种方式(.&#x2F;shutdown.sh)执行脚本来关闭tomcat服务，如果通过第一种方式停止不了tomcat了，这个时候，我们可以考虑使用第二种方式，强制杀死进程。</p></blockquote><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>​<strong>tomcat安装步骤：</strong></p><pre><code>    1. 解压      2. 进入bin目录使用./startup.sh启动            3. 开放8080端口</code></pre><h3 id="2-4-安装MySQL"><a href="#2-4-安装MySQL" class="headerlink" title="2.4 安装MySQL"></a>2.4 安装MySQL</h3><h4 id="2-4-1-MySQL安装"><a href="#2-4-1-MySQL安装" class="headerlink" title="2.4.1 MySQL安装"></a>2.4.1 MySQL安装</h4><p>对于MySQL数据库的安装，我们将要使用前面讲解的第二种安装方式rpm进行安装。那么首先我们先了解一下什么rpm？</p><blockquote><p><strong>RPM：</strong>全称为 Red-Hat Package Manager，RPM软件包管理器（相当于windows的软件管家），是红帽Linux用于管理和安装软件的工具。</p></blockquote><p>我们要通过rpm，进行MySQL数据库的安装，主要的步骤如下：</p><p><strong>1). 检测当前系统是否安装过MySQL相关数据库</strong></p><p>需要通过rpm相关指令，来查询当前系统中是否存在已安装的mysql软件包，执行指令如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -<span class="keyword">qa</span>查询当前系统中安装的所有软件</span><br><span class="line">rpm -<span class="keyword">qa</span> | <span class="keyword">grep</span> mysql查询当前系统中安装的名称带mysql的软件</span><br><span class="line">rpm -<span class="keyword">qa</span> | <span class="keyword">grep</span> mariadb查询当前系统中安装的名称带mariadb的软件</span><br></pre></td></tr></table></figure><p>通过rpm -qa 查询到系统通过rpm安装的所有软件，太多了，不方便查看，所以我们可以通过管道符 | 配合着grep进行过滤查询。</p><p><img src="https://img-blog.csdnimg.cn/bec5196b2c214db09f0386203dc524ba.png#pic_center" alt="在这里插入图片描述"></p><p>通过查询，我们发现在当前系统中存在mariadb数据库，是CentOS7中自带的，而这个数据库和MySQL数据库是冲突的，所以要想保证MySQL成功安装，需要卸载mariadb数据库。</p><p><strong>2). 卸载现有的MySQL数据库</strong></p><p>在rpm中，卸载软件的语法为： </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e <span class="comment">--nodeps  软件名称</span></span><br></pre></td></tr></table></figure><p>那么，我们就可以通过指令，卸载 mariadb，具体指令为： </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rpm</span> -e --nodeps mariadb-libs-<span class="number">5</span>.<span class="number">5</span>.<span class="number">56</span>-<span class="number">2</span>.el7.x86_64</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4e7b556b9a1048a0b4fc89a49c14063a.png#pic_center" alt="在这里插入图片描述"></p><p>我们看到执行完毕之后， 再次查询 mariadb，就查不到了，因为已经被成功卸载了。</p><p><strong>3). 将资料中提供的MySQL安装包上传到Linux并解压</strong></p><p>A. 上传MySQL安装包</p><p>在课程资料中，提供的有MySQL的安装包 ，我们需要将该安装包上传到Linux系统的根目录 &#x2F; 下面。<br><img src="https://img-blog.csdnimg.cn/2587e1f7e1214d2eb7c732b0cdbeca75.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/539a6ebe86f44dce849f7a1bff9aa100.png#pic_center" alt="在这里插入图片描述"></p><p>B. 解压到&#x2F;usr&#x2F;local&#x2F;mysql</p><p>执行如下指令: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /soft</span><br><span class="line"><span class="built_in">mkdir</span> mysql</span><br><span class="line">tar -xvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz  -C ./mysql</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /soft/mysql</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/27273b2771f24e148dfb7534af63c2cc.png#pic_center" alt="在这里插入图片描述"></p><p><strong>4). 安装顺序安装rpm安装包  (要求一条一条命令执行)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm</span><br><span class="line">yum install net-tools</span><br><span class="line">rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><blockquote><p>说明: </p><ul><li>因为rpm安装方式，是不会自动处理依赖关系的，需要我们自己处理，所以对于上面的rpm包的安装顺序不能随意修改。</li><li>安装过程中提示缺少net-tools依赖，使用yum安装(yum是一种在线安装方式，需要保证联网)</li><li>可以通过指令(yum update)升级现有软件及系统内核</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/d8c5abea902a47fd9cb6de7b4bca2597.png#pic_center" alt="在这里插入图片描述"></p><h4 id="1-4-2-MySQL启动"><a href="#1-4-2-MySQL启动" class="headerlink" title="1.4.2 MySQL启动"></a>1.4.2 MySQL启动</h4><p>MySQL安装完成之后，会自动注册为系统的服务，服务名为mysqld。那么，我们就可以通过systemctl指令来查看mysql的状态、启动mysql、停止mysql。</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">system</span>ctl status mysqld查看mysql服务状态</span><br><span class="line"><span class="params">system</span>ctl start mysqld启动mysql服务</span><br><span class="line"><span class="params">system</span>ctl stop mysqld停止mysql服务</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/30efbcf3df8546c0b347175f5db0a0db.png#pic_center" alt="在这里插入图片描述"></p><blockquote><p>说明： </p><p>​可以设置开机时启动mysql服务，避免每次开机启动mysql。执行如下指令： </p><p>​systemctl enable mysqld</p></blockquote><p>我们可以通过如下方式，来判定mysql是否启动：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">ps</span> –ef | <span class="keyword">grep</span> mysql查看mysql进程</span><br></pre></td></tr></table></figure><blockquote><p>​<font color='red'>B. ps命令用于查看Linux中的进程数据。</font></p></blockquote><h4 id="1-4-3-MySQL登录"><a href="#1-4-3-MySQL登录" class="headerlink" title="1.4.3 MySQL登录"></a>1.4.3 MySQL登录</h4><h5 id="1-4-3-1-查阅临时密码"><a href="#1-4-3-1-查阅临时密码" class="headerlink" title="1.4.3.1 查阅临时密码"></a>1.4.3.1 查阅临时密码</h5><p>MySQL启动起来之后，我们就可以测试一下登录操作，但是我们要想登录MySQL，需要一个访问密码，而刚才在安装MySQL的过程中，并没有看到让我们设置访问密码，那这个访问密码是多少呢? 那实际上，对于rpm安装的mysql，在mysql第一次启动时，会自动帮我们生成root用户的访问密码，并且输出在mysql的日志文件 &#x2F;var&#x2F;log&#x2F;mysqld.log中，我们可以查看这份日志文件，从而获取到访问密码。</p><p>可以执行如下指令：</p><p>1). cat &#x2F;var&#x2F;log&#x2F;mysqld.log</p><p><img src="https://img-blog.csdnimg.cn/a588797069934d40945cbc6b8a95e238.png#pic_center" alt="在这里插入图片描述"></p><p>这种方式，可以看到所有的日志数据，文件比较大时，很不方便查看数据。我们可以通过管道符 | 配合grep来对数据进行过滤。</p><p>2). cat &#x2F;var&#x2F;log&#x2F;mysqld.log | grep password</p><p>我们可以通过上述指令，查询日志文件内容中包含password的行信息。</p><p><img src="https://img-blog.csdnimg.cn/23ebb1075cd64beabce617b6d5eb6bd2.png#pic_center" alt="在这里插入图片描述"></p><h5 id="1-4-3-2-登录MySQL"><a href="#1-4-3-2-登录MySQL" class="headerlink" title="1.4.3.2 登录MySQL"></a>1.4.3.2 登录MySQL</h5><p>获取到root用户的临时密码之后，我们就可以登录mysql数据库，修改root的密码，为root设置一个新的密码。并且我们还需要开启root用户远程访问该数据库的权限，这样的话，我们就可以在windows上来访问这台MySQL数据库。</p><p>执行如下指令： </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">①. 登录mysql（复制日志中的临时密码登录）</span><br><span class="line">mysql -uroot -p</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">②. 修改密码</span><br><span class="line">    <span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">4</span>;设置密码长度最低位数</span><br><span class="line">    <span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=LOW;设置密码安全等级低，便于密码可以修改成root</span><br><span class="line">    <span class="keyword">set</span> <span class="keyword">password</span> = <span class="keyword">password</span>(<span class="string">&#x27;root&#x27;</span>);设置密码为root</span><br><span class="line">    </span><br><span class="line">③. 开启访问权限(允许外界可以远程连接mysql，默认只能是本机连接)</span><br><span class="line">    <span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">    flush <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><p>操作完上述的指令之后，数据库root用户的密码以及远程访问我们就配置好了，接下来，可以执行exit退出mysql，再次通过新的密码进行登录。</p><p><img src="https://img-blog.csdnimg.cn/01d504c6552e411aa8d2b9cfa10406fb.png#pic_center" alt="在这里插入图片描述"></p><p>&#x3D;&#x3D;注意： 要想在windows上能够访问MySQL，还需要开放防火墙的3306端口，执行如下指令：&#x3D;&#x3D;</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">firewall</span><span class="literal">-</span><span class="comment">cmd</span> <span class="literal">--</span><span class="comment">zone=public</span> <span class="literal">--</span><span class="comment">add</span><span class="literal">-</span><span class="comment">port=3306/tcp</span> <span class="literal">--</span><span class="comment">permanent</span></span><br><span class="line"><span class="comment">firewall</span><span class="literal">-</span><span class="comment">cmd</span> <span class="literal">--</span><span class="comment">reload</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/54bd439718624b2a93221408216adc6a.png#pic_center" alt="在这里插入图片描述"></p><p>当然我们也可以使用安装在windows系统中的sqlyog或者Navicat来远程连接linux上的MySQL。</p><p><img src="https://img-blog.csdnimg.cn/b0eedc38ba6340778068cad8b5ef2d35.png#pic_center" alt="在这里插入图片描述"></p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><h5 id="安装mysql的步骤小结："><a href="#安装mysql的步骤小结：" class="headerlink" title="安装mysql的步骤小结："></a>安装mysql的步骤小结：</h5><ol><li><p>卸载原本的mysql</p><ol start="2"><li>解压</li><li>安装</li><li>开启mysqld的服务</li><li>登录，查找你初始化密码&#x2F;var&#x2F;log&#x2F;mysqld.log</li><li>修改密码</li><li>授权允许root用户在任意地址都可以登录</li><li>开放3306端口</li><li>使用windows的小海豚链接。</li></ol></li></ol><h2 id="3-项目部署"><a href="#3-项目部署" class="headerlink" title="3. 项目部署"></a>3. 项目部署</h2><p>之前我们讲解Linux操作系统时，就提到，我们服务端开发工程师学习Linux系统的目的就是将来我们开发的项目绝大部分情况下都需要部署在Linux系统中。那么在本章节，我们将通过两种方式，来演示项目部署，分别是：手动部署项目 和 基于shell脚本自动部署。</p><h3 id="3-1-手动部署项目"><a href="#3-1-手动部署项目" class="headerlink" title="3.1 手动部署项目"></a>3.1 手动部署项目</h3><p><strong>1). 在IDEA中开发SpringBoot项目并打成jar包</strong></p><p>项目是一个很简单的springboot项目(可以自己开发一个，也可以直接导入资料中提供的)，结构如下： </p><p><img src="https://img-blog.csdnimg.cn/0a9297d740844909b8a6f0e454e91252.png#pic_center" alt="在这里插入图片描述"></p><p>可以在本地的idea中先启动当前的demo工程，然后访问一下，看看工程是否正常访问。</p><p><img src="https://img-blog.csdnimg.cn/122466f9a4e54b2db55b426106f17637.png#pic_center" alt="在这里插入图片描述"></p><p>执行package指令，进行打包操作，将当前的springboot项目，打成一个jar包。 </p><p><strong>操作步骤</strong></p><ul><li><p>第一步: 引入Spring Boot打包插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--指定jar的名字--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>helloworld<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二步: 执行命令</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理、打包 跳过测试</span></span><br><span class="line"><span class="attr">mvn</span> <span class="string">clean package -Dmaven.test.skip=true</span></span><br></pre></td></tr></table></figure></li><li><p>第三步: 运行</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java</span> <span class="string">-jar xxx.jar</span></span><br></pre></td></tr></table></figure></li><li><p>第四步: 浏览器访问 <a href="http://localhost:8080/hello">http://localhost:8080/hello</a></p></li></ul><p><strong>2). 将jar包上传到Linux服务器</strong></p><p>通过 rz 指令，将打好的jar包上传至Linux服务器的 &#x2F;usr&#x2F;local&#x2F;app 目录下。 先执行指令创建app目录。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A. 在/usr/<span class="keyword">local</span>下创建目录<span class="keyword">app</span></span><br><span class="line"><span class="keyword">mkdir</span> /usr/<span class="keyword">local</span>/<span class="keyword">app</span></span><br><span class="line"></span><br><span class="line">B. 切换到<span class="keyword">app</span>目录下</span><br><span class="line"><span class="keyword">cd</span> /usr/<span class="keyword">local</span>/<span class="keyword">app</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/248b1278807c44c39d1609a3fbf67def.png#pic_center" alt="在这里插入图片描述"></p><p>此时这个jar包就上传到 &#x2F;usr&#x2F;local&#x2F;app 目录了。</p><p><img src="https://img-blog.csdnimg.cn/24423f13b7324f6f8b6eb8ab51db6af5.png#pic_center" alt="在这里插入图片描述"></p><p><strong>3). 启动SpringBoot程序</strong></p><p>由于我们的项目已经打成jar包上传上来到Linux服务器，我们只需要运行这个jar包项目就启动起来了，所以只需要执行如下指令即可： </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">java</span> -jar helloworld-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/dbeb0be9e8bd4494a60f950203fdc6fa.png#pic_center" alt="在这里插入图片描述"></p><p>&#x3D;&#x3D;注意： 由于前面安装的Tomcat在启动时，会占用端口号8080，而当前springboot项目我们没有配置端口号，默认也是8080，所以我们要想启动springboot项目，需要把之前运行的Tomcat停止掉。&#x3D;&#x3D;</p><p><strong>4). 检查防火墙，确保8080端口对外开放，访问SpringBoot项目</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd  <span class="comment">--list-all</span></span><br></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/79e77482aec346189c181746863c0f7e.png#pic_center" alt="在这里插入图片描述"></p><p>如果防火墙没有放开8080端口，还需要放开对应的端口号，执行如下指令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=8080/tcp --permanent</span><br></pre></td></tr></table></figure><p><strong>5). 访问测试</strong></p><p><a href="http://192.168.138.130:8080/hello">http://192.168.138.130:8080/hello</a></p><p><img src="https://img-blog.csdnimg.cn/89255793fdd2457780fbfa8f8714fb9a.png#pic_center" alt="在这里插入图片描述"></p><p><strong>6). 后台运行项目</strong></p><p>当前这个demo工程我们已经部署成功了，并且我们也可以访问项目了。但是这个工程目前是存在问题的，就是当前我们项目启动的这个窗口被霸屏占用了，&#x3D;&#x3D;如果我们把这个窗口关闭掉(或ctrl+c)，当前服务也就访问不到了&#x3D;&#x3D;，我们可以试一下。</p><p><img src="https://img-blog.csdnimg.cn/a0ce9065d9dc4146b60fc688dffd1010.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/f50520c505d84bfd8c776803270820ba.png#pic_center" alt="在这里插入图片描述"></p><p><strong>目前程序运行的问题：</strong></p><p>A. 线上程序不会采用控制台&#x3D;&#x3D;霸屏&#x3D;&#x3D;的形式运行程序，而是将程序在后台运行</p><p>B. 线上程序不会将日志输出到控制台，而是输出到日志文件，而且一旦关闭客户端窗口，我们程序就会关闭</p><p><strong>后台运行程序:</strong></p><p>要想让我们部署的项目进行后台运行，这个时候我们需要使用到linux中的一个命令 nohup ，接下来，就来介绍一下nohup命令。</p><blockquote><p><strong>nohup命令：</strong>英文全称 no hang up（不挂断），用于不挂断地运行指定命令，退出终端不会影响程序的运行</p><p><strong>语法格式：</strong> nohup Command [ Arg … ] [&amp;]</p><p><strong>参数说明：</strong></p><p>​Command：要执行的命令</p><p>​Arg：一些参数，可以指定输出文件</p><p>​&amp;：让命令在后台运行</p><p><strong>举例：</strong></p><p>​nohup java -jar boot工程.jar &amp;&gt; hello.log &amp;</p><p>​上述指令的含义为： 后台运行 java -jar 命令，并将日志输出到hello.log文件</p></blockquote><p>那么经过上面的介绍，我们可以推测中，我们要想让当前部署的项目后台运行，就可以使用下面的指令： </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup <span class="keyword">java </span>-<span class="keyword">jar </span>helloworld<span class="number">-1</span>.<span class="number">0</span>-SNAPSHOT.<span class="keyword">jar </span>&amp;&gt; hello.log &amp;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/08f9781688f74631ab0437d621fed2b7.png#pic_center" alt="在这里插入图片描述"></p><p>这样的话，我们的项目就已经启动成功了，我们可以通过ps指令，查看到系统的进程。</p><p><img src="https://img-blog.csdnimg.cn/297896425c134716884ccef5fe1e1a76.png#pic_center" alt="在这里插入图片描述"></p><p>接下来，我们再次访问我们的项目，来看看服务是否可用。</p><p><img src="https://img-blog.csdnimg.cn/4519053a58e048ddafc108b5174bafe8.png#pic_center" alt="在这里插入图片描述"></p><p><strong>7). 停止SpringBoot项目</strong></p><p><img src="https://img-blog.csdnimg.cn/5078116cd7734420a44b542a751613a9.png#pic_center" alt="在这里插入图片描述"></p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul><li><p><strong>手动部署需要经历那些步骤</strong></p><ul><li><p>打包jar</p></li><li><p>把jar上传到linux</p></li><li><p>运行jar包。    nohup  java -jar   jar的名称    &amp; &gt;日志文件 &amp;</p></li></ul></li></ul><h3 id="3-2-基于Shell脚本自动部署"><a href="#3-2-基于Shell脚本自动部署" class="headerlink" title="3.2 基于Shell脚本自动部署"></a>3.2 基于Shell脚本自动部署</h3><h4 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h4><p>前面介绍的项目部署是手动部署，也就是部署过程中的每一步操作都需要我们手动操作。接下来，我们需要再讲解一下项目的自动部署，从而来简化项目部署的操作，那么我们先来整体上了解一下项目自动部署的流程及操作步骤。</p><p><img src="https://img-blog.csdnimg.cn/d207895177d0486e9ba2166d58b4bac4.png#pic_center" alt="在这里插入图片描述"></p><p>操作步骤如下： </p><p>1). 在Gitee上创建远程仓库，并将本地的项目代码推送到远程仓库中</p><p>2). 在Linux中安装Git,克隆代码</p><p>3). 在Linux中安装maven</p><p>4). 编写Shell脚本（拉取代码、编译、打包、启动）</p><p>5). 为用户授予执行Shell脚本的权限</p><p>6). 执行Shell脚本</p><h4 id="3-2-2-推送代码到远程"><a href="#3-2-2-推送代码到远程" class="headerlink" title="3.2.2 推送代码到远程"></a>3.2.2 推送代码到远程</h4><p>这部分操作，大家只需要参考之前讲解的Git，来完成helloworld工程代码推送即可。</p><p>A. 创建远程仓库</p><p><img src="https://img-blog.csdnimg.cn/57ca0a1c59574b36af27a8561b9fc71e.png#pic_center" alt="在这里插入图片描述"></p><p>B. 将idea中的代码提交并推送到远程仓库</p><p><img src="https://img-blog.csdnimg.cn/e91e077e0a704d549ea8a25c7c1db3de.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/87f9e73593b1436c952474aace9a560c.png#pic_center" alt="在这里插入图片描述"></p><h4 id="3-2-3-Git操作"><a href="#3-2-3-Git操作" class="headerlink" title="3.2.3 Git操作"></a>3.2.3 Git操作</h4><p>1). Git软件安装（可以省略）</p><p>通过yum命令在线安装git，执行如下指令： </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">list</span> git列出git安装包</span><br><span class="line">yum <span class="keyword">install</span> git在线安装git</span><br></pre></td></tr></table></figure><p>通过上述指令，安装好git之后，我们就可以通过 git –version去验证git的环境。</p><p><img src="https://img-blog.csdnimg.cn/9a79f3a815fe43b882d3c4d8b8a20fe5.png#pic_center" alt="在这里插入图片描述"></p><p>2). Git克隆代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>local/</span><br><span class="line">git clone https:<span class="regexp">//gi</span>tee.com<span class="regexp">/ChuanZhiBoKe/</span>helloworld.git</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/1ad99dd17cbc4e238b438a24e4e028da.png#pic_center" alt="在这里插入图片描述"></p><h4 id="3-2-4-Maven安装"><a href="#3-2-4-Maven安装" class="headerlink" title="3.2.4 Maven安装"></a>3.2.4 Maven安装</h4><p>由于我们的工程是maven工程，我们要想进行项目的编译打包，需要用到maven的指令，所以需要安装maven。具体操作步骤如下：</p><p><strong>1). 上传资料中提供的maven的安装包</strong></p><p>上传课程资料中的maven安装包到soft目录</p><p><strong>2). 解压maven安装包到&#x2F;usr&#x2F;local目录</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span> /soft</span><br><span class="line"></span><br><span class="line"><span class="attribute">tar</span> -zxvf apache-maven-<span class="number">3</span>.<span class="number">5</span>.<span class="number">4</span>-bin.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/670b01c762e549ec983f831aa26c5cd5.png#pic_center" alt="在这里插入图片描述"></p><p><strong>3). 在&#x2F;etc&#x2F;profile配置文件中配置环境变量</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>profile</span><br><span class="line"></span><br><span class="line">修改配置文件，进入到命令模式，按G切换到最后一行，按a<span class="regexp">/i/</span>o进入插入模式，然后在最后加入如下内容 :</span><br><span class="line">JAVA_HOME=<span class="regexp">/usr/</span>local<span class="regexp">/jdk1.8.0_221/</span></span><br><span class="line">MAVEN_HOME=<span class="regexp">/usr/</span>local<span class="regexp">/apache-maven-3.5.4/</span></span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span><span class="regexp">/bin:$PATH:$MAVEN_HOME/</span>bin</span><br><span class="line">export JAVA_HOME PATH MAVEN_HOME</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后按ESC进入到命令模式，输入 :wq 保存并退出</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/fb26c9c177554ccd80911c733165a669.png#pic_center" alt="在这里插入图片描述"></p><p>要想让配置的环境变量生效,还需要执行如下指令:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/aec24aeb6c8f48fa953ccc901c668c4d.png#pic_center" alt="在这里插入图片描述"></p><p><strong>4). 修改maven的settings.xml配置文件,配置本地仓库地址</strong></p><p>A. 切换目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/apache-maven-3.5.4/</span>conf</span><br></pre></td></tr></table></figure><p>B. 编辑settings.xml配置文件</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim settings.<span class="built_in">xml</span></span><br></pre></td></tr></table></figure><p>在其中增加如下配置,配置本地仓库地址:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;<span class="regexp">/usr/</span>local<span class="regexp">/repo&lt;/</span>localRepository&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c7d9cf97973f4f0fbe93139ae6bc45ed.png#pic_center" alt="在这里插入图片描述"></p><p>并在settings.xml中的<mirrors>标签中,配置阿里云的私服</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/db5aee2562944a158134a80111b8d433.png#pic_center" alt="在这里插入图片描述"></p><h4 id="3-2-5-Shell脚本准备"><a href="#3-2-5-Shell脚本准备" class="headerlink" title="3.2.5 Shell脚本准备"></a>3.2.5 Shell脚本准备</h4><blockquote><p>Shell脚本（shell script），是一种Linux系统中的脚本程序。使用Shell脚本编程跟 JavaScript、Java编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 </p><p>对于Shell脚本编写不作为本课程重点内容，直接使用课程资料中提供的脚本文件bootStart.sh即可。</p></blockquote><p>在&#x2F;usr&#x2F;local&#x2F;目录下创建一个目录 sh(mkdir sh)，并将shell脚本上传到该目录下。或者直接在sh目录下创建一个脚本bootStart.sh，然后将资料中的bootStart.sh文件打开,内容拷贝过来即可。</p><p><img src="https://img-blog.csdnimg.cn/d2735ac7d46e4d0db39122a3dc359a4d.png#pic_center" alt="在这里插入图片描述"></p><p><strong>脚本解读:</strong> </p><p><img src="https://img-blog.csdnimg.cn/ea1dd5cd56644180b8296faee5606032.png#pic_center" alt="在这里插入图片描述"></p><h4 id="2-2-6-Linux权限"><a href="#2-2-6-Linux权限" class="headerlink" title="2.2.6 Linux权限"></a>2.2.6 Linux权限</h4><p>前面我们已经把Shell脚本准备好了，但是Shell脚本要想正常的执行，还需要给Shell脚本分配执行权限。 由于linux系统是一个多用户的操作系统，并且针对每一个用户，Linux会严格的控制操作权限。接下来，我们就需要介绍一下Linux系统的权限控制。</p><blockquote><p>1). &#x3D;&#x3D;chmod&#x3D;&#x3D;（英文全拼：change mode）命令是控制用户对文件的权限的命令</p><p>2). Linux中的权限分为三种 ：读(r)、写(w)、执行(x)</p><p>3). Linux文件权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）</p><p>4). 只有文件的所有者和超级用户可以修改文件或目录的权限</p><p>5). 要执行Shell脚本需要有对此脚本文件的执行权限(x)，如果没有则不能执行</p></blockquote><p>Linux系统中权限描述如下: </p><p><img src="https://img-blog.csdnimg.cn/9e597737491d4d8e90ed384ecc692c77.png#pic_center" alt="在这里插入图片描述"></p><p>解析当前脚本的权限情况: </p><p><img src="https://img-blog.csdnimg.cn/85453fe9567b4927950b7ef306ae4153.png#pic_center" alt="在这里插入图片描述"></p><p>chmod命令可以使用八进制数来指定权限(0 - 代表无 , 1 - 执行x , 2 - 写w , 4 - 读r):</p><table><thead><tr><th>值</th><th>权限</th><th>rwx</th></tr></thead><tbody><tr><td>7</td><td>读 + 写 + 执行</td><td>rwx</td></tr><tr><td>6</td><td>读 + 写</td><td>rw-</td></tr><tr><td>5</td><td>读 + 执行</td><td>r-x</td></tr><tr><td>4</td><td>只读</td><td>r–</td></tr><tr><td>3</td><td>写 + 执行</td><td>-wx</td></tr><tr><td>2</td><td>只写</td><td>-w-</td></tr><tr><td>1</td><td>只执行</td><td>–x</td></tr><tr><td>0</td><td>无</td><td>—</td></tr></tbody></table><p><strong>举例:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">chmod</span> <span class="number">777</span> bootStart.sh   为所有用户授予读、写、执行权限</span><br><span class="line"><span class="attribute">chmod</span> <span class="number">755</span> bootStart.sh   为文件拥有者授予读、写、执行权限，同组用户和其他用户授予读、执行权限</span><br><span class="line"><span class="attribute">chmod</span> <span class="number">210</span> bootStart.sh   为文件拥有者授予写权限，同组用户授予执行权限，其他用户没有任何权限</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;</p><p>三个数字分别代表不同用户的权限</p><ul><li>第1位表示文件拥有者的权限</li><li>第2位表示同组用户的权限</li><li>第3位表示其他用户的权限</li></ul><h4 id="2-2-7-授权并执行脚本"><a href="#2-2-7-授权并执行脚本" class="headerlink" title="2.2.7 授权并执行脚本"></a>2.2.7 授权并执行脚本</h4><p>在测试阶段，我们可以给所有的人都赋予执行该shell脚本的权限。所以可以执行如下指令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">chmod</span> <span class="number">777</span> bootStart.sh</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/9140dcf0c1ca469cb057524f4011df37.png#pic_center" alt="在这里插入图片描述"></p><p>权限解读: </p><p>A. 第一个7，代表当前文件所有者root用户，对该文件具有读写执行权限；</p><p>B. 第二个7，代表当前文件所有者所属组的用户，对该文件具有读写执行权限；</p><p>B. 第三个7，代表其他用户，对该文件具有读写执行权限；</p><p>执行该shell脚本:</p><p> <img src="https://img-blog.csdnimg.cn/7e894795394c456dab5714df42d394b9.png#pic_center" alt="在这里插入图片描述"></p><p>&#x3D;&#x3D;注意： 在执行maven指令进行打包时，第一次执行可能会耗时比较长，因为在进行maven工程的打包时，需要到中央仓库下载工程依赖的jar包和插件(可以在settings.xml中配置阿里云私服加速下载)。&#x3D;&#x3D;</p><p>启动完成之后, 我们可以查看java进程：</p><p><img src="https://img-blog.csdnimg.cn/50166e298b5a47939389ff6fb427d2ae.png#pic_center" alt="在这里插入图片描述"></p><p>访问项目：</p><p><img src="https://img-blog.csdnimg.cn/442b8345638d45b4a235b18400b6a103.png#pic_center" alt="在这里插入图片描述"></p><h2 id="4-虚拟机克隆"><a href="#4-虚拟机克隆" class="headerlink" title="4. 虚拟机克隆"></a>4. 虚拟机克隆</h2><h3 id="虚拟机克隆的作用"><a href="#虚拟机克隆的作用" class="headerlink" title="虚拟机克隆的作用"></a>虚拟机克隆的作用</h3><p>以后我们需要玩集群，那么就需要有多台服务器，而且每台服务都需要安装相应的软件，这样子我们的工作就会重复了，解决方案：我们先在一台机器安装好所有的软件，然后克隆出来另外的机器。被克隆出来机器环境与供体是一模一样的。</p><h3 id="如何克隆"><a href="#如何克隆" class="headerlink" title="如何克隆"></a>如何克隆</h3><ol><li>克隆</li></ol><p><img src="https://img-blog.csdnimg.cn/5239cde5b8244937aefffcced770d3df.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2ff2bd9763af4b32ae0f48d57e17bedb.png#pic_center" alt="在这里插入图片描述"></p><ol start="2"><li>修改ip地址，否则会互相ip冲突</li></ol><p><img src="https://img-blog.csdnimg.cn/569b3d13e4d440c0858b536597cefea6.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/e4258620183040b18016ad346b706907.png#pic_center" alt="在这里插入图片描述"></p><ol start="3"><li>重启网卡服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-镜像还原"><a href="#5-镜像还原" class="headerlink" title="5. 镜像还原"></a>5. 镜像还原</h2><h3 id="镜像还原的应用场景"><a href="#镜像还原的应用场景" class="headerlink" title="镜像还原的应用场景"></a>镜像还原的应用场景</h3><ol><li><p>某些同学晚上关机的时候是强制关机的，导致文件出现损坏，机器没法启动。</p><ol start="2"><li>后面我们的项目里面linux需要安装大量的软件的，这些软件目前都是在安装在老师的机器上，学生机器还没有，如果学生挨个安装耗时太久了，这时候老师可以把linux 的镜像拷贝给你们，然后还原出来与老师一模一样的机器。</li></ol></li></ol><h3 id="如何实现镜像还原"><a href="#如何实现镜像还原" class="headerlink" title="如何实现镜像还原"></a>如何实现镜像还原</h3><ol><li><strong>先把镜像文件拷贝给目标群体</strong></li></ol><p>​</p><p><img src="https://img-blog.csdnimg.cn/a667e0b8b0544abd983913877e2051c4.png#pic_center" alt="在这里插入图片描述"></p><ol start="2"><li>还原镜像</li></ol><p><img src="https://img-blog.csdnimg.cn/c9e8cf3439e94c2eb2abad0c3e4debe5.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/f7091c60b6a444b581eccb38a9aa9fd3.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/a14725ed587e42acba28b7e1cd301cc6.png#pic_center" alt="在这里插入图片描述"></p><ol start="3"><li>查看你本机的vm的网关</li></ol><p><img src="https://img-blog.csdnimg.cn/9336b6347a1a4fae813639634c22e643.png#pic_center" alt="在这里插入图片描述"></p><ol start="4"><li>修改ip（前三位）地址与网关一致</li></ol><p><img src="https://img-blog.csdnimg.cn/3f28259942034cef824274db64a31754.png#pic_center" alt="在这里插入图片描述"></p><ol start="5"><li>重启网卡</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助</summary>
      
    
    
    
    <category term="SOP操作手册" scheme="https://onlyonemomo.github.io/categories/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    
    
    <category term="SOP" scheme="https://onlyonemomo.github.io/tags/SOP/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之入门案例</title>
    <link href="https://onlyonemomo.github.io/2022/08/25/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/SpringBoot%E4%B9%8B%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"/>
    <id>https://onlyonemomo.github.io/2022/08/25/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/SpringBoot%E4%B9%8B%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</id>
    <published>2022-08-25T12:23:36.000Z</published>
    <updated>2022-08-25T12:31:19.497Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语</strong>：在《通往java之路》这个栏目，我不想表现出更多的功利主义。我希望在这个栏目中每一篇文章都有很强的可读性和趣味性，能让我闲暇之时也能好好的阅读。</p><h3 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--1. 凡是springboot项目都必须要继承一个父模块--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 以后你需要使用哪个框架，那么就导入对应框架的启动器即可。</span></span><br><span class="line"><span class="comment"> 比如：springmvc - starter-web--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、编写SpringBoot项目启动类"><a href="#2、编写SpringBoot项目启动类" class="headerlink" title="2、编写SpringBoot项目启动类"></a>2、编写SpringBoot项目启动类</h3><blockquote><p>启动类就是带 @SpringBootApplication 注解的普通Java类【是运行SpringBoot项目的入口类】</p></blockquote><p><strong>核心代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.onlyone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6a053cda12f047d3b7d5cd06f3d189e1.png#pic_center" alt="在这里插入图片描述"></p><h3 id="3、编写Controller"><a href="#3、编写Controller" class="headerlink" title="3、编写Controller"></a>3、编写Controller</h3><p><strong>核心代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.onlyone.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">quick</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello springboot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入<code>localhost:8080/quick</code><br><img src="https://img-blog.csdnimg.cn/abc240985e2a4aab97c280f8d661bcaa.png#pic_center" alt="在这里插入图片描述"><br>入门案例已编写完成了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;：在《通往java之路》这个栏目，我不想表现出更多的功利主义。我希望在这个栏目中每一篇文章都有很强的可读性和趣味性，能让我闲暇之时也能好好的阅读。&lt;/p&gt;
&lt;h3 id=&quot;1、导入依赖&quot;&gt;&lt;a href=&quot;#1、导入依赖&quot; class=</summary>
      
    
    
    
    <category term="通往java之路" scheme="https://onlyonemomo.github.io/categories/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot之java打包SOP</title>
    <link href="https://onlyonemomo.github.io/2022/08/25/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/SpringBoot%E4%B9%8Bjava%E6%89%93%E5%8C%85SOP/"/>
    <id>https://onlyonemomo.github.io/2022/08/25/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/SpringBoot%E4%B9%8Bjava%E6%89%93%E5%8C%85SOP/</id>
    <published>2022-08-25T12:21:51.000Z</published>
    <updated>2022-08-25T12:24:13.424Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语</strong>：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助于快速配置相关属性，提高开发效率。</p><h3 id="第一、先配置Maven环境变量"><a href="#第一、先配置Maven环境变量" class="headerlink" title="第一、先配置Maven环境变量"></a>第一、先配置Maven环境变量</h3><p><strong>图1：点击高级系统设置</strong><br><img src="https://img-blog.csdnimg.cn/8fdc10cdb43f41a9aa3a1c95bee3a104.png#pic_center" alt="在这里插入图片描述"></p><p><strong>图2：点击环境变量</strong><br><img src="https://img-blog.csdnimg.cn/ad233281f95249cf902791dbdf6947c4.png#pic_center" alt="在这里插入图片描述"></p><p><strong>图3：新建<code>MAVEN_HOME</code>系统变量</strong><br><img src="https://img-blog.csdnimg.cn/51812a58bdbc461fad6e68244e203313.png#pic_center" alt="在这里插入图片描述"></p><p><strong>图4：编辑path，在系统变量中引用MAVEN_HOME变量，指向MAVEN_HOME中的bin目录</strong>  <code>%MAVEN_HOME%\bin</code><br><img src="https://img-blog.csdnimg.cn/b99a906655dd48939f88b14724ab8fad.png#pic_center" alt="在这里插入图片描述"></p><p><strong>图5：输入mvn -v命令，如果出现maven版本号，就表明安装成功。</strong><br><img src="https://img-blog.csdnimg.cn/11de7a768b914f7dbe114efe2a35b90f.png#pic_center" alt="在这里插入图片描述"></p><h3 id="第二、在SpringBoot里面打包"><a href="#第二、在SpringBoot里面打包" class="headerlink" title="第二、在SpringBoot里面打包"></a>第二、在SpringBoot里面打包</h3><h5 id="第一步-引入Spring-Boot打包插件"><a href="#第一步-引入Spring-Boot打包插件" class="headerlink" title="第一步: 引入Spring Boot打包插件"></a>第一步: 引入Spring Boot打包插件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--打包的插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--修改jar的名字--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>ROOT<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="第二步-在IDEA-左下方的Terminal里执行命令"><a href="#第二步-在IDEA-左下方的Terminal里执行命令" class="headerlink" title="第二步: 在IDEA-左下方的Terminal里执行命令"></a>第二步: 在IDEA-左下方的Terminal里执行命令</h5><p><strong>温馨提示：</strong>要在对应的项目路径里面输入此命令</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理、打包 跳过测试</span></span><br><span class="line"><span class="attr">mvn</span> <span class="string">clean package -Dmaven.test.skip=true</span></span><br></pre></td></tr></table></figure><h5 id="第三步-在jar目录下，打开cmd运行"><a href="#第三步-在jar目录下，打开cmd运行" class="headerlink" title="第三步: 在jar目录下，打开cmd运行"></a>第三步: 在jar目录下，打开cmd运行</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar</span><br></pre></td></tr></table></figure><p>: 在jar目录下，打开cmd运行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar</span><br></pre></td></tr></table></figure><h5 id="第四步：在浏览器输入访问路径"><a href="#第四步：在浏览器输入访问路径" class="headerlink" title="第四步：在浏览器输入访问路径"></a>第四步：在浏览器输入访问路径</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助</summary>
      
    
    
    
    <category term="SOP操作手册" scheme="https://onlyonemomo.github.io/categories/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    
    
    <category term="SOP" scheme="https://onlyonemomo.github.io/tags/SOP/"/>
    
  </entry>
  
  <entry>
    <title>世界级天后中岛美雪的歌曲</title>
    <link href="https://onlyonemomo.github.io/2022/08/24/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/%E4%B8%96%E7%95%8C%E7%BA%A7%E5%A4%A9%E5%90%8E%E4%B8%AD%E5%B2%9B%E7%BE%8E%E9%9B%AA%E7%9A%84%E6%AD%8C%E6%9B%B2/"/>
    <id>https://onlyonemomo.github.io/2022/08/24/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/%E4%B8%96%E7%95%8C%E7%BA%A7%E5%A4%A9%E5%90%8E%E4%B8%AD%E5%B2%9B%E7%BE%8E%E9%9B%AA%E7%9A%84%E6%AD%8C%E6%9B%B2/</id>
    <published>2022-08-24T15:25:39.000Z</published>
    <updated>2022-08-25T12:48:28.138Z</updated>
    
    <content type="html"><![CDATA[<p><strong>中岛美雪号称养活了半个华语娱乐圈的人</strong>！中岛美雪，这个名字或许你会觉得陌生，但很多歌曲就是翻唱她的。<br>(1)比如邓丽君的《漫步人生路》，是根据中岛美雪1980年的单曲《习惯孤独》改编的，这首单曲曾创下了40万张销量的奇迹。<br>(2)1992年，《容易受伤的女人》红遍香港，王菲在各大音乐颁奖礼中获奖无数，就此跃入香港一线女歌手的行列。这首歌的原版歌曲《口红》，同样是中岛美雪作词、作曲并演唱的。<br>(3)还有范玮琪这首旋律激昂，引发无数听众共鸣的《最初的梦想》，日文原版名为《骑在银龙的背上》，中岛美雪用这首歌歌颂了一位孤岛医生，用“银龙飞跃”的形象，表达了对善良、纯真的追求与向往。</p><p>话不多说，一起来听一下我选出来的三首经典歌曲吧！！！</p><h5 id="第一首《骑在银龙的背上》"><a href="#第一首《骑在银龙的背上》" class="headerlink" title="第一首《骑在银龙的背上》"></a>第一首《骑在银龙的背上》</h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=69799435&bvid=BV1pE411Q7TQ&cid=269615233&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h5 id="第二首《幸福》"><a href="#第二首《幸福》" class="headerlink" title="第二首《幸福》"></a>第二首《幸福》</h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=628262163&bvid=BV1Qt4y1k7E9&cid=271284248&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h5 id="第三首《ひとり上手》漫步人生路原曲"><a href="#第三首《ひとり上手》漫步人生路原曲" class="headerlink" title="第三首《ひとり上手》漫步人生路原曲"></a>第三首《ひとり上手》漫步人生路原曲</h5><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=841414544&bvid=BV1C54y1q7QU&cid=215222372&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;中岛美雪号称养活了半个华语娱乐圈的人&lt;/strong&gt;！中岛美雪，这个名字或许你会觉得陌生，但很多歌曲就是翻唱她的。&lt;br&gt;(1)比如邓丽君的《漫步人生路》，是根据中岛美雪1980年的单曲《习惯孤独》改编的，这首单曲曾创下了40万张销量的奇迹。&lt;br&gt;(2)</summary>
      
    
    
    
    <category term="三千世界" scheme="https://onlyonemomo.github.io/categories/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/"/>
    
    
    <category term="歌曲" scheme="https://onlyonemomo.github.io/tags/%E6%AD%8C%E6%9B%B2/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装和SSH连接工具使用SOP</title>
    <link href="https://onlyonemomo.github.io/2022/08/24/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/Linux%E5%AE%89%E8%A3%85%E5%92%8CSSH%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8SOP/"/>
    <id>https://onlyonemomo.github.io/2022/08/24/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/Linux%E5%AE%89%E8%A3%85%E5%92%8CSSH%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8SOP/</id>
    <published>2022-08-24T10:34:51.000Z</published>
    <updated>2022-08-24T10:34:34.444Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语</strong>：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助于快速配置相关属性，提高开发效率。</p><h3 id="1-1-安装方式介绍"><a href="#1-1-安装方式介绍" class="headerlink" title="1.1 安装方式介绍"></a>1.1 安装方式介绍</h3><p>Linux系统的安装方式，主要包含以下两种：</p><p><img src="https://img-blog.csdnimg.cn/362a0c47299849cb8098c912a5ac5729.png#pic_center" alt="在这里插入图片描述"></p><table><thead><tr><th>方式</th><th>概述</th><th>场景</th></tr></thead><tbody><tr><td>物理机安装</td><td>直接将操作系统安装到服务器硬件&#96;</td><td>企业开发中，我们使用的服务器基本都是采用这种方式</td></tr><tr><td>虚拟机安装</td><td>通过虚拟机软件安装</td><td>我们在学习阶段，没有自己服务器，而我们又需要学Linux，就可以安装在虚拟机上(&#x3D;&#x3D;虚拟机的作用就是可以帮你模拟一台或者多台裸机出来&#x3D;&#x3D;)</td></tr></tbody></table><p><strong>虚拟机</strong>（Virtual Machine）指通过<strong>软件</strong>模拟的具有完整硬件系统功能、运行在完全隔离环境中的完整计算机系统。常用虚拟机软件： </p><ul><li><p>VMWare </p></li><li><p>VirtualBox</p></li><li><p>VMLite WorkStation</p></li><li><p>Qemu</p></li><li><p>HopeddotVOS</p></li></ul><p>那么我们就可以在课程中将Linux操作系统安装在虚拟机中，我们课上选择的虚拟机软件是VMware。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>安装linux系统方式有几种，虚拟机的作用？  <ul><li>物理机直接安装</li><li>通过虚拟机的软件模拟出裸机然后安装操作系统</li></ul></li></ul><h3 id="1-2-安装VMware"><a href="#1-2-安装VMware" class="headerlink" title="1.2 安装VMware"></a>1.2 安装VMware</h3><p><img src="https://img-blog.csdnimg.cn/a53a72e5ce674479a9fe573407ecf139.png#pic_center" alt="在这里插入图片描述"></p><p>在我们的课程资料中提供了VMware的安装程序。直接双击运行VMware安装程序，根据提示完成安装即可。</p><p><img src="https://img-blog.csdnimg.cn/8c706ad40fc442bda2599422d713752f.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/5b0683c1018747df9dff3a25a85bdfab.png#pic_center" alt="在这里插入图片描述"></p><p>以上就是VMware在安装时的每一步操作，基本上就是点击 “下一步” 一直进行安装。</p><p>&#x3D;&#x3D;注意： 安装完毕vm的时候检查一下的网卡，是否存在vm1与vm8这两张网卡,缺少这两张网卡任意一张以后要不就是不能够与windows通讯，要不就是不能够上外网 ,解决办法： 卸载重装vm，如果还不行，换vm的版本&#x3D;&#x3D;<br><img src="https://img-blog.csdnimg.cn/10e186c0777a4c1b8c832e98fbd5f2ad.png#pic_center" alt="在这里插入图片描述"></p><h3 id="1-3-安装Linux"><a href="#1-3-安装Linux" class="headerlink" title="1.3 安装Linux"></a>1.3 安装Linux</h3><p>VMware虚拟机安装完毕之后，我们就可以打开VMware，并在上面来安装Linux操作系统。具体步骤如下： </p><p><strong>1). 选择创建新的虚拟机</strong></p><p><img src="https://img-blog.csdnimg.cn/46fa4fa1ebb4471c93c49ee0d5efa39c.png#pic_center" alt="在这里插入图片描述"></p><p><strong>2). 选择”典型”配置</strong></p><p><img src="https://img-blog.csdnimg.cn/48ff36d3d21b4a41bf696d81c8ede3a0.png#pic_center" alt="在这里插入图片描述"></p><p><strong>3). 选择”稍后安装操作系统(S)”</strong><br><img src="https://img-blog.csdnimg.cn/6844a2057584455ab30ad5d112483396.png#pic_center" alt="在这里插入图片描述"></p><p><strong>4). 选择”Linux”操作系统,”CentOS7 64位”版本</strong></p><p><img src="https://img-blog.csdnimg.cn/554a27525c63404183c50bc40a4fbc6c.png#pic_center" alt="在这里插入图片描述"></p><p><strong>5). 设置虚拟机的名称及系统文件存放路径</strong></p><p><img src="https://img-blog.csdnimg.cn/2d5efb2425544fc58c387a6c565fa6e9.png#pic_center" alt="在这里插入图片描述"></p><p><strong>6). 设置磁盘容量</strong></p><p><img src="https://img-blog.csdnimg.cn/f3b6f6dab8554099b39436986e472043.png#pic_center" alt="在这里插入图片描述"></p><p><strong>7). 自定义硬件信息</strong></p><p><img src="https://img-blog.csdnimg.cn/8a639032a3da4ddd99a70516257defa9.png#pic_center" alt="在这里插入图片描述"></p><p><strong>8). 启动上述创建的新虚拟机</strong></p><p><img src="https://img-blog.csdnimg.cn/e964e944b0b64283bc797c0781b13fc1.png#pic_center" alt="在这里插入图片描述"></p><p><strong>9). 选择”Install CentOS7”</strong></p><p><img src="https://img-blog.csdnimg.cn/4ead6d664018407291585e8190a63e87.png#pic_center" alt="在这里插入图片描述"></p><blockquote><p>进入到Linux系统里面, 我们发现光标无法移动到windows操作系统中了, 这个时候, 我们可以通过快捷键 “Ctrl+Alt” 切换光标到windows系统中。</p></blockquote><p><strong>10). 选择语言为 “简体中文”</strong></p><p><img src="https://img-blog.csdnimg.cn/fff3eb4606e5424699e0c2fe60ec6442.png#pic_center" alt="在这里插入图片描述"></p><p><strong>11). 选择”自动配置分区”</strong></p><p><img src="https://img-blog.csdnimg.cn/2aa35fa7ee0a47c7815a53c11b034f33.png#pic_center" alt="在这里插入图片描述"></p><p>12). 选择”最小安装”</p><p><img src="https://img-blog.csdnimg.cn/884031b5bd4e4cf39538df625b8d53fe.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/b2cbf5a2b5864b1588c5f8f4783f4d1f.png#pic_center" alt="在这里插入图片描述"></p><p><strong>13). 启动网卡</strong></p><p><img src="https://img-blog.csdnimg.cn/d08cde2b3cf1428cb27ee3ef7d69adad.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/a77b89742f75425ca6e2bb68aafaa198.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/33bacaff11f44f3c948037d33c65d6ad.png#pic_center" alt="在这里插入图片描述"></p><p><strong>13). 设置”root”用户密码</strong></p><p><img src="https://img-blog.csdnimg.cn/d159abaae2144a409f81a2bdcecfec7a.png#pic_center" alt="在这里插入图片描述"></p><p>安装完毕后，点击窗口中的蓝色的 “重启” 按钮，重启Linux系统。</p><p><strong>14). 登录系统</strong></p><p><img src="https://img-blog.csdnimg.cn/ec966e2d86ca4e6c9b225ff5ea8d5384.png#pic_center" alt="在这里插入图片描述"></p><blockquote><p><font color='red'>注意 : 在Linux系统中，在命令行中输入密码信息，为了保证安全性，密码是不显示的(看似没有输入，实际已经输入了)；</font></p></blockquote><p>2). 重新启动虚拟机</p><p><img src="https://img-blog.csdnimg.cn/0cd0de4a414343f69a4f2951343c7ba0.png#pic_center" alt="在这里插入图片描述"></p><p>有可能会出现的问题：</p><p><img src="https://img-blog.csdnimg.cn/fee2c27a2d64455f96b7d94af5fff58a.png#pic_center" alt="在这里插入图片描述"><br>    <strong>解决方案的步骤：</strong></p><p>​1. 根据你机器的型号百度如何进入bios</p><pre><code>                  2.  在bios里面开启虚拟化即可。</code></pre><h3 id="1-4-安装SSH连接工具"><a href="#1-4-安装SSH连接工具" class="headerlink" title="1.4 安装SSH连接工具"></a>1.4 安装SSH连接工具</h3><p>以后我们进入企业工作，每个开发人员都是通过客户端软件连接公司的服务器， 所以我们需要使用客户端</p><p>客户端操作效果非常好</p><h4 id="虚拟机操作linux系统的问题"><a href="#虚拟机操作linux系统的问题" class="headerlink" title="虚拟机操作linux系统的问题"></a>虚拟机操作linux系统的问题</h4><p><img src="https://img-blog.csdnimg.cn/8fe83e81e3f94f6b85e28142573d5ac7.png#pic_center" alt="在这里插入图片描述"></p><h4 id="常见的客户端软件"><a href="#常见的客户端软件" class="headerlink" title="常见的客户端软件"></a>常见的客户端软件</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.SecureCRT</span>(操作客户端命令)，SecureFx（用于传输文件）</span><br><span class="line"><span class="number">2</span><span class="selector-class">.XShell</span>(操作客户端命令),XFtp（用于传输文件）</span><br><span class="line"><span class="number">3</span><span class="selector-class">.ModaXterm</span>软件（简单好用，推荐使用）</span><br><span class="line">上面的软件根据文档安装（《资料\<span class="number">03</span>_使用客户端连接工具连接linux系统操作\客户端软件<span class="number">3</span><span class="built_in">_MobaXterm</span>(推荐)》）</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/df069f1cf0514f629213d390e540e543.png#pic_center" alt="在这里插入图片描述"></p><p>进入目录, 下一步下一步安装即可</p><h4 id="ModaXterm软件的使用"><a href="#ModaXterm软件的使用" class="headerlink" title="ModaXterm软件的使用"></a>ModaXterm软件的使用</h4><p>1.建立连接服务器linux的会话， 查看linux 的机器的ip地址的命令： ifconfig</p><p><img src="https://img-blog.csdnimg.cn/d050b305eab442c7960641631e4c5ea3.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/14b8a2650d4e4b98a0f5b9a0ae415e1c.png#pic_center" alt="在这里插入图片描述"></p><p>使用界面</p><p><img src="https://img-blog.csdnimg.cn/f8b18e6de21c4d8a9d9a2cf6e9ff96c2.png#pic_center" alt="在这里插入图片描述"></p><h4 id="客户端的好处"><a href="#客户端的好处" class="headerlink" title="客户端的好处"></a>客户端的好处</h4><p><img src="https://img-blog.csdnimg.cn/7eea7c7da93b4bfa8e726f8aabd610d0.png#pic_center" alt="在这里插入图片描述"></p><h4 id="传递文件"><a href="#传递文件" class="headerlink" title="传递文件"></a>传递文件</h4><p><img src="https://img-blog.csdnimg.cn/28cdba66c12148e4807d97aae01d5a7a.png#pic_center" alt="在这里插入图片描述"></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><strong>为什么我们需要使用linux的客户端软件？</strong></p><ul><li><p>远程连接linux的服务器，方便我们查看日志信息</p></li><li><p>我们写好的代码可以直接上传到服务器上。</p></li></ul><h3 id="1-5-Linux目录结构"><a href="#1-5-Linux目录结构" class="headerlink" title="1.5 Linux目录结构"></a>1.5 Linux目录结构</h3><p>登录到Linux系统之后，我们需要先来熟悉一下Linux的目录结构。在Linux系统中，也是存在目录的概念的，但是Linux的目录结构和Windows的目录结构是存在比较多的差异的 在Windows目录下，是一个一个的盘符(C盘、D盘、E盘)，目录是归属于某一个盘符的。Linux系统中的目录有以下特点： </p><p><strong>A. &#x2F; 是所有目录的顶点</strong></p><p><strong>B. 目录结构像一颗倒挂的树</strong></p><p><strong>Linux 和 Windows的目录结构对比:</strong> </p><p><img src="https://img-blog.csdnimg.cn/8337d26dac0e499782671a5761fe5c9c.png#pic_center" alt="在这里插入图片描述"></p><p>Linux的目录结构，如下： </p><p><img src="https://img-blog.csdnimg.cn/037d0ef581c44fb2bf7e99d2470e32c7.png#pic_center" alt="在这里插入图片描述"></p><p>根目录&#x2F; 下各个目录的作用及含义说明:  </p><table><thead><tr><th>编号</th><th>目录</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>&#x2F;bin</td><td>存放二进制可执行文件</td></tr><tr><td>2</td><td>&#x2F;boot</td><td>存放系统引导时使用的各种文件</td></tr><tr><td>3</td><td>&#x2F;dev</td><td>存放设备文件</td></tr><tr><td>4</td><td>&#x3D;&#x3D;&#x2F;etc&#x3D;&#x3D;</td><td>存放系统配置文件，  比如：安装完毕jdk，安装maven、配置环境变量</td></tr><tr><td>5</td><td>&#x3D;&#x3D;&#x2F;home&#x3D;&#x3D;</td><td>用户的主目录,存放用户的个人资料的。比如：linux是一个多用户的操作系统，创建了zhangsan用户，那么在home目录里面有zhangsan文件夹。</td></tr><tr><td>6</td><td>&#x2F;lib</td><td>存放程序运行所需的共享库和内核模块</td></tr><tr><td>7</td><td>&#x2F;opt</td><td>额外安装的可选应用程序包所放置的位置</td></tr><tr><td>8</td><td>&#x3D;&#x3D;&#x2F;root&#x3D;&#x3D;</td><td>超级管理员的主目录</td></tr><tr><td>9</td><td>&#x2F;sbin</td><td>存放二进制可执行文件，只有root用户才能访问</td></tr><tr><td>10</td><td>&#x2F;tmp</td><td>存放临时文件</td></tr><tr><td>11</td><td>&#x3D;&#x3D;&#x2F;usr&#x3D;&#x3D;</td><td>以后我们安装软件都存储在该目录中</td></tr><tr><td>12</td><td>&#x2F;var</td><td>存放运行时需要改变数据的文件，例如日志文件</td></tr></tbody></table><h4 id="小结：常用的目录"><a href="#小结：常用的目录" class="headerlink" title="小结：常用的目录"></a>小结：常用的目录</h4><ul><li>etc 存放系统的配置信息，比如：环境变量</li><li>home: 存放用户的主目录的，当你有一个张三的用户，里面就有一个张三的文件夹</li><li>root”: 超级管理员的主目录<br>                                  |<br>| 11   | &#x3D;&#x3D;&#x2F;usr&#x3D;&#x3D;  | 以后我们安装软件都存储在该目录中                             |<br>| 12   | &#x2F;var      | 存放运行时需要改变数据的文件，例如日志文件                   |</li></ul><h4 id="小结：常用的目录-1"><a href="#小结：常用的目录-1" class="headerlink" title="小结：常用的目录"></a>小结：常用的目录</h4><ul><li>etc 存放系统的配置信息，比如：环境变量</li><li>home: 存放用户的主目录的，当你有一个张三的用户，里面就有一个张三的文件夹</li><li>root”: 超级管理员的主目录</li><li>usr: 一般软件的安装都在改目录</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助</summary>
      
    
    
    
    <category term="SOP操作手册" scheme="https://onlyonemomo.github.io/categories/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    
    
    <category term="SOP" scheme="https://onlyonemomo.github.io/tags/SOP/"/>
    
  </entry>
  
  <entry>
    <title>Springboot自动装配的原理</title>
    <link href="https://onlyonemomo.github.io/2022/08/24/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/Springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B9%8B%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/"/>
    <id>https://onlyonemomo.github.io/2022/08/24/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/Springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B9%8B%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</id>
    <published>2022-08-24T10:12:40.000Z</published>
    <updated>2022-08-26T10:58:27.673Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语</strong>：在《通往java之路》这个栏目，我不想表现出更多的功利主义。我希望在这个栏目中每一篇文章都有很强的可读性和趣味性，能让我闲暇之时也能好好的阅读。</p><h3 id="一、springboot是如何实现自动装配的呢-？"><a href="#一、springboot是如何实现自动装配的呢-？" class="headerlink" title="一、springboot是如何实现自动装配的呢 ？"></a>一、springboot是如何实现自动装配的呢 ？</h3><h5 id="1、-SpringBootApplication注解"><a href="#1、-SpringBootApplication注解" class="headerlink" title="1、@SpringBootApplication注解"></a>1、@SpringBootApplication注解</h5><p>首先我们得看源码，springboot类中有一个注解<code>@SpringBootApplication</code>,这是一个组合注解。我们点击进去看一下：<br>图1：<br><img src="https://img-blog.csdnimg.cn/7c13fd147fdf4822a72e57eb91cbff10.png#pic_center" alt="在这里插入图片描述"></p><p>图2：点进去之后可以看到如下图<br><img src="https://img-blog.csdnimg.cn/1ce9583c02b54ac0a42ec3636e6f8d12.png#pic_center" alt="在这里插入图片描述"></p><p>(1) 第一类: JDK原生注解4个</p><blockquote><p>@Target(ElementType.TYPE) &#x2F;&#x2F;当前注解的使用范围<br>@Retention(RetentionPolicy.RUNTIME) &#x2F;&#x2F;生命周期<br>@Documented &#x2F;&#x2F;声明在生成doc文档时是否带着注解<br>@Inherited &#x2F;&#x2F;声明是否子类会显示父类的注解</p></blockquote><p>@SpringBootApplication中有3个主要注解 </p><blockquote><p>1.@SpringBootConfiguration   &#x2F;&#x2F;表示该类是一个配置类<br>2.@ComponentScan &#x2F;&#x2F;包扫描，扫描启动类所在的包与启动类所在的子包<br>3.@EnableAutoConfiguration  &#x2F;&#x2F;开启自动装配</p></blockquote><h5 id="2、-EnableAutoConfiguration"><a href="#2、-EnableAutoConfiguration" class="headerlink" title="2、@EnableAutoConfiguration"></a>2、@EnableAutoConfiguration</h5><p>@EnableAutoConfiguration这个注解是开启自动装配的注解核心，它的作用就是获取配置类，扫描并注入IOC容器中管理，它也是一个组合注解。我们点进去看源码。<br>图3：<br><img src="https://img-blog.csdnimg.cn/75039d26741642749047542cf8ee9e99.png#pic_center" alt="在这里插入图片描述"></p><p>我们可以看到**@Import({AutoConfigurationImportSelector.class})** 导入<strong>AutoConfigurationImportSelector.class</strong>这个类，这里面有一个selectImports方法里面调用了getCandidateConfigurations方法去加载META-INF&#x2F;spring.factories文件。<br>图4：进入AutoConfigurationImportSelector类可看到selectImports方法<br><img src="https://img-blog.csdnimg.cn/0ec3b28c750144888588398b804d4161.png#pic_center" alt="在这里插入图片描述"></p><p>图5：点击getAutoConfigurationEntry方法进入可看到getCandidateConfigurations<br><img src="https://img-blog.csdnimg.cn/a29b62a07bd74993b1ba8e012798f727.png#pic_center" alt="在这里插入图片描述"></p><p>图6：从这里可以看到getCandidateConfigurations加载了META-INF&#x2F;spring.factories文件<br><img src="https://img-blog.csdnimg.cn/9a0a0ce2e1624ebfb17678338ca445c4.png#pic_center" alt="在这里插入图片描述"></p><h5 id="3、META-INF-x2F-spring-factories是用来干嘛的？"><a href="#3、META-INF-x2F-spring-factories是用来干嘛的？" class="headerlink" title="3、META-INF&#x2F;spring.factories是用来干嘛的？"></a>3、META-INF&#x2F;spring.factories是用来干嘛的？</h5><blockquote><p>该文件是定义了springboot自动装配的框架自动装配类</p></blockquote><p>图7：</p><p><img src="https://img-blog.csdnimg.cn/cbd933b0b0d5454885b75c61e1de1aea.png#pic_center" alt="在这里插入图片描述"></p><p>怎么确认自动装配类不会把所有的装配类加载进来呢？这个时候我们点进去RedisAutoConfiguration这个装配类，可以看到@ConditionalOnClass(RedisOperations.class)，也就是说有这个类在内存中，这个类才会被加载。<br>图8：<br><img src="https://img-blog.csdnimg.cn/fb86b23ad9724cda98f5fa6db9e6961a.png#pic_center" alt="在这里插入图片描述"></p><h5 id="4、这个类在哪里呢？怎么样才会被自动装配加载？"><a href="#4、这个类在哪里呢？怎么样才会被自动装配加载？" class="headerlink" title="4、这个类在哪里呢？怎么样才会被自动装配加载？"></a>4、这个类在哪里呢？怎么样才会被自动装配加载？</h5><p>一旦导入这个类的启动器，那么就会被自动装配加载。<br>图9：<br><img src="https://img-blog.csdnimg.cn/1bdf0ee391484cb6aa74ed284dd4be6a.png#pic_center" alt="在这里插入图片描述"></p><p>总结：Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF&#x2F;spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的。通过SpringFactoriesLoader机制创建对应的bean，注入到容器中，完成了自动注入spring容器，本来需要在spring的xml配置文件中去配置bean的操作就免去了 ，也就是springboot完成了自动装配。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;：在《通往java之路》这个栏目，我不想表现出更多的功利主义。我希望在这个栏目中每一篇文章都有很强的可读性和趣味性，能让我闲暇之时也能好好的阅读。&lt;/p&gt;
&lt;h3 id=&quot;一、springboot是如何实现自动装配的呢-？&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="通往java之路" scheme="https://onlyonemomo.github.io/categories/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>30道高频面试题答案</title>
    <link href="https://onlyonemomo.github.io/2022/08/24/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/30%E9%81%93%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    <id>https://onlyonemomo.github.io/2022/08/24/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/30%E9%81%93%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/</id>
    <published>2022-08-24T09:03:39.000Z</published>
    <updated>2022-08-24T09:04:01.875Z</updated>
    
    <content type="html"><![CDATA[<h5 id="springcloud常用组件"><a href="#springcloud常用组件" class="headerlink" title="springcloud常用组件"></a>springcloud常用组件</h5><p>Eureka：服务注册和发现，由Netflix开源</p><p>Nacos：服务注册和发现，还有配置管理功能，由阿里巴巴开源</p><p>SpringCloudGateway：微服务网关，实现微服务统一路由，统一鉴权，跨域，限流等功能</p><p>Feign：微服务之间远程调用，由Netflix开源</p><p>Ribbon：负载均衡组件，在网关路由和Feign远程调用过程中的底层都会用到Ribbon做负载均衡。</p><h5 id="springboot的常用注解"><a href="#springboot的常用注解" class="headerlink" title="springboot的常用注解"></a>springboot的常用注解</h5><ul><li>@SpringBootApplication：SpringBoot项目最核心的主键。每个SpringBoot启动类上都有，用于引导SpringBoot项目启动加载。</li><li>@ComponentScan：用于扫描Spring的组件，并将其放入IOC容器。</li><li>@Configuration：声明该类为配置类</li><li>@ConditionOnClass：一般和@Configuration注解同时使用，项目中导入了@ConditionOnClass声明的类，@Configuration中的@Bean才会构建。</li><li>@ControllerAdvice和@RestControllerAdvice：声明该类为全局异常拦截类。</li></ul><h5 id="springboot自动装配"><a href="#springboot自动装配" class="headerlink" title="springboot自动装配"></a>springboot自动装配</h5><ul><li>在启动类启动时加载@SpringBootApplication注解</li><li>在@SpringBootApplication注解里面包含三个注解：@ComponentScan，@Configuration，@EnableAutoConfiguration</li><li>@Configuration表明启动类是一个配置类</li><li>@ComponentScan自动扫描启动类所在目录及子目录在Spring组件，让其实例化</li><li>@EnableAutoConfiguration注解里面包含AutoConfigurationImportSelector配置类<br>在AutoConfigurationImportSelecto配置类中会读取springboot自动配置包中的META-INF的spring.factories文件</li><li>该spring.factories文件包含一百多个SpringBoot写好的自动配置类，但这些自动配置类并不是默认生效的，而是根据环境中导入starter启动器依赖及自动配置类上@ConditionalOnClass注解来决定该配置类是否生效。一旦自动配置类生效了，里面@Bean注解会把创建实例放入IOC容器，我们在项目中就可以随时使用@Autowired进行注入并使用</li></ul><h5 id="springmvc和springboot的关系"><a href="#springmvc和springboot的关系" class="headerlink" title="springmvc和springboot的关系"></a>springmvc和springboot的关系</h5><p> Spring MVC提供了一种轻度耦合的方式来开发web应用。它是Spring的一个模块，是一个web层框架。 </p><p> Spring Boot实现了自动配置，降低了Spring项目搭建的复杂度。 </p><p> Spring Boot 只是 辅助你简化Spring项目搭建过程的 ，如果搭建的是Web项目，Web层采用SpringMVC，那么SpringMVC的工作原理还是和原来一样的，并没有因为用了SpringBoot而被改变。</p><h5 id="谈谈对spring的理解"><a href="#谈谈对spring的理解" class="headerlink" title="谈谈对spring的理解"></a>谈谈对spring的理解</h5><p>Spring的核心组件是：IOC（控制翻转）、DI（依赖注入）和AOP（面向切面编程）</p><ul><li>IOC意思是控制反转，IOC让对 象的创建不用去new了，可以由spring根据我们提供的配置文件自动生产，我们需要对象的时候， 直接从Spring容器中获取即可。</li><li>DI的意思是依赖注入，意思是程序在运行时依赖Ioc容器来动态注入对象需要的对象。 </li><li>AOP，一般称为面向切面编程，可以方便将项目中与核心业务无关的代码进行抽取分离，最大程度地解耦。SpringAOP的底层一般采用JDK动态代理或者CGLIB动态代理实现。</li></ul><h5 id="spring-bean的生命周期"><a href="#spring-bean的生命周期" class="headerlink" title="spring bean的生命周期"></a>spring bean的生命周期</h5><ul><li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li><li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li><li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li><li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li><li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li><li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li><li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li><li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li><li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li></ul><h5 id="spring的ioc、di、aop分别是什么，ioc和di有什么关系"><a href="#spring的ioc、di、aop分别是什么，ioc和di有什么关系" class="headerlink" title="spring的ioc、di、aop分别是什么，ioc和di有什么关系"></a>spring的ioc、di、aop分别是什么，ioc和di有什么关系</h5><ul><li><p>IOC意思是控制反转，IOC让对 象的创建不用去new了，可以由spring根据我们提供的配置文件自动生产，我们需要对象的时候， 直接从Spring容器中获取即可。</p></li><li><p>DI的意思是依赖注入，意思是程序在运行时依赖Ioc容器来动态注入对象需要的对象。 </p></li><li><p>AOP，一般称为面向切面编程，可以方便将项目中与核心业务无关的代码进行抽取分离，最大程度地解耦。SpringAOP的底层一般采用JDK动态代理或者CGLIB动态代理实现。</p></li><li><p>IOC侧重于构建对象上的解耦，对象构建交给SpringIOC容器构建。</p></li><li><p>DI侧重于使用对象上的解耦，需要使用什么对象从SpringIOC容器获取。</p></li></ul><h5 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h5><p>事务是一组原子操作单元，从数据库角度说，就是一组SQL指令，要么全部执行成功，若因为某个原因其中一条指令执行有错误，则撤销先前执行过的所有SQL指令。更简答的说就是：SQL要么全部执行成功，要么撤销不执行。 </p><h5 id="事务的四大特性和隔离级别"><a href="#事务的四大特性和隔离级别" class="headerlink" title="事务的四大特性和隔离级别"></a>事务的四大特性和隔离级别</h5><p><strong>事务特性</strong> </p><ul><li><p><strong>原子性</strong>：即不可分割性，事务要么全部被执行，要么就全部不被执行。 </p></li><li><p><strong>一致性</strong>：事务的执行使得数据库从一种正确状态转换成另一种正确状态 </p></li><li><p><strong>隔离性</strong>：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务， </p></li><li><p><strong>持久性</strong>：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处 </p><p>理结果也会得到保存。</p></li></ul><p><strong>隔离级别</strong> </p><p>（1）<strong>读未提交</strong>（read Uncommited）: </p><p>在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项目中基本不 怎么用， 安全性太差； </p><p>(2) <strong>读已提交</strong>（read commited）: </p><p>这是大多数数据库默认的隔离级别，但是不是MySQL的默认隔离级别；这个隔离级别满足了简单的隔离 要求：一个事务只能看见已经提交事务所做的改变，所以会避免脏读问题； 由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读和虚读等问题</p><p>(3) <strong>可重复读</strong>（Repeatable read）： 这是MySQL的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取到一样的数 据；不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读 取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发生幻读。</p><p>(4**)** <strong>可串行化</strong>（serializable）： 事物的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每 个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争，一般为了提升程序的吞吐量不会采用这个；</p><h5 id="悲观锁和乐观锁的区别和应用场景"><a href="#悲观锁和乐观锁的区别和应用场景" class="headerlink" title="悲观锁和乐观锁的区别和应用场景"></a>悲观锁和乐观锁的区别和应用场景</h5><p>什么是悲观锁：</p><ul><li>总是假设最坏的情况，<strong>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上</strong> <strong>锁</strong>，这样别人想拿这个数据就会阻塞直到它拿到锁。</li></ul><p>悲观锁的应用场景： </p><ul><li>关系数据库的行级锁和表级锁等。</li></ul><p>什么是乐观锁：</p><p>总是假设最好的情况，<strong>每次去拿数据的时候都认为别人不会修改，所以不会上锁</strong>，但是在更新的时候会判断在此期间别人有没有去更新这个数据。</p><p>乐观锁的实现方式： </p><ul><li>可以使用<strong>版本号机制</strong>和CAS算法实现 版本号机制 在数据表中加入一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version 指会加一。当线程A要重新更新数据值时，在读取数据的时候也会读取version值，在提交更新 时，若刚才读取到的version值与当前数据库中的version值相等才更新，否则重新更新操作，直到 更新成功。</li></ul><p>悲观锁与乐观锁的应用差别：</p><ul><li><strong>乐观锁</strong>适用于写少读多的场景。这样可以省去了锁的开销，加 大了系统的整个<strong>吞吐量</strong>。</li><li><strong>悲观锁</strong>更适合读少写多的场景。因为如果在写多的场景下使用乐观锁，会导致应用会不断的进行重试，这样反倒是降低了性能，所以一般写多的场景下更适合才用<strong>悲观锁</strong>。</li></ul><h5 id="redis的数据类型，持久化方式"><a href="#redis的数据类型，持久化方式" class="headerlink" title="redis的数据类型，持久化方式"></a>redis的数据类型，持久化方式</h5><p>redis有5种数据类型：</p><ul><li>String</li><li>Set</li><li>List</li><li>Hash</li><li>SortedSet</li></ul><p>Redis持久化方式：</p><p>有两种，分别是RDB和AOF。RDB原理是对整个当前内存数据进行快照备份，体积小。AOF原理是每条操作指令都会持久化到文件，导致文件体积比较大RDB的两次备份时间间隔最短1分钟，时间长，容易导致数据丢失。而AOF默认间隔1秒1次，时间短，数据完整性高！恢复速度上来说，RDB比AOF稍快一些，因为体积小。</p><h5 id="redis缓存穿透、雪崩、击穿"><a href="#redis缓存穿透、雪崩、击穿" class="headerlink" title="redis缓存穿透、雪崩、击穿"></a>redis缓存穿透、雪崩、击穿</h5><p>什么是缓存雪崩：</p><p>缓存雪崩，即缓<strong>存同一时间大面积的失效</strong>，这个时候又来了一波 请求，结果请求都怼到数据库上，从而导致数据库连接异常。 </p><p>缓存雪崩解决方案： </p><p>1、给缓存的<strong>失效时间，加上一个随机值，避免集体失效</strong>。 </p><p>2、使用互斥锁，但是该方案吞吐量明显下降了。 </p><p>3、搭建 redis 集群</p><p>缓存击穿和缓存雪崩类似的，雪崩的大面积的key失效，击穿一般是个别key失效，解决办法可以和雪崩一样答。</p><p>什么是缓存穿透：</p><p><strong>缓存穿透，即黑客故意去请求缓存中不存在的数据</strong>，导致所有的请求都怼到数据库上，从而数据库连接 异常。 </p><p>缓存穿透解决方案： </p><p>1、利用互斥锁，缓存失效的时候，先去获得锁，得到锁了， 再去请求数据库。没得到锁，则休眠一段时间重试 </p><p>2、采用异步更新策略，无论 key 是否取到值，都直接返回， value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程 去读数据库，更新缓存。</p><h5 id="java的基本数据类型"><a href="#java的基本数据类型" class="headerlink" title="java的基本数据类型"></a>java的基本数据类型</h5><p> <strong>字节型（byte）、短整型（short）、整型（int）、长整型（long）、单精度浮点型（float）和双精度浮点型（double）、布尔型（boolean）、字符型（char）</strong> </p><h5 id="arraylist和linkedlist"><a href="#arraylist和linkedlist" class="headerlink" title="arraylist和linkedlist"></a>arraylist和linkedlist</h5><p>arraylist和linkedlist作用 </p><p>ArrayList和LinkedList都是实现了List接口的容器类，用于存储一系列的对象引用。他们都可以对元素的 </p><p>增删改查进行操作。 对于ArrayList<strong>，它在集合的末尾删除或添加元素所用的时间是一致的，但是在列表中间的部分添加或删*除时</strong>所用<strong>时间就会大大增加</strong>。但是它在根据索引<strong>查找元素</strong>的时候<strong>速度很快</strong>。 </p><p>对于LinkedList则相反<strong>，它在</strong>插入、删除<strong>集合中任何位置的元素所</strong>花费的时间都是一样<strong>的，但是它查</strong>询一个元素<strong>的时候却</strong>比较慢。 </p><p>arraylist和linkedlist区别 </p><p>1**.ArrayList<strong>是实现了</strong>基于动态数组<strong>的数据结构，</strong>LinkedList<strong>是</strong>基于链表**结构。 </p><p>2.对于<strong>随机访问</strong>的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。 </p><p>3.对于新增和删除操作add和remove<strong>，</strong>LinkedList比较占优势，因为ArrayList要移动数据。 </p><h5 id="hashtable和hashmap"><a href="#hashtable和hashmap" class="headerlink" title="hashtable和hashmap"></a>hashtable和hashmap</h5><p>1、HashMap 是<strong>非线程安全</strong>的，HashTable 是线程<strong>安全</strong>的。 </p><p>2、HashMap 的键和值都<strong>允许有</strong> <strong>null</strong> <strong>值</strong>存在，而 HashTable 则<strong>不行</strong>。 </p><p>3、因为线程安全的问题，HashMap <strong>效率</strong>比 HashTable 的<strong>要高</strong>。 </p><p>4、Hashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线 <strong>程环境</strong>，而 Hashtable 适合于多线程环境。一般现在不建议用 HashTable, ① 是 HashTable 是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下， 现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用HashTable。 </p><h5 id="jvm内存溢出"><a href="#jvm内存溢出" class="headerlink" title="jvm内存溢出"></a>jvm内存溢出</h5><p> 在Java程序中，出现内存溢出的原因也有很多，常见的有堆内存溢出，直接内存溢出，永久区&#x2F;元空间溢出 </p><p>1）堆内存溢出：</p><p> 堆溢出这种是最常见的一种，在Java中堆是重要的一个空间，Java的大量对象都是直接在堆上分配的(参考<strong>内存分配</strong>)。当大量对象占据了堆空间而且都是强引用，使之始终无法被回收，当所有对象大小之和大于参数<code>-Xmx</code>指定的值时，就会出现溢出了。 </p><p>如何处理</p><ul><li>首选检查代码是否存在循环或者死循环，是否能够不断的创建对象。</li><li>查看启动参数<code>-Xmx</code>和<code>-Xms</code> 设置的堆内存是否过小，不足以加载服务中的所有类，可以适当增加。</li><li>检查代码中是否存在数据库查询，没有分页一次性返回大量数据。</li><li>还可以通过MAT或者<strong>VisualVM工具</strong>分析，找到占用大量堆空间的对象，然后做出合理优化。</li></ul><p>2）<strong>直接内存溢出</strong></p><p>这个问题遇到的一般比较少，直接内存不是运行时数据区的一部分。</p><p>Java中NIO(New IO)是支持直接使用直接内存的，可以直接获取一块堆外空间使用，而这块空间是直接向操作系统申请的。直接内存的申请速度一般比堆内存慢，但是其访问速度要快于堆内存，所以如果存在可复用且经常被访问的空间，使用直接内存可以提高系统的性能。但是直接内存没有被Java完全托管，使用不当容易出现溢出的问题。</p><p>如何处理：</p><ul><li>检查程序中使用直接内存的代码是否恰当。</li><li>检查参数-Xmx和-XX:MaxDirectMemorySize 的大小是否合理，可以根据实际情况调整其大小。</li></ul><p>3）永久区&#x2F;元空间溢出 </p><p>这种错误是永久代或者元空间溢出，在jdk1.8之前会出现这种错误，之后hotspot用元空间代替了永久代来存储class信息。如果一个系统在不断的创建新的类(不是对象实例)，那么最终会导致元空间溢出的。</p><p>如何处理：</p><ul><li>增加元空间的大小，设置其对应参数的值 <code>-XX:MaxMetaspaceSize=512m</code></li><li>减少系统需要的类的数量，检查是否有不需要的类并且清除掉。</li><li>使用ClassLoader合理的装载各个类，并定期进行回收。</li></ul><h5 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h5><p>调优目的：</p><p> 对JVM内容的系统级的调优主要的目的是减少GC的频率和Full GC的次数。 </p><p>调优步骤：</p><p>a. 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</p><p>b. 确定jvm调优量化目标；</p><p>c. 确定jvm调优参数（根据历史jvm参数来调整）；</p><p>d. 调优一台服务器，对比观察调优前后的差异；</p><p>e. 不断的分析和调整，知道找到合适的jvm参数配置；</p><p>f. 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</p><p>调优常见参数：<br>1）设定堆内存大小（比较常用的）<br>-Xmx：堆内存最大限制。</p><p>2）设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代<br>-XX:NewSize：新生代大小<br>-XX:NewRatio  新生代和老生代占比<br>-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比</p><p>3）设定垃圾回收器算法<br>年轻代用  -XX:+UseParNewGC<br>年老代用-XX:+UseConcMarkSweepGC</p><h5 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h5><ul><li>继承Thread类创建线程类 </li><li>通过Runnable接口创建线程类 </li><li>通过Callable和Future创建线程</li></ul><h5 id="线程池有几种"><a href="#线程池有几种" class="headerlink" title="线程池有几种"></a>线程池有几种</h5><ol><li><p><strong>newCachedThreadPool</strong>：创建一个<strong>可进行缓存重复利用的线程池</strong> </p></li><li><p><strong>newFixedThreadPool</strong>：创建一个可重用<strong>固定线程数的线程池</strong>，以共享的无界队列方式来运行这些</p></li></ol><p>线程，线程池中的线程处于一定的量，可以很好的控制线程的并发量 </p><ol start="3"><li><strong>newSingleThreadExecutor</strong>：创建一个使用单个 worker 线程的Executor ，以无界队列方式来运行</li></ol><p>该线程。线程池中<strong>最多执行一个线程，之后提交的线程将会排在队列中以此执行</strong> </p><ol start="4"><li><strong>newSingleThreadScheduledExecutor</strong>：创建<strong>一个单线程</strong>执行程序，它可安排在<strong>给定延迟后运行命</strong></li></ol><p><strong>令或者定期执行</strong> </p><ol start="5"><li><p><strong>newScheduledThreadPool</strong>：创建一个线程池，它可安排在给<strong>定延迟后运行命令或者定期的执行</strong> </p></li><li><p><strong>newWorkStealingPool</strong>：创建一个带并<strong>行级别的线程池</strong>，并行级别决定了同<strong>一时刻</strong>最多有<strong>多</strong>少个</p></li></ol><p><strong>线程在执行</strong>，如不传并行级别参数，将默认为当前系统的<strong>CPU核心数</strong>*2</p><h5 id="mysql的引擎有几种"><a href="#mysql的引擎有几种" class="headerlink" title="mysql的引擎有几种"></a>mysql的引擎有几种</h5><p>InnoDB：MySQL默认存储引擎。支持事务。支持行级锁和表级锁。索引采用聚簇索引（索引和数据存储在一个文件，提升查询性能）。</p><p>MyISAM：不支持事务。仅仅支持表级锁。索引采用非聚簇索引（索引和数据分开存储，查询性能差一些）。</p><h5 id="项目中有没有设计表，都有哪些字段"><a href="#项目中有没有设计表，都有哪些字段" class="headerlink" title="项目中有没有设计表，都有哪些字段"></a>项目中有没有设计表，都有哪些字段</h5><p>根据自己项目自由发挥</p><h5 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h5><p>首先开启数据库慢查询日志，定位到查询效率比较低的sql , 找出对应的sql语句并进行分析</p><p>1.表设计是否规范，是否符合三范式的标准</p><p>(1)第一范式：保证原子性(不可拆分)</p><p>(2)第二范式：每张表都有主键</p><p>(3)第三范式(每一列都有主键相关)</p><p>2.查看数据表中是否存在大量的冗余字段，字段数据类型是否合理</p><p>3.尽可能的使用varchar代替char 建表数据类型，能用数值的绝对不用字符存储</p><p>4.尽量避免null值，使用默认值替代空值，数值型可以使用0，字符型可以使用空字符串</p><p>查看sql语句是否规范：</p><p>(1)避免使用关键字：or ，in，not in ，!&#x3D;，&lt;&gt;，避免使用select *</p><p>(2)尽量避免子查询，大部分子查询都可以连接查询</p><p>(3)用到or的地方可以使用union去代替实现</p><p>(4)用到in的地方可以使用exists去代替</p><p>分析sql的索引是否可以用上：</p><p>(1) explain查询sql的执行计划,重点关注的几个列就是，type是不是全表扫描</p><p>(2)看一下索引是否能够用的上,主要看key使用的是哪个索引</p><p>(3)看一下rows扫描行数是不是很大</p><h5 id="eureka和nacos的区别"><a href="#eureka和nacos的区别" class="headerlink" title="eureka和nacos的区别"></a>eureka和nacos的区别</h5><p>1）Nacos可以实现服务注册发现，也可以做配置管理；Eureka只能做服务注册发现。<br>2）Nacos临时实例心跳不正常会被剔除，非临时实例（永久实例）则不会被剔除；而Eureka只能注册临时实例，实例失效会被剔除（Eureka不支持永久实例）<br>3）Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式；而Eureka只有心跳模式；<br>4）Nacos支持服务列表变更的消息主动通知模式，服务列表更新更及时，减少服务调用失败的机率；而Eureka采用被动定时服务列表拉取更新；</p><h5 id="项目中用到什么设计模式，单例有几种"><a href="#项目中用到什么设计模式，单例有几种" class="headerlink" title="项目中用到什么设计模式，单例有几种"></a>项目中用到什么设计模式，单例有几种</h5><ul><li>单例设计模式 </li><li>代理模式 </li><li>装饰者</li><li>工厂模式</li><li>建造者模式</li></ul><p>单例有懒汉式 和 饿汉式</p><h5 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h5><ol><li><p>用户发送请求到前端控制器（DispatcherServlet）</p></li><li><p>前端控制器（DispatcherServlet）收到请求调用处理器映射器（HandlerMapping），去查找处理器 （Handler） </p></li><li><p>处理器映射器（HandlerMapping）找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </p></li><li><p>前端控制器（DispatcherServlet）调用处理器映射器（HandlerMapping） </p></li><li><p>处理器适配器（HandlerAdapter）去调用自定义的处理器类(Controller，也叫后端控制器)。 自定义的处理器类(Controller，也叫后端控制器)将得到的参数进行处理并返回结果给处理器映 射器（HandlerMapping） </p></li><li><p>处理器适配器（HandlerAdapter）将得到的结果返回给前端控制器（DispatcherServlet） </p></li><li><p>DispatcherServlet(前端控制器)将ModelAndView传给视图解析器(ViewReslover) </p></li><li><p>视图解析器(ViewReslover)将得到的参数从逻辑视图转换为物理视图并返回给前端控制器</p></li></ol><p>（DispatcherServlet） </p><ol start="9"><li><p>前端控制器（DispatcherServlet）调用物理视图进行渲染并返回 </p></li><li><p>前端控制器（DispatcherServlet）将渲染后的结果返回</p></li></ol><h5 id="mybatis的-和"><a href="#mybatis的-和" class="headerlink" title="mybatis的$和#"></a>mybatis的$和#</h5><p><strong>1， #是一个占位符，$是拼接符。</strong></p><p> #是一个占位符，$是拼接符。</p><p><strong>（1）</strong>使用#parameterName方式引用参数的时候，Mybatis会把传入的参数当成是一个字符串，自动添加双引号。</p><p>（2）使用$parameterName引用参数时，不做任何处理，直接将值拼接在sql语句中。</p><p><strong>2，使用 # 能够防止sql注入，$不能避免注入攻击。</strong></p><p>   #的方式引用参数，mybatis会先对sql语句进行预编译，然后再引用值，能够有效防止sql注入，提高安全性。$的方式引用参数，sql语句不进行预编译。</p><h5 id="为什么要用es，es的倒排索引是什么"><a href="#为什么要用es，es的倒排索引是什么" class="headerlink" title="为什么要用es，es的倒排索引是什么"></a>为什么要用es，es的倒排索引是什么</h5><p>为什么用ES？</p><p>1）MySQL的海量数据时，搜索效率比较低，而Elasticsearch采用倒排索引法检测数据，从而效率更高。<br>2）MySQL的搜索功能比较弱，只有like这种模糊搜索，而Elasticsearch拥有大量复杂搜索的API，更加适合数据搜索场景</p><p>ES的倒排索引：</p><p>1）首先，Elasticsearch将文档数据进行索引构建。将文档数据需要分词的字段内容使用分词器进行分词，并记录每个词条和原文档的出现位置和出现频率等信息，构建出文档的索引库。<br>2）然后，用户搜索时，可以对关键词进行分词，使用分词后词条来匹配索引库，在索引库匹配到记录后，通过文档位置频率信息，反查具体的文档数据。</p><h5 id="rabbitmq-x2F-rocketmq、kafka的了解"><a href="#rabbitmq-x2F-rocketmq、kafka的了解" class="headerlink" title="rabbitmq&#x2F;rocketmq、kafka的了解"></a>rabbitmq&#x2F;rocketmq、kafka的了解</h5><p>RabbitMQ：<br>优势：<br>1）支持语言非常广<br>2）稳定性很好，采用Erlang语言开发<br>3）吞吐量不算低，万级<br>4）RabbitMQ官方提供7种消息发送模式，开发者轻松选择合适的模式进行开发即可<br>缺点：<br>1）采用Erlang，太小众，研究源码很难</p><p>Kafka：<br>优势：<br>1）高吞吐量，百万级<br>2）稳定性好，采用zookeeper进行注册（Zookeep采用CP模式，高一致模式）<br>3）可以应用在大数据数据处理领域（KafkaStream）<br>缺点：<br>1）支持的开发语言比较少<br>2）耦合zk，依赖zookeeper进行注册</p><h5 id="spring中-Autowired和-Resource的区别"><a href="#spring中-Autowired和-Resource的区别" class="headerlink" title="spring中@Autowired和@Resource的区别"></a>spring中@Autowired和@Resource的区别</h5><ul><li>@Autowired是Spring的，@Resource是javax包下的 </li><li>@Autowired默认按类型匹配，@Resource默认按名称匹配 </li><li>@Autowired和@Qualifier一起用，@Resource单独用</li></ul><h5 id="mysql索引数据结构，为什么用的是b-树不用红黑树"><a href="#mysql索引数据结构，为什么用的是b-树不用红黑树" class="headerlink" title="mysql索引数据结构，为什么用的是b+树不用红黑树"></a>mysql索引数据结构，为什么用的是b+树不用红黑树</h5><p>1）Hash哈希，只适合等值查询，不适合范围查询<br>2）一般二叉树，可能会特殊化为一个链表，相当于全表扫描<br>3）红黑树，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了。<br>4）B树在范围查询时，存在回旋查找的问题，导致性能不高。B+树叶子节点是有序链表，更有利于范围查询。</p><p>综上所述，MySQL的索引数据结构最适合采用B+树来实现。而且为了提高索引前后范围检索效率，MySQL改造了传统的B+树，形成了双向链指针。</p><h5 id="mysql和redis如何保证数据一致性"><a href="#mysql和redis如何保证数据一致性" class="headerlink" title="mysql和redis如何保证数据一致性"></a>mysql和redis如何保证数据一致性</h5><p>1）缓存延迟双删 </p><ul><li><p>先删除缓存</p></li><li><p>写数据库</p></li></ul><p>休眠 500 毫秒，然后删除缓存</p><p>这样，读取脏数据的时间最多只有500毫秒。关键是如何确定睡眠时间？ 延迟时间的目的是为了保证读请求结束，写请求可以删除读请求引起的缓存脏数据。 因此，我们需要自己评估项目的数据读取业务逻辑的耗时，在读取时间的基础上加上几百毫秒的延迟时间。</p><p>2）删除缓存重试机制</p><p>缓存删除失败怎么办？比如延迟双删的第二次删除失败，说明脏数据无法删除。 使用重试机制保证缓存删除成功。 比如重试3次，失败3次，就会将日志记录到数据库中，并发出警告进行人工干预。 在高并发场景下，重试最好采用异步方式，比如向MQ中间件发送消息，实现异步解耦。</p><p>3）读取 bin-log 异步删除</p><ul><li><p>更新数据库。</p></li><li><p>数据库会将操作信息记录在bin-log日志中。</p></li><li><p>使用 canal 订阅 bin-log 日志获取目标数据和密钥。</p></li><li><p>缓存删除系统获取canal数据，解析目标key，尝试删除缓存。</p></li><li><p>如果删除失败，将消息发送到消息队列。</p></li><li><p>缓存删除系统再次从消息队列中获取数据，再次执行删除操作。</p></li></ul><h4 id="扩展具难面试题："><a href="#扩展具难面试题：" class="headerlink" title="扩展具难面试题："></a>扩展具难面试题：</h4><h5 id="1、多线程在项目中的使用场景"><a href="#1、多线程在项目中的使用场景" class="headerlink" title="1、多线程在项目中的使用场景"></a>1、多线程在项目中的使用场景</h5><ul><li>多线程批量导入MySQL数据到ES</li><li>CRM采用异步线程执行多个统计SQL</li></ul><h5 id="2、项目中是否有高并发导致的问题"><a href="#2、项目中是否有高并发导致的问题" class="headerlink" title="2、项目中是否有高并发导致的问题"></a>2、项目中是否有高并发导致的问题</h5><ul><li>mysql和redis数据一致性问题</li><li>ThreadLocal存储登录用户ID</li></ul><h5 id="3、线程不安全导致的问题"><a href="#3、线程不安全导致的问题" class="headerlink" title="3、线程不安全导致的问题"></a>3、线程不安全导致的问题</h5><p>共享数据安全问题（分布式锁解决）</p><h5 id="4、并发安全的集合有哪些"><a href="#4、并发安全的集合有哪些" class="headerlink" title="4、并发安全的集合有哪些"></a>4、并发安全的集合有哪些</h5><p>ConcurrentHashMap</p><p>CopyOnWriteArrayList</p><h5 id="5、sql慢查询优化、行锁、表锁"><a href="#5、sql慢查询优化、行锁、表锁" class="headerlink" title="5、sql慢查询优化、行锁、表锁"></a>5、sql慢查询优化、行锁、表锁</h5><p>1)避免回表查询</p><p>2)联合索引</p><p>3)避免索引失效</p><p>4）使用执行计划优化</p><p>表级锁：对整个表记录锁定，一个事务修改表数据的时候，另一个事务无法修改表数据。</p><p>语法：<br>  lock table tb_user read local;<br>  update tb_user ssss<br>  insert into tb_user<br>  unlock;</p><p>特点：锁定范围比较大，比较影响性能<br>应用场景：在数据迁移场景下使用</p><p>行级锁：对表的某条（某些）记录锁定。</p><p>行级锁分为 共享锁 和 排他锁</p><p>共享锁：一个事务在修改记录的时候，另一个事务无法修改记录，但是可以读取。<br>      update tb_user set sex&#x3D;’女’ where id &#x3D; 1 lock in share mode;</p><p>排他锁：一个事务在查询&#x2F;修改记录的时候，另一个事务无法修改和读取数据。<br>      select * from tb_user where id &#x3D; 1 for update;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;springcloud常用组件&quot;&gt;&lt;a href=&quot;#springcloud常用组件&quot; class=&quot;headerlink&quot; title=&quot;springcloud常用组件&quot;&gt;&lt;/a&gt;springcloud常用组件&lt;/h5&gt;&lt;p&gt;Eureka：服务注册和发现，由Ne</summary>
      
    
    
    
    <category term="面试宝典" scheme="https://onlyonemomo.github.io/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    
    <category term="面试必看" scheme="https://onlyonemomo.github.io/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/"/>
    
  </entry>
  
  <entry>
    <title>模块化之消息转换器</title>
    <link href="https://onlyonemomo.github.io/2022/08/22/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8B%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8/"/>
    <id>https://onlyonemomo.github.io/2022/08/22/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8B%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8/</id>
    <published>2022-08-22T10:34:56.000Z</published>
    <updated>2022-08-24T09:05:32.019Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导读</strong>：所谓模块化是针对在项目里面出现的各种问题，提供的一个模板操作，跟SOP很相似，用于指导和规范日常的工作流程。对于程序开发者来说，建立项目模块化系统，有助于提高开发效率。</p><p>这个是把数据库的数据通过对象返给前端，会出现下列没有转换的现象</p><p><img src="https://img-blog.csdnimg.cn/a9d34256a5d4452fbd615663473e8f89.png#pic_center" alt="在这里插入图片描述"></p><p>这个需要我们加入消息转换器进行转换，把Java对象转为json字符串，在配置类加入这段代码就可以解决了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展mvc框架的消息转换器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;开始扩展消息转换器...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个消息转化器对象</span></span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="comment">//设置对象转换器，可以将Java对象转为json字符串</span></span><br><span class="line">    converter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自己的转换器放入spring MVC框架的容器中</span></span><br><span class="line">    converters.add(<span class="number">0</span>,converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导读&lt;/strong&gt;：所谓模块化是针对在项目里面出现的各种问题，提供的一个模板操作，跟SOP很相似，用于指导和规范日常的工作流程。对于程序开发者来说，建立项目模块化系统，有助于提高开发效率。&lt;/p&gt;
&lt;p&gt;这个是把数据库的数据通过对象返给前端，会出现下列没</summary>
      
    
    
    
    <category term="项目模块化" scheme="https://onlyonemomo.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
    <category term="模块化" scheme="https://onlyonemomo.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>模块化之自定义注解</title>
    <link href="https://onlyonemomo.github.io/2022/08/22/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    <id>https://onlyonemomo.github.io/2022/08/22/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-08-22T10:34:56.000Z</published>
    <updated>2022-08-24T09:05:54.836Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导读</strong>：所谓模块化是针对在项目里面出现的各种问题，提供的一个模板操作，跟SOP很相似，用于指导和规范日常的工作流程。对于程序开发者来说，建立项目模块化系统，有助于提高开发效率。</p><p><strong>自定义注解就是一个标记，需要通过具体的代码去实现这个注解的用途。</strong></p><h5 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h5><h6 id="先定义一个自定义注解"><a href="#先定义一个自定义注解" class="headerlink" title="先定义一个自定义注解"></a>先定义一个自定义注解</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IgnoreToken &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="拦截器写逻辑"><a href="#拦截器写逻辑" class="headerlink" title="拦截器写逻辑"></a>拦截器写逻辑</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断当前被拦截的Controller方法上是否加入了IgnoreToken注解</span></span><br><span class="line"><span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod)handler;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasMethodAnnotation</span> <span class="operator">=</span> handlerMethod.hasMethodAnnotation(IgnoreToken.class);</span><br><span class="line"><span class="keyword">if</span> (hasMethodAnnotation)&#123;</span><br><span class="line">    <span class="comment">//加入了IgnoreToken注解，直接放行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是一个判断Controller方法上是否加入了IgnoreToken注解，如果加入了IgnoreToken注解，直接放行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导读&lt;/strong&gt;：所谓模块化是针对在项目里面出现的各种问题，提供的一个模板操作，跟SOP很相似，用于指导和规范日常的工作流程。对于程序开发者来说，建立项目模块化系统，有助于提高开发效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义注解就是一个标记，需要通过具</summary>
      
    
    
    
    <category term="项目模块化" scheme="https://onlyonemomo.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
    <category term="模块化" scheme="https://onlyonemomo.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>状态码大全</title>
    <link href="https://onlyonemomo.github.io/2022/08/22/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    <id>https://onlyonemomo.github.io/2022/08/22/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/</id>
    <published>2022-08-22T00:36:23.000Z</published>
    <updated>2022-08-25T12:32:09.594Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语</strong>：在《通往java之路》这个栏目，我不想表现出更多的功利主义。我希望在这个栏目中每一篇文章都有很强的可读性和趣味性，能让我闲暇之时也能好好的阅读。</p><h3 id="一、状态码大类"><a href="#一、状态码大类" class="headerlink" title="一、状态码大类"></a>一、状态码大类</h3><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2xx</td><td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><p>状态码大全：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a> </p><h3 id="二、常见的响应状态码"><a href="#二、常见的响应状态码" class="headerlink" title="二、常见的响应状态码"></a>二、常见的响应状态码</h3><table><thead><tr><th>状态码</th><th>英文描述</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td><strong><code>OK</code></strong></td><td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td></tr><tr><td>302</td><td><strong><code>Found</code></strong></td><td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td></tr><tr><td>304</td><td><strong><code>Not Modified</code></strong></td><td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td></tr><tr><td>400</td><td><strong><code>Bad Request</code></strong></td><td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td></tr><tr><td>403</td><td><strong><code>Forbidden</code></strong></td><td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td></tr><tr><td>404</td><td><strong><code>Not Found</code></strong></td><td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td></tr><tr><td>428</td><td><strong><code>Precondition Required</code></strong></td><td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td></tr><tr><td>429</td><td><strong><code>Too Many Requests</code></strong></td><td><strong>太多请求</strong>，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用</td></tr><tr><td>431</td><td><strong><code> Request Header Fields Too Large</code></strong></td><td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td></tr><tr><td>405</td><td><strong><code>Method Not Allowed</code></strong></td><td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td></tr><tr><td>500</td><td><strong><code>Internal Server Error</code></strong></td><td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td></tr><tr><td>503</td><td><strong><code>Service Unavailable</code></strong></td><td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td></tr><tr><td>511</td><td><strong><code>Network Authentication Required</code></strong></td><td><strong>客户端需要进行身份验证才能获得网络访问权限</strong></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;：在《通往java之路》这个栏目，我不想表现出更多的功利主义。我希望在这个栏目中每一篇文章都有很强的可读性和趣味性，能让我闲暇之时也能好好的阅读。&lt;/p&gt;
&lt;h3 id=&quot;一、状态码大类&quot;&gt;&lt;a href=&quot;#一、状态码大类&quot; clas</summary>
      
    
    
    
    <category term="通往java之路" scheme="https://onlyonemomo.github.io/categories/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="状态码" scheme="https://onlyonemomo.github.io/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>IDEA安装SOP</title>
    <link href="https://onlyonemomo.github.io/2022/08/21/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/IDEA%E5%AE%89%E8%A3%85SOP/"/>
    <id>https://onlyonemomo.github.io/2022/08/21/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/IDEA%E5%AE%89%E8%A3%85SOP/</id>
    <published>2022-08-21T11:56:51.000Z</published>
    <updated>2022-08-24T10:36:05.341Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语</strong>：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助于快速配置相关属性，提高开发效率。</p><p>可以自行到官方网站自行下载，网址为：<a href="https://www.jetbrains.com/idea">https://www.jetbrains.com/idea</a><br>本文演示的IDEA版本为 IntelliJ IDEA 2021.1.1 x64</p><h3 id="2、安装IDEA图解"><a href="#2、安装IDEA图解" class="headerlink" title="2、安装IDEA图解"></a>2、安装IDEA图解</h3><h5 id="2-1双击安装包，点击next"><a href="#2-1双击安装包，点击next" class="headerlink" title="2.1双击安装包，点击next"></a>2.1双击安装包，点击next</h5><p><img src="https://img-blog.csdnimg.cn/a7f6748c720e4376a9cba9ce1ea34eca.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2-2点击修改Browse修改安装路径，然后点击next"><a href="#2-2点击修改Browse修改安装路径，然后点击next" class="headerlink" title="2.2点击修改Browse修改安装路径，然后点击next"></a>2.2点击修改Browse修改安装路径，然后点击next</h5><p><strong>注意：安装路径不能有中文或者有空格</strong></p><p><img src="https://img-blog.csdnimg.cn/2d3f5fa9867142519722d211ed7246a1.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2-3-看图勾选，然后点击next"><a href="#2-3-看图勾选，然后点击next" class="headerlink" title="2.3 看图勾选，然后点击next"></a>2.3 看图勾选，然后点击next</h5><p><img src="https://img-blog.csdnimg.cn/1a18d151e1d248dd85e2f02481fc9e53.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2-4-点击Install-准备安装"><a href="#2-4-点击Install-准备安装" class="headerlink" title="2.4 点击Install , 准备安装"></a>2.4 点击Install , 准备安装</h5><p><img src="https://img-blog.csdnimg.cn/a10206a5482a405dbed1709807fc2148.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2-5等进度条读取完毕之后，会有最终页面提示，然后点击Finish"><a href="#2-5等进度条读取完毕之后，会有最终页面提示，然后点击Finish" class="headerlink" title="2.5等进度条读取完毕之后，会有最终页面提示，然后点击Finish"></a>2.5等进度条读取完毕之后，会有最终页面提示，然后点击Finish</h5><p><img src="https://img-blog.csdnimg.cn/ace584d408134e2ca1dba53bc96757ac.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2-6-第一次启动会询问，是否导入一些设置-选择第二个不导入，保持默认设置，再点OK"><a href="#2-6-第一次启动会询问，是否导入一些设置-选择第二个不导入，保持默认设置，再点OK" class="headerlink" title="2.6 第一次启动会询问，是否导入一些设置.选择第二个不导入，保持默认设置，再点OK"></a>2.6 第一次启动会询问，是否导入一些设置.选择第二个不导入，保持默认设置，再点OK</h5><p><img src="https://img-blog.csdnimg.cn/9ee3da7f4f7a410b86278db672ccc19e.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2-7-选择背景主题"><a href="#2-7-选择背景主题" class="headerlink" title="2.7 选择背景主题"></a>2.7 选择背景主题</h5><p><strong>建议选择白色，代码错了可以很清晰看出</strong>,选择完毕，继续next<br><img src="https://img-blog.csdnimg.cn/681e6d68384b4fddb270d17fdc864b52.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2-8-本界面让我们购买Idea"><a href="#2-8-本界面让我们购买Idea" class="headerlink" title="2.8 本界面让我们购买Idea"></a>2.8 本界面让我们购买Idea</h5><p>因为我们是学习阶段，所以可以使用免费30天<br>点击第一排第二个。Evaluate for free</p><p><img src="https://img-blog.csdnimg.cn/83808e04f2ab46ec846cdf8de2a88bff.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2-9-点击蓝色的Evaluate-就可以开始免费试用30天了"><a href="#2-9-点击蓝色的Evaluate-就可以开始免费试用30天了" class="headerlink" title="2.9 点击蓝色的Evaluate , 就可以开始免费试用30天了"></a>2.9 点击蓝色的Evaluate , 就可以开始免费试用30天了</h5><p><img src="https://img-blog.csdnimg.cn/35ef673b5b6543128799423e1c3e43fa.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2-10-当看到这个界面，就表示idea已经安装成功了"><a href="#2-10-当看到这个界面，就表示idea已经安装成功了" class="headerlink" title="2.10  当看到这个界面，就表示idea已经安装成功了"></a>2.10  当看到这个界面，就表示idea已经安装成功了</h5><p><img src="https://img-blog.csdnimg.cn/46ea26c1c72e4154b4a73f1e7477a2c0.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2-11-破解Idea"><a href="#2-11-破解Idea" class="headerlink" title="2.11 破解Idea"></a>2.11 破解Idea</h5><p>网址：<a href="https://www.exception.site/essay/idea-reset-eval">https://www.exception.site/essay/idea-reset-eval</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助</summary>
      
    
    
    
    <category term="SOP操作手册" scheme="https://onlyonemomo.github.io/categories/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    
    
    <category term="SOP" scheme="https://onlyonemomo.github.io/tags/SOP/"/>
    
  </entry>
  
  <entry>
    <title>JDK环境变量配置SOP</title>
    <link href="https://onlyonemomo.github.io/2022/08/21/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/JDK%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AESOP/"/>
    <id>https://onlyonemomo.github.io/2022/08/21/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/JDK%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AESOP/</id>
    <published>2022-08-21T11:56:51.000Z</published>
    <updated>2022-08-22T03:20:25.279Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语</strong>：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助于快速配置相关属性，提高开发效率。</p><h3 id="1、按下Win键-E，找到计算机"><a href="#1、按下Win键-E，找到计算机" class="headerlink" title="1、按下Win键+E，找到计算机"></a>1、按下Win键+E，找到计算机</h3><p><img src="https://img-blog.csdnimg.cn/2d617c7031754c3d8b3f978337fbb87a.png#pic_center" alt="在这里插入图片描述"></p><h3 id="2、鼠标右键点击计算机，选择属性"><a href="#2、鼠标右键点击计算机，选择属性" class="headerlink" title="2、鼠标右键点击计算机，选择属性"></a>2、鼠标右键点击计算机，选择属性</h3><p><img src="https://img-blog.csdnimg.cn/c9c27ce5def84d608c5928a72c9012ba.png#pic_center" alt="在这里插入图片描述"></p><h3 id="3、点击高级系统设置"><a href="#3、点击高级系统设置" class="headerlink" title="3、点击高级系统设置"></a>3、点击高级系统设置</h3><p><img src="https://img-blog.csdnimg.cn/b4a03f99534b4d3db1d2265cad7b0063.png#pic_center" alt="在这里插入图片描述"></p><h5 id="3-1-选择高级，再点击里面的环境变量"><a href="#3-1-选择高级，再点击里面的环境变量" class="headerlink" title="3.1 选择高级，再点击里面的环境变量"></a>3.1 选择高级，再点击里面的环境变量</h5><p><img src="https://img-blog.csdnimg.cn/4ea8ce67b314490faf4417ce576564bd.png#pic_center" alt="在这里插入图片描述"></p><h5 id="3-2点击系统变量下面的新建"><a href="#3-2点击系统变量下面的新建" class="headerlink" title="3.2点击系统变量下面的新建"></a>3.2点击系统变量下面的新建</h5><p><img src="https://img-blog.csdnimg.cn/136e14532ff54910b871d2bab44611f7.png#pic_center" alt="在这里插入图片描述"></p><ul><li>会弹出这样的界面</li></ul><p><img src="https://img-blog.csdnimg.cn/d4ea8d3f73594ec7a5ac590a29e42681.png#pic_center" alt="在这里插入图片描述"></p><ul><li><p>变量名后面输入:  JAVA_HOME </p><p>变量值后面：把JDk的安装路径复制过来<br><strong>注意：不带bin目录</strong><br>操作完点击确定</p></li></ul><p><img src="https://img-blog.csdnimg.cn/175b1648b9444544b2e48d2d926009c4.png#pic_center" alt="在这里插入图片描述"></p><ul><li>选择Path<br>此处还是要选择下方<strong>系统变量</strong>中的Path<br>点击编辑</li></ul><p><img src="https://img-blog.csdnimg.cn/01faadb81bc34130bfeaa65ef8d52f24.png#pic_center" alt="在这里插入图片描述"></p><ul><li><p>在弹出的页面中点击编辑文本 （<strong>也可以点击新建，输入完之后点上移到第一个</strong>）<br><img src="https://img-blog.csdnimg.cn/be00c89975764c2e9d2e789404a67d6e.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>点击完毕后之后会弹出这样的页面</p><p><strong>注意：里面的很多内容不能删除</strong></p></li></ul><p><img src="https://img-blog.csdnimg.cn/8c837453c884422fbe8f6b6f505bccc6.png#pic_center" alt="在这里插入图片描述"></p><ul><li>在变量值的最前面输入：**%JAVA_HOME%\bin; **<br>其中使用两个百分号包住 JAVA_HOME,表示引用了 JAVA_HOME 里面的值。<br>分号，表示多个环境变量之间的间隔。<strong>一定不能漏</strong><br><strong>注意：所以符号一定要是英文状态下的。</strong><br><img src="https://img-blog.csdnimg.cn/18e13a8e04034928a83896a0d277199d.png#pic_center" alt="在这里插入图片描述"></li></ul><h3 id="4、打开CMD，输入java回车。"><a href="#4、打开CMD，输入java回车。" class="headerlink" title="4、打开CMD，输入java回车。"></a>4、打开CMD，输入java回车。</h3><p><img src="https://img-blog.csdnimg.cn/36e5efc2260e4392868ac2ff1317053e.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助</summary>
      
    
    
    
    <category term="SOP操作手册" scheme="https://onlyonemomo.github.io/categories/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    
    
    <category term="SOP" scheme="https://onlyonemomo.github.io/tags/SOP/"/>
    
  </entry>
  
  <entry>
    <title>进化论是个惊天骗局</title>
    <link href="https://onlyonemomo.github.io/2022/08/19/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/%E8%BF%9B%E5%8C%96%E8%AE%BA%E6%98%AF%E4%B8%AA%E9%AA%97%E5%B1%80/"/>
    <id>https://onlyonemomo.github.io/2022/08/19/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/%E8%BF%9B%E5%8C%96%E8%AE%BA%E6%98%AF%E4%B8%AA%E9%AA%97%E5%B1%80/</id>
    <published>2022-08-19T11:28:25.000Z</published>
    <updated>2022-08-23T13:58:41.968Z</updated>
    
    <content type="html"><![CDATA[<p>我看了卫斯理系列中的《木炭》，讲的是人的灵魂在木炭中寄存。以前的我是不相信鬼神的，现在的我相信人是不死不灭的。我们这个世界是个表征的世界，解释人类的起源无疑是《进化论》占据很大的话语权。但很多人都不知道的是进化论的作者达尔文根本没有在书中说过人是进化而来的，只是强烈暗示这一结果！</p><p>最近韦伯望远镜拍摄了130亿年前的照片，足以证明宇宙的时间是永恒的。可以想象一下，现在有一台照相机能捕摄到你小时候的照片那般震撼，也进一步说明人是不死不灭的。我们日常所说的时间是用来描述物体运动的，并不是宇宙定义的时间。下列是我收集挑战进化论的一些论点，在此之前先看罗翔老师的一个视频。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=211870755&bvid=BV11a41187gG&cid=515291490&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h5 id="1、古生物学几大问题无法回答"><a href="#1、古生物学几大问题无法回答" class="headerlink" title="1、古生物学几大问题无法回答:"></a>1、古生物学几大问题无法回答:</h5><p>(1）如果人类是渐变进化而来的，那么目前为止没有发现相关化石，也就是没有进化这个过程。也就直接违反了生物是进化而来的这个理论。</p><p>(2）在寒武纪之前的生命是以单细胞和多细胞的形式存在，但寒武纪生命大爆发就出现了很多物种，几乎所有生物的门都在同一时间出现。这就直接反驳达尔文的进化论，物种是从水生到陆生，由简单到复杂，由低级到高级循序渐进的进化而来。</p><p>(3）按照目前的理解，生物进化的速度越来越快。但生物学在基因生物这个领域的话，你会发现其实生命越高级它的基因越稳定越不容易发生突变，也就是说它的这种进化速度，其实是应该越高级越慢。可是从化石上来看，从它们其它别的证据上来看，反而好像是越高级它的进化就越快一样，所以说就是进化论本身的论据之间也存在着冲突。</p><h5 id="2、埃及金字塔里面的秘密"><a href="#2、埃及金字塔里面的秘密" class="headerlink" title="2、埃及金字塔里面的秘密:"></a>2、埃及金字塔里面的秘密:</h5><p>(1）金字塔的构成: 它大概由230万到250万块巨石构成，每一块巨石大概在3吨到30吨，巨石之间，不知道用了什么样的工艺，使得互相之间压得非常紧，拿一个最锋利的刀片都没有办法插到两块石头中间去，就是这种工艺现在的人都很难造出来。</p><p>(2）有一种说法说，当时埃及用了10万奴隶，花了20年时间造了这个金字塔。为什么不可信呢? 因为这个金字塔里面一共有230万到250万块石头，刚才讲过 每块石头3吨到30吨，如果是用了20年的时间，咱们说每年365天，每天从早到晚一分钟都不休息，需要每五分钟放一块石头上去，才能够把这个金字塔在20年造出来。就算是目前的现代人也很难能造得出来!</p><h5 id="3、这个金字塔有很多天文学的奇观。"><a href="#3、这个金字塔有很多天文学的奇观。" class="headerlink" title="3、这个金字塔有很多天文学的奇观。"></a>3、这个金字塔有很多天文学的奇观。</h5><p>比如说四个面是对着正东正西正南正北，然后在某一个时刻金字塔上的某一个点，对着天上的某一颗星星等等，就是它整个设计包含了非常精密的数学计算，然后包含了丰富的天文学，包括地球测量，包括在建筑工艺上也是非常先进。</p><p>(1）金字塔的底边是一个正方形，这个正方形每边长230.37米。角度51度50分，包括230.37米，或者说觉得没什么奇怪的数字。但是如果用三角函数值计算一下，就会发现，这个金字塔四边的周长，除以金字塔的高度，然后再除以二，结果就是π。这就是说当时建造金字塔的人已经知道了π! 这是四千多年前的古埃及人就懂得使用了，而中国是南北朝的祖冲之才计算出六七位的。</p><p>(2) 经线和纬线相交的地方就是这个吉萨金字塔。吉萨金字塔的高度是146.8米，如果把这个高度乘以10亿，就是地球到太阳的距离。这个金字塔的重量大概是590万吨，如果乘以1000万亿就是地球的重量，非常不可思议的一个整数倍1000万亿。高度是10亿， 重量是1000万亿倍。</p><h5 id="4、石油越来越多反而冲击了进化论"><a href="#4、石油越来越多反而冲击了进化论" class="headerlink" title="4、石油越来越多反而冲击了进化论:"></a>4、石油越来越多反而冲击了进化论:</h5><p>(1) 全球的石油储量到底有多少? 在2004年，埃克森美孚 ExxonMobil统计说全球的石油储量大概在1717亿吨。这个《Science》 科学杂志，美国最权威的科学期刊，它的统计数据更乐观一些，说全球大概有4000亿吨石油储量。</p><p>(2) 众所周知，石油是由动物的尸体在地底下转化而来的，植物则变成炭。在2018年4月份有三个科学家做了一个研究，这个研究发表在美国的科学院，就是叫 Proceedings of National Academy of America。National Academy of America 可以译为美国的科学院，相当于中国的中科院，Proceedings 指的是他们的杂志——学术期刊。也就是相当于中国中科院这样一个级别的美国科学院，它的学术期刊里边登了三个科学家的文章。</p><p>3.1 这三个科学家花了很多很多年的时间，去统计全世界所有地球表面上的生物所含碳的含量到底有多少，后来发现这个碳的含量大概在5500万亿吨。5500万亿吨是个什么概念呢？就是说地球上主要的碳存在于植物之中，植物中含有4万5千亿吨碳。当然我们知道植物是不会变成石油的，因为它埋到地下就变成煤了，煤是这么来的。那么动物有多少呢？经过他们的计算发现动物的含碳量大概是20亿吨。20亿吨的全世界所有活着的动物，不管是陆地上的还是海洋上的，加一块儿20亿吨。</p><p>3.2 如果要产生4000亿吨石油的话，需要把现在地球上所有的动物全部灭绝，而且一点儿不能糟践，不能说腐烂了、分解了、什么之类的不行，一点不糟践的转化成为石油，那也不过就是20亿吨。如果要产生4000亿吨石油的话，需要把地球上的生物毁灭200遍，所有的生物毁灭200遍。</p><p>这样计算的话，平均每一百万年就得来场灭世浩劫，才能产生这么多石油，那么生物明显就无法进化了。目前来说石油还在源源不断被发现，很显然进化论无法解释这一点。</p><h5 id="5、还有一些不解之谜"><a href="#5、还有一些不解之谜" class="headerlink" title="5、还有一些不解之谜:"></a>5、还有一些不解之谜:</h5><p>(1) 比如说在非洲加蓬共和国有一个奥克洛矿区，这个奥克洛矿区发现了一个20亿年以前的核反应堆，而且这个核反应堆运转了50万年。核反应堆不可能是自然形成的，稍有不慎就炸了。</p><p>(2)NASA在2006年刊登了一篇文章。当时是访问了一个NASA的科学家，他说NASA从1972年开始到1977年 5年的时间，观察月亮上的地震，其实这个不应该叫做Earthquake了，Earthquake是地震，它应该叫Moonquake，就是月震。</p><p>地球发生地震的时候，由于地球是一个实心球体，所以地球一震之后地震波在地表的传播，最多不过半分钟就不见了，因为被地表吸收了。而当月球发生地震的时候，月震波在月球上可以传递长达10分钟之久。当时那科学家说了一句话，他说这个月球 ring like a bell，说月亮就像是一个钟一样敲起来，10分钟的时间余音不绝，余音袅袅，所以月球是空心的。</p><p>从道理上来讲，一个陨石如果落到地球上来，它砸出来那个坑应该是比较浅。为什么呢？因为地球上有空气，当大的小行星或者是一些什么样的小的天体，比如说一公里两公里的小天体掉到地球上来的时候，它在跟空气的摩擦当中，会起到一种好像是风力刹车的作用，能够让它速度有所减低，而月球没有空气，所以说，如果是一些天体砸到月球上，砸出的坑应该更深，但是实际上砸出的坑都很浅，所以就有人说实际上月球有一个金属的外壳，非常坚硬，所以才能够保证这个坑砸出的这么浅。</p><p>月亮的重量非常可疑! 我们看月亮它是地球直径的1&#x2F;4，计算体积的话它和一个球体的直径的立方成正比，这么算下来月球的质量应该是地球的1&#x2F;64，如果它们构成是同样的质地就是1&#x2F;64。但是月球比这个轻，它是地球质量的1&#x2F;81。这样一轻就有一个想法，其实是两个答案了。第一个答案就是月球的土壤密度比地球的要小，这是一种解释；还有一种解释更不可思议，就是月球是空心的，别看它那么大，因为它空所以它轻。</p><p>小结：我希望大家能用我“<strong>浅谈ADE效应</strong>”那篇文章一样，<strong>我们要以一个什么都不知道的人为出发点，然后以其个人的智力来挖掘与确定的知识</strong>。知识论的思考规则是：</p><blockquote><p>(1)拒绝既定的现象。<br>(2)拒绝确定的教条。<br>(3)拒绝过去的权威。<br>(4)只接受个人理性验证为实的真理。</p></blockquote><p>为什么进化论遭受如此大的挑战还仍然是主流？因为是要理论才能打败理论，不是日常的他说错就可以推翻他的理论，这也是中国人惯有的思维。就像曾经的<code>燃素理论</code>一样，后面出现<code>氧化反应理论</code>才彻底击败<code>燃素理论</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我看了卫斯理系列中的《木炭》，讲的是人的灵魂在木炭中寄存。以前的我是不相信鬼神的，现在的我相信人是不死不灭的。我们这个世界是个表征的世界，解释人类的起源无疑是《进化论》占据很大的话语权。但很多人都不知道的是进化论的作者达尔文根本没有在书中说过人是进化而来的，只是强烈暗示这一</summary>
      
    
    
    
    <category term="三千世界" scheme="https://onlyonemomo.github.io/categories/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/"/>
    
    
    <category term="进化论" scheme="https://onlyonemomo.github.io/tags/%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>畅聊教育</title>
    <link href="https://onlyonemomo.github.io/2022/08/18/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/%E7%95%85%E8%81%8A%E6%95%99%E8%82%B2/"/>
    <id>https://onlyonemomo.github.io/2022/08/18/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/%E7%95%85%E8%81%8A%E6%95%99%E8%82%B2/</id>
    <published>2022-08-18T08:07:42.000Z</published>
    <updated>2022-08-23T14:12:33.143Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语</strong>：我记得每次跟朋友争论教育的时候，她每次就说了一句“中国现在能有这样的成就不是发展的很好吗”? 我无法反驳此言论，但心中颇为不服，通过不断的去学习，我终于明白什么是教育！</p><h3 id="一、教育发展史"><a href="#一、教育发展史" class="headerlink" title="一、教育发展史"></a>一、教育发展史</h3><p>要想反驳这些人的言论，就得运用上知识论的内容，我们要以一个什么都不知道的人为出发点，然后以其个人的智力来挖掘与确定的知识。首先就得从教育发展史出发，对比各国的教育差异！</p><h5 id="普鲁士教育"><a href="#普鲁士教育" class="headerlink" title="普鲁士教育"></a>普鲁士教育</h5><p>现代教育体制的起源就是普鲁士教育改革，普鲁士也是全世界第一个实施了义务教育的国家。普鲁士教育的核心是什么？就是集体观念，中规中矩，服从，专业技能强。工业文明之后只要采用普鲁士教育这个模范的几乎是后来工业革命的大赢家，包括美国。</p><p>其中德国和日本是深受普鲁士教育的影响，所以会出现德国人的严谨，日本的匠人精神都来源于此! 接下来谈一下日本：日本的教育过去那是完全是一个封建皇权教育，日本后来的脱亚入欧的杂种思想，和所谓“心近中国，身在欧洲”的日本文化。它的教育就是这样的，它佩服德国，它学的普鲁士，它回去带了普鲁士，日本才实现了跟德国特别一样的这种行为和社会文化结果。</p><h5 id="芬兰教育"><a href="#芬兰教育" class="headerlink" title="芬兰教育"></a>芬兰教育</h5><p>在第二次工业文明之后，教育最为突出的是芬兰。<strong>芬兰教育是什么教育</strong>？它打破了普鲁士教育上很多的所谓的“把人训练成机器”。芬兰教育它把它人性化。芬兰学校，基本上不考试，最后就一个国家考试，一关就过；中间避免考试，避免人与人之间的恶性竞争，避免人给人打标签、打评分，因为人在不同的环境下、不同的时间下会有不同的表现。评分、考试是奴役和老师和学生之间恶性循环的最糟糕的东西。</p><p>芬兰，这个享有“世界第一教育之国”称号！芬兰的教育水平、科技水平始终居于世界前列。只有500多万人的小国，却在20项关键科技领域，有17项排名世界前十。从这里就可以看得出第一次工业文明和第二次工业文明教育的转变。</p><h5 id="美国的教育"><a href="#美国的教育" class="headerlink" title="美国的教育"></a>美国的教育</h5><p>美国教育又是怎么样的呢？答曰:美国的基础教育很差，但成年教育非常好，职业教育是规划特别好的。</p><p>为什么就成年教育最好呢？是因为美国是个移民国家，所有美国的教育最重要的好是因为美国是移民带来的，而不是它所谓的教育的优越性。它是享受了普鲁士的初期幼儿园这个教育成功的最后的收割者。</p><h3 id="二、教育的核心"><a href="#二、教育的核心" class="headerlink" title="二、教育的核心"></a>二、教育的核心</h3><p>2004年，美国的一个“死亡谷”，从不长一棵树，突然之间就下起了一场雨。这片沙漠从那天开始就逐渐长出来参天大树，自成一个生态圈。有一位科学家去考察，说这里的环境就适合长出花草树木。教育也同样如此，需要一个环境，什么环境就适合长什么。国内有个比喻，老师就像辛勤园丁一样。老师的作用是帮助健康的树苗茁壮的成长，进而帮助它选择合适的环境。</p><h6 id="教育的作用"><a href="#教育的作用" class="headerlink" title="教育的作用"></a>教育的作用</h6><p><strong>教育的作用是认知文明和创造文明的</strong>。从普鲁士教育到芬兰教育的转变，代表着文明的进化。第一次工业文明的主流是普鲁士教育，第二次工业文明的教育以芬兰为主。第一次工业文明需要的是廉价的劳动力，第二次工业文明需要的是创新型的人才。每一次文明的进化是伴随着教育的改变，相辅相成的。</p><h6 id="教育的终极目的"><a href="#教育的终极目的" class="headerlink" title="教育的终极目的"></a>教育的终极目的</h6><p>高中时期，我班主任在课堂讲素质教育的时候，极其狂妄的说：”就算是大学的教授来也讲不明白什么是素质教育“！这里就引发我的思考，教育的终极目的是什么？今天我可以回复我班主任当时的素质教育的问题了，教育的终极目的是，”<strong>分真假，辨善恶，知荣辱，识廉耻</strong>“！这十二个字也是我对素质教育的诠释。</p><p>当今社会的教育都是功能性教育、欲望的教育和欲望满足的工具。每当我和别人交流的时候，他们的嘴里只会吐出“搞钱”两个字。但你要是问他，财富从何而来？谈话就戛然而止了。<strong>这个世界是很现实的，它也很客观、很科学、也很公平。所有的爱和情、金钱、尊严，它只追求强者；只跟高尚者，只跟有信仰的人、有理想的人；它只往高处走，不往低处流</strong>。一个人连财富的来源都不明白，怎么能搞得到钱呢？就算你偶然之间天降横财，你能守得住吗？我曾经看过一篇报道中彩票的人大多最后面的结局是妻离子散，家破人亡。所以你没有钱是老天对你的一种保护！</p><h6 id="第三次世界文明即将诞生"><a href="#第三次世界文明即将诞生" class="headerlink" title="第三次世界文明即将诞生"></a>第三次世界文明即将诞生</h6><p>第一次工业文明的教育是以普鲁士教育为主，第二次工业文明开始倒向芬兰式教育，也就是通识教育。目前新的教育体系已经开始显露出来了，就是教育的终极目的”<strong>分真假，辨善恶，知荣辱，识廉耻</strong>“。</p><p><strong>未完待续…….</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;：我记得每次跟朋友争论教育的时候，她每次就说了一句“中国现在能有这样的成就不是发展的很好吗”? 我无法反驳此言论，但心中颇为不服，通过不断的去学习，我终于明白什么是教育！&lt;/p&gt;
&lt;h3 id=&quot;一、教育发展史&quot;&gt;&lt;a href=&quot;#一</summary>
      
    
    
    
    <category term="三千世界" scheme="https://onlyonemomo.github.io/categories/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>详解缓存穿透、缓存雪崩、缓存击穿</title>
    <link href="https://onlyonemomo.github.io/2022/08/17/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/%E8%AF%A6%E8%A7%A3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    <id>https://onlyonemomo.github.io/2022/08/17/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/%E8%AF%A6%E8%A7%A3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</id>
    <published>2022-08-17T12:45:36.000Z</published>
    <updated>2022-08-25T12:33:44.716Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语</strong>：在《通往java之路》这个栏目，我不想表现出更多的功利主义。我希望在这个栏目中每一篇文章都有很强的可读性和趣味性，能让我闲暇之时也能好好的阅读。</p><p><strong>正文</strong>：当我们使用缓存时，目标通常有两个：第一，提升响应效率和并发量；第二，减轻数据库的压力。<strong>缓存穿透</strong>、<strong>缓存雪崩</strong>和<strong>缓存击穿</strong>的发生，都是因为在某些特殊情况下，缓存失去了预期的功能所致。当缓存失效或没有抵挡住流量，流量直接涌入到数据库，在高并发的情况下，可能直接击垮数据库，导致整个系统崩溃！</p><h3 id="一、什么叫缓存穿透？"><a href="#一、什么叫缓存穿透？" class="headerlink" title="一、什么叫缓存穿透？"></a>一、什么叫缓存穿透？</h3><h5 id="缓存穿透的定义"><a href="#缓存穿透的定义" class="headerlink" title="缓存穿透的定义"></a>缓存穿透的定义</h5><p>用户访问的数据既不在缓存当中，也不在数据库中。出于容错的考虑，如果从底层数据库查询不到数据，则不写入缓存。这就导致每次请求都会到底层数据库进行查询，缓存也失去了意义。当高并发或有人利用不存在的Key频繁攻击时，数据库的压力骤增，甚至崩溃，这就是<strong>缓存穿透</strong>！</p><p><strong>造成缓存穿透的场景一般有两类</strong>：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(1)</span>原来数据是存在的，但由于某些原因（误删除、主动清理等）在缓存和数据库层面被删除了，但前端或前置的应用程序依旧保有这些数据；</span><br><span class="line"></span><br><span class="line"><span class="comment">(2)</span>恶意攻击行为，利用不存在的Key或者恶意尝试导致产生大量不存在的业务数据请求</span><br></pre></td></tr></table></figure><h5 id="常用的解决方案"><a href="#常用的解决方案" class="headerlink" title="常用的解决方案"></a>常用的解决方案</h5><h6 id="方案一：缓存空值（null）或默认值"><a href="#方案一：缓存空值（null）或默认值" class="headerlink" title="方案一：缓存空值（null）或默认值"></a>方案一：缓存空值（null）或默认值</h6><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分析业务请求，如果是正常业务请求时发生缓存穿透现象，可针对相应的业务数据，在数据库查询不存在时，将其缓存为空值（<span class="built_in">null</span>）或默认值。需要注意的是，针对空值的缓存失效时间不宜过长，一般设置为<span class="number">5</span>分钟之内。当数据库被写入或更新该<span class="built_in">key</span>的新数据时，缓存必须同时被刷新，避免数据不一致。</span><br></pre></td></tr></table></figure><h6 id="方案二：业务逻辑前置校验"><a href="#方案二：业务逻辑前置校验" class="headerlink" title="方案二：业务逻辑前置校验"></a>方案二：业务逻辑前置校验</h6><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在业务请求的入口处进行数据合法性校验，检查请求参数是否合理、是否包含非法值、是否恶意请求等，提前有效阻断非法请求。比如，根据年龄查询时，请求的年龄为<span class="string">-10</span>岁，这显然是不合法的请求参数，直接在参数校验时进行判断返回。</span><br></pre></td></tr></table></figure><h6 id="方案三：使用布隆过滤器请求白名单"><a href="#方案三：使用布隆过滤器请求白名单" class="headerlink" title="方案三：使用布隆过滤器请求白名单"></a>方案三：使用布隆过滤器请求白名单</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在写入数据时，使用布隆过滤器进行标记（相当于设置白名单），业务请求发现缓存中无对应数据时，可先通过查询布隆过滤器判断数据是否在白名单内，如果不在白名单内，则直接返回空或失败。</span><br></pre></td></tr></table></figure><h6 id="方案四：用户黑名单限制"><a href="#方案四：用户黑名单限制" class="headerlink" title="方案四：用户黑名单限制"></a>方案四：用户黑名单限制</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当发生异常情况时，实时监控访问的对象和数据，分析用户行为，针对故意请求、爬虫或攻击者，进行特定用户的限制；</span><br></pre></td></tr></table></figure><h3 id="二、什么叫缓存雪崩？"><a href="#二、什么叫缓存雪崩？" class="headerlink" title="二、什么叫缓存雪崩？"></a>二、什么叫缓存雪崩？</h3><h5 id="缓存雪崩的定义"><a href="#缓存雪崩的定义" class="headerlink" title="缓存雪崩的定义"></a>缓存雪崩的定义</h5><p>当缓存中大量热点缓存采用了相同的实效时间，就会导致缓存在某一个时刻同时失效，请求全部转发到数据库，从而导致数据库压力骤增，甚至宕机。从而形成一系列的连锁反应，造成系统崩溃等情况，这就是<strong>缓存雪崩</strong>！由于某些原因导致缓存服务宕机、挂掉或不响应，也同样会导致流量直接转移到数据库。</p><p>缓存雪崩的场景通常有两个:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(1)</span>大量热点key同时过期；</span><br><span class="line"><span class="comment">(2)</span>缓存服务故障；</span><br></pre></td></tr></table></figure><h5 id="缓存雪崩的解决方案"><a href="#缓存雪崩的解决方案" class="headerlink" title="缓存雪崩的解决方案"></a>缓存雪崩的解决方案</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、通常的解决方案是将<span class="keyword">key</span>的过期时间后面加上一个随机数（比如随机<span class="number">1</span>-<span class="number">5</span>分钟），让<span class="keyword">key</span>均匀的失效。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、考虑用队列或者锁的方式，保证缓存单线程写，但这种方案可能会影响并发量。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、热点数据可以考虑不失效，后台异步更新缓存，适用于不严格要求缓存一致性的场景。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、双<span class="keyword">key</span>策略，主<span class="keyword">key</span>设置过期时间，备<span class="keyword">key</span>不设置过期时间，当主<span class="keyword">key</span>失效时，直接返回备<span class="keyword">key</span>值。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、构建缓存高可用集群（针对缓存服务故障情况）。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、当缓存雪崩发生时，服务熔断、限流、降级等措施保障。</span><br></pre></td></tr></table></figure><h3 id="三、什么叫缓存击穿"><a href="#三、什么叫缓存击穿" class="headerlink" title="三、什么叫缓存击穿?"></a>三、什么叫缓存击穿?</h3><h5 id="缓存击穿的定义"><a href="#缓存击穿的定义" class="headerlink" title="缓存击穿的定义"></a>缓存击穿的定义</h5><p>缓存雪崩是指只大量热点key同时失效的情况，如果是单个热点key，在不停的扛着大并发，在这个key失效的瞬间，持续的大并发请求就会击破缓存，直接请求到数据库，好像蛮力击穿一样。这种情况就是<strong>缓存击穿</strong>!</p><p>从定义上可以看出，缓存击穿和缓存雪崩很类似，只不过是缓存击穿是一个热点key失效，而缓存雪崩是大量热点key失效。因此，可以将缓存击穿看作是缓存雪崩的一个子集</p><h5 id="缓存击穿的解决方案"><a href="#缓存击穿的解决方案" class="headerlink" title="缓存击穿的解决方案:"></a>缓存击穿的解决方案:</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、使用互斥锁（Mutex <span class="keyword">Key</span>），只让一个线程构建缓存，其他线程等待构建缓存执行完毕，重新从缓存中获取数据。单机通过synchronized或lock来处理，分布式环境采用分布式锁。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、热点数据不设置过期时间，后台异步更新缓存，适用于不严格要求缓存一致性的场景。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、”提前“使用互斥锁（Mutex <span class="keyword">Key</span>）：在value内部设置一个比缓存（Redis）过期时间短的过期时间标识，当异步线程发现该值快过期时，马上延长内置的这个时间，并重新从数据库加载数据，设置到缓存中去。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;：在《通往java之路》这个栏目，我不想表现出更多的功利主义。我希望在这个栏目中每一篇文章都有很强的可读性和趣味性，能让我闲暇之时也能好好的阅读。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正文&lt;/strong&gt;：当我们使用缓存时，目标通常有两个：</summary>
      
    
    
    
    <category term="通往java之路" scheme="https://onlyonemomo.github.io/categories/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>胡适给儿子的一封信</title>
    <link href="https://onlyonemomo.github.io/2022/08/17/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/%E8%83%A1%E9%80%82%E7%BB%99%E5%84%BF%E5%AD%90%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/"/>
    <id>https://onlyonemomo.github.io/2022/08/17/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/%E8%83%A1%E9%80%82%E7%BB%99%E5%84%BF%E5%AD%90%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/</id>
    <published>2022-08-17T10:51:39.000Z</published>
    <updated>2022-08-25T12:46:53.809Z</updated>
    
    <content type="html"><![CDATA[<p>我养育你，并非恩情，</p><p>只是血缘使然的生物本能。</p><p>所以，我既然无恩于你，</p><p>你便无需报答我。</p><p>反而，我要感谢你，</p><p>因为有你的参与，我的生命才更完整。</p><p>我只是碰巧成为了你的父亲，</p><p>你只是碰巧成为了我的女儿和儿子。</p><p>我不是你的前传，</p><p>你也不是我的续篇。</p><p>你是独立的个体，</p><p>是与我不同的灵魂。</p><p>你并不因我而来，</p><p>你是因对生命的渴望而来。</p><p>你是自由的，我是爱你的。</p><p>但我绝不会“以爱之名”，去掌控你的人生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我养育你，并非恩情，&lt;/p&gt;
&lt;p&gt;只是血缘使然的生物本能。&lt;/p&gt;
&lt;p&gt;所以，我既然无恩于你，&lt;/p&gt;
&lt;p&gt;你便无需报答我。&lt;/p&gt;
&lt;p&gt;反而，我要感谢你，&lt;/p&gt;
&lt;p&gt;因为有你的参与，我的生命才更完整。&lt;/p&gt;
&lt;p&gt;我只是碰巧成为了你的父亲，&lt;/p&gt;
&lt;p&gt;你</summary>
      
    
    
    
    <category term="三千世界" scheme="https://onlyonemomo.github.io/categories/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/"/>
    
    
    <category term="教育" scheme="https://onlyonemomo.github.io/tags/%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
  <entry>
    <title>浅谈“ADE效应”陷阱</title>
    <link href="https://onlyonemomo.github.io/2022/08/16/%E6%B5%85%E8%B0%88%E2%80%9CADE%E6%95%88%E5%BA%94%E2%80%9D%E9%99%B7%E9%98%B1/"/>
    <id>https://onlyonemomo.github.io/2022/08/16/%E6%B5%85%E8%B0%88%E2%80%9CADE%E6%95%88%E5%BA%94%E2%80%9D%E9%99%B7%E9%98%B1/</id>
    <published>2022-08-16T14:36:56.000Z</published>
    <updated>2022-08-21T08:09:52.245Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语：</strong>ADE即抗体依赖增强。之前开发的登革病毒疫苗，还是西尼罗病毒疫苗，都被发现具有很强的ADE 效应，即针对E蛋白产生的抗体，会通过抗体的Fc受体结合巨噬细胞，并进入巨噬细胞，从而导致严重的细胞因子风暴。 这一ADE效应导致接种过西尼罗病毒疫苗的人反而更容易感染其他黄病毒（登革病毒、寨卡病毒！ 科学家早在1979年发表的《Nature》文章中就研究了黄病毒的 ADE 效应（Antibody-mediated enhancement of flavivirus replication in macrophage-like cell lines. Nature 1979）</p><p><strong>正文：</strong>通过导语可知，我们原有的观念就发生了颠覆。我们一直以为打了疫苗就可以有抗体抵御病毒攻击，可事实却相反！这就是“ADE效应“。我们的生活中也常常陷入“ADE效应陷阱”，像心理疾病一样，去看心理医生往往病情无法减轻，甚至可能更加重病情，但我们通过森田疗法（也称〃放弃治疗〃）常常有意想不到的效果！</p><h3 id="1、生活中有哪些ADE效应陷阱？"><a href="#1、生活中有哪些ADE效应陷阱？" class="headerlink" title="1、生活中有哪些ADE效应陷阱？"></a>1、生活中有哪些ADE效应陷阱？</h3><p><strong>心理疾病的ADE效应陷阱：</strong>根据传统认知，我们不能讳疾忌医，生病就应该去看医生。但是心理疾病确实一大反例，例如森田正马，“上学时，医生诊断为神经衰弱和脚气病，经常服药治疗，大学一年级时，父母因农忙，两个月忘记了给森田寄生活费，森田误以为是父母不支持他上学，感到很气愤，甚至想到当着父母的面自杀，于是暗下决心，豁出去拼命地学习，要干出个样子来让家里人看看，在这时期什么药也不吃了，放弃一切治疗，不顾一切地拼命学习，考完试后，取得了想不到的好成绩，不知什么时候，神经衰弱和脚气病等症状不知不觉也消失了。”</p><p><strong>古典文学的ADE效应陷阱：</strong>人们常说，要多读点书，可是有的书越读越困惑。胡适编写的《中国古代哲学 简史》里面就举例了大量的伪篇。“汉代的书，如贾谊的《新书》，董仲舒的《春秋繁露》，都有后人增加 的痕迹。又如王充的《论衡》，是汉代一部奇书，但其中如《乱龙篇》极力为董仲舒作土龙求雨一事辩护，与全书的宗旨恰相反。篇末又有”论衡终之，故曰 乱龙。乱者，终也“ 的话，全无道理。明是后人假造 的。此外重复的话极多。伪造的书定不止这一篇。又 如仲长统的《昌言》，乃是中国政治哲学史上有数的书，如今已失，仅存三篇魏晋人的书，散失更多。 《三国志》、《晋书》、《世说新语》所称各书，今 所存的，不过几部书。如《世说新语》说魏晋注《庄 子》的有几十家，今但有郭象注完全存在。” </p><p><strong>新闻的ADE效应陷阱：</strong>美国的总统拜登，在演讲中频频出错，就如同一个老年痴呆一样。本来是竞选总统的，但是他竟然说成竞选参议员，更有甚者认为美国白宫里面的总统并不是拜登。给大家普及一下，美国总统身份验证需要46项生物信息，包括指纹，笔迹等。拜登总统是一个老的政治家，政治家在公共场所 的所言所行都是有深意的。顺便说一下，<strong>政治没有巧合！</strong>由此可见，人们并不具备辨别假新闻的能力。</p><p><strong>体育上的ADE效应陷阱：</strong>我们的乒乓球很厉害，为什 么足球这么差劲？大家都在责怪足球运动员拿高薪， 却没有成就。大家可以看一下国外有哪些乒乓球俱乐部吗？足球的俱乐部我倒是知道很多，例如：皇家马德里足球俱乐部、拜仁慕尼黑俱乐部、巴塞罗那足球俱乐部、曼彻斯特联足球俱乐部、切尔西足球俱乐部 等。乒乓球就是一个业余活动，怎么能跟人家专业的比呢？我相信还有人不服气，我再说一个例子。我们知道学术界最高奖项是诺贝尔奖，但是很多人说受外国势力控制。那菲尔兹奖（全世界最高的数学奖）呢？ 只要你能证明得了数学，就可以获奖了。这个总不能再受外国势力控制了吧！中国一个人都没能获得过这个奖项，倒是奥数经常碾压外国人。</p><p><strong>逻辑上的ADE效应陷阱：</strong>由于我们受到意识形态影响太深，明明一些没有逻辑的话，却认为很有道理。例 如，“落后就要挨打”，为什么落后就要挨打呢？有人公然地说，“穷是原罪”，而希特勒的口号是，“让每一 户德国人餐桌上都有面包和牛奶”。</p><p><strong>小结：</strong>像生活中诸如此类地ADE效应很普遍，但大多数的人都深陷〃ADE效应陷阱〃里面无法自拔。由于填鸭式地教育的影响，我们明明知道这些不合理却无法跳出这个思想的沼泽，更无法有力的还击这些人。</p><h3 id="2-如何确定百分百正确的知识？"><a href="#2-如何确定百分百正确的知识？" class="headerlink" title="2.如何确定百分百正确的知识？"></a>2.如何确定百分百正确的知识？</h3><p><strong>”如何确定百分百正确的知识？“</strong>相信很多人说，这不可能获得百分百正确的知识。就算是牛顿的经典力学，也被爱因斯坦的相对论击败。这里我想引用一个小故事说明，“某高校的课堂上，有个教授问女学生， 你愿意接受你的男朋友一年365天，364天都是爱着你 的，另外一天是爱着别人的吗？女生思索了一下，然后坚定地说，不行！他必须365天中每一分钟都是爱着我的。”虽然明知道她的男朋友不可能每一分钟都是爰着她的，但她仍然这样要求。这就是在追求百分百确定的知识！</p><p><strong>”如何确定百分百正确的知识？“</strong>是笛卡尔提出来的。 笛卡尔提出来这个问题，引爆了欧洲的讨论，从而开创现代文明。人民从此告别了旧时代，迎接新科学。 顺带一提，数学的演绎推理便是他开创的。科学有可能会出错，但是数学永远不会出错！</p><h5 id="2-1、-笛卡尔知识论的问题：如何获得100-确定的知识？"><a href="#2-1、-笛卡尔知识论的问题：如何获得100-确定的知识？" class="headerlink" title="2.1、 笛卡尔知识论的问题：如何获得100%确定的知识？"></a>2.1、 笛卡尔知识论的问题：如何获得100%确定的知识？</h5><blockquote><p><strong>(1)拒绝既定的现象</strong><br><strong>(2)拒绝确定的教条</strong><br><strong>(3)拒绝过去的权威</strong><br><strong>(4)只接受个人理性验证为实的真理</strong></p></blockquote><p>笛卡尔有一天晚上连续做了三个梦，梦中梦。由此<strong>方法论</strong>就诞生了。例如《楚门的世界》，便是根据笛卡尔的方法论而拍摄的。在这里我想用一个例子来说明，100%确定知识的运用！像传销1040阳关工程， 他们所用的手法都是很低级的。他们使用心灵的复杂学习即**”谎言说一千遍便成真的”**，非常好破解。投资本来就是有赔有赚的，他们说投资就能获得高回报， 明显违背了市场的运行。又如六合彩百分百”特码”诈 骗，骗子往五百多万的手机号分为49的倍数，发一条 “特码”信息。连续四次便有49个人连续中4次特码，接下来骗子便打电话索要好处费。因为人民缺乏这个知识论的思维，认为人家真的能掌握特码信息。</p><h5 id="2-2、-如何建立自己的体系"><a href="#2-2、-如何建立自己的体系" class="headerlink" title="2.2、 如何建立自己的体系"></a>2.2、 如何建立自己的体系</h5><p>在讲完笛卡尔的100%确定的知识，就涉及到了如何建立自己的体系。攻防是一体的，道高一尺魔高一 丈。我们用笛卡尔获取知识的方法去思考规则：</p><blockquote><p><strong>a.拒绝偏见，获得【清晰与明确的知识】</strong><br><strong>b.分析细部来解决问题</strong><br><strong>c.从简而繁，由浅入深来构建解决问题的秩序</strong><br><strong>d.全面的确定没有遗漏应当检视的对象</strong></p></blockquote><p>规则的目的，运用理智，找出事物的方法。方法的目的在于挖掘事物，找出它们，并确定所找出的为真。 除非清晰地认知，否则不接受任何事物为真，甚至怀疑原有已经接受事物地真实性。<strong>我们要以一个什么都 不知道的人为出发点，然后以其个人的智力来挖掘与确定的知识。</strong>在信息大爆炸的时代，如何获取真实的信息尤为重要。例如我们日常下载的软件，如何确保不是盗版的？如Python下载，官网下载速度极慢，我想到其他的网站或者共享盘下载。如何保证下载的是官网的，而不是被人动了手脚？这时候我们可以校验它的MD5&#x2F;SHA1。</p><p>又如目前的区块链技术，到底是这个世界的未来，还是一波炒作的概念捞钱的手段。这就需要我们凭借自己的个人智力来挖掘这个区块链到底是什么？为什么这么多人推崇，有人这么多人诋毁？</p><p><strong>在建立体系的关键</strong>，在于必须有一个公共的标准。如果不是这样，就不能对事物有一个公正的判断。但是”公正“从何而来？答曰：来自一个共同的标准。我们要用一个同样的标准、一个客观的标准，一个大家乐于接受的标准。这样我们才能揭穿假象，辨别实情，回答种种的污蔑。例如，对待近代史的人物评判，这个标准是爰国的还是卖国的，是民主的还是走向专制 的。我相信这个标准是大家都乐于接受和认同的。回想过去，每当我与别人争论的时候，盖因〃批判的武器 〃，而不会受到〃武器的批判〃，才会使我落入敌人语言上的”圈套“。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;导语：&lt;/strong&gt;ADE即抗体依赖增强。之前开发的登革病毒疫苗，还是西尼罗病毒疫苗，都被发现具有很强的ADE 效应，即针对E蛋白产生的抗体，会通过抗体的Fc受体结合巨噬细胞，并进入巨噬细胞，从而导致严重的细胞因子风暴。 这一ADE效应导致接种过西尼罗病</summary>
      
    
    
    
    <category term="三千世界" scheme="https://onlyonemomo.github.io/categories/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/"/>
    
    
    <category term="知识论" scheme="https://onlyonemomo.github.io/tags/%E7%9F%A5%E8%AF%86%E8%AE%BA/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"onlyonemomo.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="springcloud常用组件"><meta property="og:type" content="article"><meta property="og:title" content="30道高频面试题答案"><meta property="og:url" content="https://onlyonemomo.github.io/2022/08/24/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/30%E9%81%93%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/index.html"><meta property="og:site_name" content="博客"><meta property="og:description" content="springcloud常用组件"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-08-24T09:03:39.000Z"><meta property="article:modified_time" content="2022-08-24T09:04:01.875Z"><meta property="article:author" content="onlyone Mo"><meta property="article:tag" content="面试必看"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://onlyonemomo.github.io/2022/08/24/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/30%E9%81%93%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>30道高频面试题答案 | 博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">博客</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">世界好大，修行好难</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">9</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">18</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://onlyonemomo.github.io/2022/08/24/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/30%E9%81%93%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="onlyone Mo"><meta itemprop="description" content="一切刚刚开始！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">30道高频面试题答案</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-08-24 17:03:39 / 修改时间：17:04:01" itemprop="dateCreated datePublished" datetime="2022-08-24T17:03:39+08:00">2022-08-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/" itemprop="url" rel="index"><span itemprop="name">面试宝典</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h5 id="springcloud常用组件"><a href="#springcloud常用组件" class="headerlink" title="springcloud常用组件"></a>springcloud常用组件</h5><p>Eureka：服务注册和发现，由Netflix开源</p><p>Nacos：服务注册和发现，还有配置管理功能，由阿里巴巴开源</p><p>SpringCloudGateway：微服务网关，实现微服务统一路由，统一鉴权，跨域，限流等功能</p><p>Feign：微服务之间远程调用，由Netflix开源</p><p>Ribbon：负载均衡组件，在网关路由和Feign远程调用过程中的底层都会用到Ribbon做负载均衡。</p><h5 id="springboot的常用注解"><a href="#springboot的常用注解" class="headerlink" title="springboot的常用注解"></a>springboot的常用注解</h5><ul><li>@SpringBootApplication：SpringBoot项目最核心的主键。每个SpringBoot启动类上都有，用于引导SpringBoot项目启动加载。</li><li>@ComponentScan：用于扫描Spring的组件，并将其放入IOC容器。</li><li>@Configuration：声明该类为配置类</li><li>@ConditionOnClass：一般和@Configuration注解同时使用，项目中导入了@ConditionOnClass声明的类，@Configuration中的@Bean才会构建。</li><li>@ControllerAdvice和@RestControllerAdvice：声明该类为全局异常拦截类。</li></ul><h5 id="springboot自动装配"><a href="#springboot自动装配" class="headerlink" title="springboot自动装配"></a>springboot自动装配</h5><ul><li>在启动类启动时加载@SpringBootApplication注解</li><li>在@SpringBootApplication注解里面包含三个注解：@ComponentScan，@Configuration，@EnableAutoConfiguration</li><li>@Configuration表明启动类是一个配置类</li><li>@ComponentScan自动扫描启动类所在目录及子目录在Spring组件，让其实例化</li><li>@EnableAutoConfiguration注解里面包含AutoConfigurationImportSelector配置类<br>在AutoConfigurationImportSelecto配置类中会读取springboot自动配置包中的META-INF的spring.factories文件</li><li>该spring.factories文件包含一百多个SpringBoot写好的自动配置类，但这些自动配置类并不是默认生效的，而是根据环境中导入starter启动器依赖及自动配置类上@ConditionalOnClass注解来决定该配置类是否生效。一旦自动配置类生效了，里面@Bean注解会把创建实例放入IOC容器，我们在项目中就可以随时使用@Autowired进行注入并使用</li></ul><h5 id="springmvc和springboot的关系"><a href="#springmvc和springboot的关系" class="headerlink" title="springmvc和springboot的关系"></a>springmvc和springboot的关系</h5><p>Spring MVC提供了一种轻度耦合的方式来开发web应用。它是Spring的一个模块，是一个web层框架。</p><p>Spring Boot实现了自动配置，降低了Spring项目搭建的复杂度。</p><p>Spring Boot 只是 辅助你简化Spring项目搭建过程的 ，如果搭建的是Web项目，Web层采用SpringMVC，那么SpringMVC的工作原理还是和原来一样的，并没有因为用了SpringBoot而被改变。</p><h5 id="谈谈对spring的理解"><a href="#谈谈对spring的理解" class="headerlink" title="谈谈对spring的理解"></a>谈谈对spring的理解</h5><p>Spring的核心组件是：IOC（控制翻转）、DI（依赖注入）和AOP（面向切面编程）</p><ul><li>IOC意思是控制反转，IOC让对 象的创建不用去new了，可以由spring根据我们提供的配置文件自动生产，我们需要对象的时候， 直接从Spring容器中获取即可。</li><li>DI的意思是依赖注入，意思是程序在运行时依赖Ioc容器来动态注入对象需要的对象。</li><li>AOP，一般称为面向切面编程，可以方便将项目中与核心业务无关的代码进行抽取分离，最大程度地解耦。SpringAOP的底层一般采用JDK动态代理或者CGLIB动态代理实现。</li></ul><h5 id="spring-bean的生命周期"><a href="#spring-bean的生命周期" class="headerlink" title="spring bean的生命周期"></a>spring bean的生命周期</h5><ul><li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li><li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li><li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li><li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li><li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li><li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li><li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li><li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li><li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li></ul><h5 id="spring的ioc、di、aop分别是什么，ioc和di有什么关系"><a href="#spring的ioc、di、aop分别是什么，ioc和di有什么关系" class="headerlink" title="spring的ioc、di、aop分别是什么，ioc和di有什么关系"></a>spring的ioc、di、aop分别是什么，ioc和di有什么关系</h5><ul><li><p>IOC意思是控制反转，IOC让对 象的创建不用去new了，可以由spring根据我们提供的配置文件自动生产，我们需要对象的时候， 直接从Spring容器中获取即可。</p></li><li><p>DI的意思是依赖注入，意思是程序在运行时依赖Ioc容器来动态注入对象需要的对象。</p></li><li><p>AOP，一般称为面向切面编程，可以方便将项目中与核心业务无关的代码进行抽取分离，最大程度地解耦。SpringAOP的底层一般采用JDK动态代理或者CGLIB动态代理实现。</p></li><li><p>IOC侧重于构建对象上的解耦，对象构建交给SpringIOC容器构建。</p></li><li><p>DI侧重于使用对象上的解耦，需要使用什么对象从SpringIOC容器获取。</p></li></ul><h5 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h5><p>事务是一组原子操作单元，从数据库角度说，就是一组SQL指令，要么全部执行成功，若因为某个原因其中一条指令执行有错误，则撤销先前执行过的所有SQL指令。更简答的说就是：SQL要么全部执行成功，要么撤销不执行。</p><h5 id="事务的四大特性和隔离级别"><a href="#事务的四大特性和隔离级别" class="headerlink" title="事务的四大特性和隔离级别"></a>事务的四大特性和隔离级别</h5><p><strong>事务特性</strong></p><ul><li><p><strong>原子性</strong>：即不可分割性，事务要么全部被执行，要么就全部不被执行。</p></li><li><p><strong>一致性</strong>：事务的执行使得数据库从一种正确状态转换成另一种正确状态</p></li><li><p><strong>隔离性</strong>：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，</p></li><li><p><strong>持久性</strong>：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处</p><p>理结果也会得到保存。</p></li></ul><p><strong>隔离级别</strong></p><p>（1）<strong>读未提交</strong>（read Uncommited）:</p><p>在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项目中基本不 怎么用， 安全性太差；</p><p>(2) <strong>读已提交</strong>（read commited）:</p><p>这是大多数数据库默认的隔离级别，但是不是MySQL的默认隔离级别；这个隔离级别满足了简单的隔离 要求：一个事务只能看见已经提交事务所做的改变，所以会避免脏读问题； 由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读和虚读等问题</p><p>(3) <strong>可重复读</strong>（Repeatable read）： 这是MySQL的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取到一样的数 据；不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读 取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发生幻读。</p><p>(4**)** <strong>可串行化</strong>（serializable）： 事物的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每 个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争，一般为了提升程序的吞吐量不会采用这个；</p><h5 id="悲观锁和乐观锁的区别和应用场景"><a href="#悲观锁和乐观锁的区别和应用场景" class="headerlink" title="悲观锁和乐观锁的区别和应用场景"></a>悲观锁和乐观锁的区别和应用场景</h5><p>什么是悲观锁：</p><ul><li>总是假设最坏的情况，<strong>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上</strong> <strong>锁</strong>，这样别人想拿这个数据就会阻塞直到它拿到锁。</li></ul><p>悲观锁的应用场景：</p><ul><li>关系数据库的行级锁和表级锁等。</li></ul><p>什么是乐观锁：</p><p>总是假设最好的情况，<strong>每次去拿数据的时候都认为别人不会修改，所以不会上锁</strong>，但是在更新的时候会判断在此期间别人有没有去更新这个数据。</p><p>乐观锁的实现方式：</p><ul><li>可以使用<strong>版本号机制</strong>和CAS算法实现 版本号机制 在数据表中加入一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version 指会加一。当线程A要重新更新数据值时，在读取数据的时候也会读取version值，在提交更新 时，若刚才读取到的version值与当前数据库中的version值相等才更新，否则重新更新操作，直到 更新成功。</li></ul><p>悲观锁与乐观锁的应用差别：</p><ul><li><strong>乐观锁</strong>适用于写少读多的场景。这样可以省去了锁的开销，加 大了系统的整个<strong>吞吐量</strong>。</li><li><strong>悲观锁</strong>更适合读少写多的场景。因为如果在写多的场景下使用乐观锁，会导致应用会不断的进行重试，这样反倒是降低了性能，所以一般写多的场景下更适合才用<strong>悲观锁</strong>。</li></ul><h5 id="redis的数据类型，持久化方式"><a href="#redis的数据类型，持久化方式" class="headerlink" title="redis的数据类型，持久化方式"></a>redis的数据类型，持久化方式</h5><p>redis有5种数据类型：</p><ul><li>String</li><li>Set</li><li>List</li><li>Hash</li><li>SortedSet</li></ul><p>Redis持久化方式：</p><p>有两种，分别是RDB和AOF。RDB原理是对整个当前内存数据进行快照备份，体积小。AOF原理是每条操作指令都会持久化到文件，导致文件体积比较大RDB的两次备份时间间隔最短1分钟，时间长，容易导致数据丢失。而AOF默认间隔1秒1次，时间短，数据完整性高！恢复速度上来说，RDB比AOF稍快一些，因为体积小。</p><h5 id="redis缓存穿透、雪崩、击穿"><a href="#redis缓存穿透、雪崩、击穿" class="headerlink" title="redis缓存穿透、雪崩、击穿"></a>redis缓存穿透、雪崩、击穿</h5><p>什么是缓存雪崩：</p><p>缓存雪崩，即缓<strong>存同一时间大面积的失效</strong>，这个时候又来了一波 请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p><p>缓存雪崩解决方案：</p><p>1、给缓存的<strong>失效时间，加上一个随机值，避免集体失效</strong>。</p><p>2、使用互斥锁，但是该方案吞吐量明显下降了。</p><p>3、搭建 redis 集群</p><p>缓存击穿和缓存雪崩类似的，雪崩的大面积的key失效，击穿一般是个别key失效，解决办法可以和雪崩一样答。</p><p>什么是缓存穿透：</p><p><strong>缓存穿透，即黑客故意去请求缓存中不存在的数据</strong>，导致所有的请求都怼到数据库上，从而数据库连接 异常。</p><p>缓存穿透解决方案：</p><p>1、利用互斥锁，缓存失效的时候，先去获得锁，得到锁了， 再去请求数据库。没得到锁，则休眠一段时间重试</p><p>2、采用异步更新策略，无论 key 是否取到值，都直接返回， value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程 去读数据库，更新缓存。</p><h5 id="java的基本数据类型"><a href="#java的基本数据类型" class="headerlink" title="java的基本数据类型"></a>java的基本数据类型</h5><p><strong>字节型（byte）、短整型（short）、整型（int）、长整型（long）、单精度浮点型（float）和双精度浮点型（double）、布尔型（boolean）、字符型（char）</strong></p><h5 id="arraylist和linkedlist"><a href="#arraylist和linkedlist" class="headerlink" title="arraylist和linkedlist"></a>arraylist和linkedlist</h5><p>arraylist和linkedlist作用</p><p>ArrayList和LinkedList都是实现了List接口的容器类，用于存储一系列的对象引用。他们都可以对元素的</p><p>增删改查进行操作。 对于ArrayList<strong>，它在集合的末尾删除或添加元素所用的时间是一致的，但是在列表中间的部分添加或删*除时</strong>所用<strong>时间就会大大增加</strong>。但是它在根据索引<strong>查找元素</strong>的时候<strong>速度很快</strong>。</p><p>对于LinkedList则相反<strong>，它在</strong>插入、删除<strong>集合中任何位置的元素所</strong>花费的时间都是一样<strong>的，但是它查</strong>询一个元素<strong>的时候却</strong>比较慢。</p><p>arraylist和linkedlist区别</p><p>1**.ArrayList<strong>是实现了</strong>基于动态数组<strong>的数据结构，</strong>LinkedList<strong>是</strong>基于链表**结构。</p><p>2.对于<strong>随机访问</strong>的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。</p><p>3.对于新增和删除操作add和remove<strong>，</strong>LinkedList比较占优势，因为ArrayList要移动数据。</p><h5 id="hashtable和hashmap"><a href="#hashtable和hashmap" class="headerlink" title="hashtable和hashmap"></a>hashtable和hashmap</h5><p>1、HashMap 是<strong>非线程安全</strong>的，HashTable 是线程<strong>安全</strong>的。</p><p>2、HashMap 的键和值都<strong>允许有</strong> <strong>null</strong> <strong>值</strong>存在，而 HashTable 则<strong>不行</strong>。</p><p>3、因为线程安全的问题，HashMap <strong>效率</strong>比 HashTable 的<strong>要高</strong>。</p><p>4、Hashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线 <strong>程环境</strong>，而 Hashtable 适合于多线程环境。一般现在不建议用 HashTable, ① 是 HashTable 是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下， 现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用HashTable。</p><h5 id="jvm内存溢出"><a href="#jvm内存溢出" class="headerlink" title="jvm内存溢出"></a>jvm内存溢出</h5><p>在Java程序中，出现内存溢出的原因也有很多，常见的有堆内存溢出，直接内存溢出，永久区&#x2F;元空间溢出</p><p>1）堆内存溢出：</p><p>堆溢出这种是最常见的一种，在Java中堆是重要的一个空间，Java的大量对象都是直接在堆上分配的(参考<strong>内存分配</strong>)。当大量对象占据了堆空间而且都是强引用，使之始终无法被回收，当所有对象大小之和大于参数<code>-Xmx</code>指定的值时，就会出现溢出了。</p><p>如何处理</p><ul><li>首选检查代码是否存在循环或者死循环，是否能够不断的创建对象。</li><li>查看启动参数<code>-Xmx</code>和<code>-Xms</code> 设置的堆内存是否过小，不足以加载服务中的所有类，可以适当增加。</li><li>检查代码中是否存在数据库查询，没有分页一次性返回大量数据。</li><li>还可以通过MAT或者<strong>VisualVM工具</strong>分析，找到占用大量堆空间的对象，然后做出合理优化。</li></ul><p>2）<strong>直接内存溢出</strong></p><p>这个问题遇到的一般比较少，直接内存不是运行时数据区的一部分。</p><p>Java中NIO(New IO)是支持直接使用直接内存的，可以直接获取一块堆外空间使用，而这块空间是直接向操作系统申请的。直接内存的申请速度一般比堆内存慢，但是其访问速度要快于堆内存，所以如果存在可复用且经常被访问的空间，使用直接内存可以提高系统的性能。但是直接内存没有被Java完全托管，使用不当容易出现溢出的问题。</p><p>如何处理：</p><ul><li>检查程序中使用直接内存的代码是否恰当。</li><li>检查参数-Xmx和-XX:MaxDirectMemorySize 的大小是否合理，可以根据实际情况调整其大小。</li></ul><p>3）永久区&#x2F;元空间溢出</p><p>这种错误是永久代或者元空间溢出，在jdk1.8之前会出现这种错误，之后hotspot用元空间代替了永久代来存储class信息。如果一个系统在不断的创建新的类(不是对象实例)，那么最终会导致元空间溢出的。</p><p>如何处理：</p><ul><li>增加元空间的大小，设置其对应参数的值 <code>-XX:MaxMetaspaceSize=512m</code></li><li>减少系统需要的类的数量，检查是否有不需要的类并且清除掉。</li><li>使用ClassLoader合理的装载各个类，并定期进行回收。</li></ul><h5 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h5><p>调优目的：</p><p>对JVM内容的系统级的调优主要的目的是减少GC的频率和Full GC的次数。</p><p>调优步骤：</p><p>a. 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</p><p>b. 确定jvm调优量化目标；</p><p>c. 确定jvm调优参数（根据历史jvm参数来调整）；</p><p>d. 调优一台服务器，对比观察调优前后的差异；</p><p>e. 不断的分析和调整，知道找到合适的jvm参数配置；</p><p>f. 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</p><p>调优常见参数：<br>1）设定堆内存大小（比较常用的）<br>-Xmx：堆内存最大限制。</p><p>2）设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代<br>-XX:NewSize：新生代大小<br>-XX:NewRatio 新生代和老生代占比<br>-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比</p><p>3）设定垃圾回收器算法<br>年轻代用 -XX:+UseParNewGC<br>年老代用-XX:+UseConcMarkSweepGC</p><h5 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h5><ul><li>继承Thread类创建线程类</li><li>通过Runnable接口创建线程类</li><li>通过Callable和Future创建线程</li></ul><h5 id="线程池有几种"><a href="#线程池有几种" class="headerlink" title="线程池有几种"></a>线程池有几种</h5><ol><li><p><strong>newCachedThreadPool</strong>：创建一个<strong>可进行缓存重复利用的线程池</strong></p></li><li><p><strong>newFixedThreadPool</strong>：创建一个可重用<strong>固定线程数的线程池</strong>，以共享的无界队列方式来运行这些</p></li></ol><p>线程，线程池中的线程处于一定的量，可以很好的控制线程的并发量</p><ol start="3"><li><strong>newSingleThreadExecutor</strong>：创建一个使用单个 worker 线程的Executor ，以无界队列方式来运行</li></ol><p>该线程。线程池中<strong>最多执行一个线程，之后提交的线程将会排在队列中以此执行</strong></p><ol start="4"><li><strong>newSingleThreadScheduledExecutor</strong>：创建<strong>一个单线程</strong>执行程序，它可安排在<strong>给定延迟后运行命</strong></li></ol><p><strong>令或者定期执行</strong></p><ol start="5"><li><p><strong>newScheduledThreadPool</strong>：创建一个线程池，它可安排在给<strong>定延迟后运行命令或者定期的执行</strong></p></li><li><p><strong>newWorkStealingPool</strong>：创建一个带并<strong>行级别的线程池</strong>，并行级别决定了同<strong>一时刻</strong>最多有<strong>多</strong>少个</p></li></ol><p><strong>线程在执行</strong>，如不传并行级别参数，将默认为当前系统的<strong>CPU核心数</strong>*2</p><h5 id="mysql的引擎有几种"><a href="#mysql的引擎有几种" class="headerlink" title="mysql的引擎有几种"></a>mysql的引擎有几种</h5><p>InnoDB：MySQL默认存储引擎。支持事务。支持行级锁和表级锁。索引采用聚簇索引（索引和数据存储在一个文件，提升查询性能）。</p><p>MyISAM：不支持事务。仅仅支持表级锁。索引采用非聚簇索引（索引和数据分开存储，查询性能差一些）。</p><h5 id="项目中有没有设计表，都有哪些字段"><a href="#项目中有没有设计表，都有哪些字段" class="headerlink" title="项目中有没有设计表，都有哪些字段"></a>项目中有没有设计表，都有哪些字段</h5><p>根据自己项目自由发挥</p><h5 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h5><p>首先开启数据库慢查询日志，定位到查询效率比较低的sql , 找出对应的sql语句并进行分析</p><p>1.表设计是否规范，是否符合三范式的标准</p><p>(1)第一范式：保证原子性(不可拆分)</p><p>(2)第二范式：每张表都有主键</p><p>(3)第三范式(每一列都有主键相关)</p><p>2.查看数据表中是否存在大量的冗余字段，字段数据类型是否合理</p><p>3.尽可能的使用varchar代替char 建表数据类型，能用数值的绝对不用字符存储</p><p>4.尽量避免null值，使用默认值替代空值，数值型可以使用0，字符型可以使用空字符串</p><p>查看sql语句是否规范：</p><p>(1)避免使用关键字：or ，in，not in ，!&#x3D;，&lt;&gt;，避免使用select *</p><p>(2)尽量避免子查询，大部分子查询都可以连接查询</p><p>(3)用到or的地方可以使用union去代替实现</p><p>(4)用到in的地方可以使用exists去代替</p><p>分析sql的索引是否可以用上：</p><p>(1) explain查询sql的执行计划,重点关注的几个列就是，type是不是全表扫描</p><p>(2)看一下索引是否能够用的上,主要看key使用的是哪个索引</p><p>(3)看一下rows扫描行数是不是很大</p><h5 id="eureka和nacos的区别"><a href="#eureka和nacos的区别" class="headerlink" title="eureka和nacos的区别"></a>eureka和nacos的区别</h5><p>1）Nacos可以实现服务注册发现，也可以做配置管理；Eureka只能做服务注册发现。<br>2）Nacos临时实例心跳不正常会被剔除，非临时实例（永久实例）则不会被剔除；而Eureka只能注册临时实例，实例失效会被剔除（Eureka不支持永久实例）<br>3）Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式；而Eureka只有心跳模式；<br>4）Nacos支持服务列表变更的消息主动通知模式，服务列表更新更及时，减少服务调用失败的机率；而Eureka采用被动定时服务列表拉取更新；</p><h5 id="项目中用到什么设计模式，单例有几种"><a href="#项目中用到什么设计模式，单例有几种" class="headerlink" title="项目中用到什么设计模式，单例有几种"></a>项目中用到什么设计模式，单例有几种</h5><ul><li>单例设计模式</li><li>代理模式</li><li>装饰者</li><li>工厂模式</li><li>建造者模式</li></ul><p>单例有懒汉式 和 饿汉式</p><h5 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h5><ol><li><p>用户发送请求到前端控制器（DispatcherServlet）</p></li><li><p>前端控制器（DispatcherServlet）收到请求调用处理器映射器（HandlerMapping），去查找处理器 （Handler）</p></li><li><p>处理器映射器（HandlerMapping）找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p></li><li><p>前端控制器（DispatcherServlet）调用处理器映射器（HandlerMapping）</p></li><li><p>处理器适配器（HandlerAdapter）去调用自定义的处理器类(Controller，也叫后端控制器)。 自定义的处理器类(Controller，也叫后端控制器)将得到的参数进行处理并返回结果给处理器映 射器（HandlerMapping）</p></li><li><p>处理器适配器（HandlerAdapter）将得到的结果返回给前端控制器（DispatcherServlet）</p></li><li><p>DispatcherServlet(前端控制器)将ModelAndView传给视图解析器(ViewReslover)</p></li><li><p>视图解析器(ViewReslover)将得到的参数从逻辑视图转换为物理视图并返回给前端控制器</p></li></ol><p>（DispatcherServlet）</p><ol start="9"><li><p>前端控制器（DispatcherServlet）调用物理视图进行渲染并返回</p></li><li><p>前端控制器（DispatcherServlet）将渲染后的结果返回</p></li></ol><h5 id="mybatis的-和"><a href="#mybatis的-和" class="headerlink" title="mybatis的$和#"></a>mybatis的$和#</h5><p><strong>1， #是一个占位符，$是拼接符。</strong></p><p>#是一个占位符，$是拼接符。</p><p><strong>（1）</strong>使用#parameterName方式引用参数的时候，Mybatis会把传入的参数当成是一个字符串，自动添加双引号。</p><p>（2）使用$parameterName引用参数时，不做任何处理，直接将值拼接在sql语句中。</p><p><strong>2，使用 # 能够防止sql注入，$不能避免注入攻击。</strong></p><p>#的方式引用参数，mybatis会先对sql语句进行预编译，然后再引用值，能够有效防止sql注入，提高安全性。$的方式引用参数，sql语句不进行预编译。</p><h5 id="为什么要用es，es的倒排索引是什么"><a href="#为什么要用es，es的倒排索引是什么" class="headerlink" title="为什么要用es，es的倒排索引是什么"></a>为什么要用es，es的倒排索引是什么</h5><p>为什么用ES？</p><p>1）MySQL的海量数据时，搜索效率比较低，而Elasticsearch采用倒排索引法检测数据，从而效率更高。<br>2）MySQL的搜索功能比较弱，只有like这种模糊搜索，而Elasticsearch拥有大量复杂搜索的API，更加适合数据搜索场景</p><p>ES的倒排索引：</p><p>1）首先，Elasticsearch将文档数据进行索引构建。将文档数据需要分词的字段内容使用分词器进行分词，并记录每个词条和原文档的出现位置和出现频率等信息，构建出文档的索引库。<br>2）然后，用户搜索时，可以对关键词进行分词，使用分词后词条来匹配索引库，在索引库匹配到记录后，通过文档位置频率信息，反查具体的文档数据。</p><h5 id="rabbitmq-x2F-rocketmq、kafka的了解"><a href="#rabbitmq-x2F-rocketmq、kafka的了解" class="headerlink" title="rabbitmq&#x2F;rocketmq、kafka的了解"></a>rabbitmq&#x2F;rocketmq、kafka的了解</h5><p>RabbitMQ：<br>优势：<br>1）支持语言非常广<br>2）稳定性很好，采用Erlang语言开发<br>3）吞吐量不算低，万级<br>4）RabbitMQ官方提供7种消息发送模式，开发者轻松选择合适的模式进行开发即可<br>缺点：<br>1）采用Erlang，太小众，研究源码很难</p><p>Kafka：<br>优势：<br>1）高吞吐量，百万级<br>2）稳定性好，采用zookeeper进行注册（Zookeep采用CP模式，高一致模式）<br>3）可以应用在大数据数据处理领域（KafkaStream）<br>缺点：<br>1）支持的开发语言比较少<br>2）耦合zk，依赖zookeeper进行注册</p><h5 id="spring中-Autowired和-Resource的区别"><a href="#spring中-Autowired和-Resource的区别" class="headerlink" title="spring中@Autowired和@Resource的区别"></a>spring中@Autowired和@Resource的区别</h5><ul><li>@Autowired是Spring的，@Resource是javax包下的</li><li>@Autowired默认按类型匹配，@Resource默认按名称匹配</li><li>@Autowired和@Qualifier一起用，@Resource单独用</li></ul><h5 id="mysql索引数据结构，为什么用的是b-树不用红黑树"><a href="#mysql索引数据结构，为什么用的是b-树不用红黑树" class="headerlink" title="mysql索引数据结构，为什么用的是b+树不用红黑树"></a>mysql索引数据结构，为什么用的是b+树不用红黑树</h5><p>1）Hash哈希，只适合等值查询，不适合范围查询<br>2）一般二叉树，可能会特殊化为一个链表，相当于全表扫描<br>3）红黑树，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了。<br>4）B树在范围查询时，存在回旋查找的问题，导致性能不高。B+树叶子节点是有序链表，更有利于范围查询。</p><p>综上所述，MySQL的索引数据结构最适合采用B+树来实现。而且为了提高索引前后范围检索效率，MySQL改造了传统的B+树，形成了双向链指针。</p><h5 id="mysql和redis如何保证数据一致性"><a href="#mysql和redis如何保证数据一致性" class="headerlink" title="mysql和redis如何保证数据一致性"></a>mysql和redis如何保证数据一致性</h5><p>1）缓存延迟双删</p><ul><li><p>先删除缓存</p></li><li><p>写数据库</p></li></ul><p>休眠 500 毫秒，然后删除缓存</p><p>这样，读取脏数据的时间最多只有500毫秒。关键是如何确定睡眠时间？ 延迟时间的目的是为了保证读请求结束，写请求可以删除读请求引起的缓存脏数据。 因此，我们需要自己评估项目的数据读取业务逻辑的耗时，在读取时间的基础上加上几百毫秒的延迟时间。</p><p>2）删除缓存重试机制</p><p>缓存删除失败怎么办？比如延迟双删的第二次删除失败，说明脏数据无法删除。 使用重试机制保证缓存删除成功。 比如重试3次，失败3次，就会将日志记录到数据库中，并发出警告进行人工干预。 在高并发场景下，重试最好采用异步方式，比如向MQ中间件发送消息，实现异步解耦。</p><p>3）读取 bin-log 异步删除</p><ul><li><p>更新数据库。</p></li><li><p>数据库会将操作信息记录在bin-log日志中。</p></li><li><p>使用 canal 订阅 bin-log 日志获取目标数据和密钥。</p></li><li><p>缓存删除系统获取canal数据，解析目标key，尝试删除缓存。</p></li><li><p>如果删除失败，将消息发送到消息队列。</p></li><li><p>缓存删除系统再次从消息队列中获取数据，再次执行删除操作。</p></li></ul><h4 id="扩展具难面试题："><a href="#扩展具难面试题：" class="headerlink" title="扩展具难面试题："></a>扩展具难面试题：</h4><h5 id="1、多线程在项目中的使用场景"><a href="#1、多线程在项目中的使用场景" class="headerlink" title="1、多线程在项目中的使用场景"></a>1、多线程在项目中的使用场景</h5><ul><li>多线程批量导入MySQL数据到ES</li><li>CRM采用异步线程执行多个统计SQL</li></ul><h5 id="2、项目中是否有高并发导致的问题"><a href="#2、项目中是否有高并发导致的问题" class="headerlink" title="2、项目中是否有高并发导致的问题"></a>2、项目中是否有高并发导致的问题</h5><ul><li>mysql和redis数据一致性问题</li><li>ThreadLocal存储登录用户ID</li></ul><h5 id="3、线程不安全导致的问题"><a href="#3、线程不安全导致的问题" class="headerlink" title="3、线程不安全导致的问题"></a>3、线程不安全导致的问题</h5><p>共享数据安全问题（分布式锁解决）</p><h5 id="4、并发安全的集合有哪些"><a href="#4、并发安全的集合有哪些" class="headerlink" title="4、并发安全的集合有哪些"></a>4、并发安全的集合有哪些</h5><p>ConcurrentHashMap</p><p>CopyOnWriteArrayList</p><h5 id="5、sql慢查询优化、行锁、表锁"><a href="#5、sql慢查询优化、行锁、表锁" class="headerlink" title="5、sql慢查询优化、行锁、表锁"></a>5、sql慢查询优化、行锁、表锁</h5><p>1)避免回表查询</p><p>2)联合索引</p><p>3)避免索引失效</p><p>4）使用执行计划优化</p><p>表级锁：对整个表记录锁定，一个事务修改表数据的时候，另一个事务无法修改表数据。</p><p>语法：<br>lock table tb_user read local;<br>update tb_user ssss<br>insert into tb_user<br>unlock;</p><p>特点：锁定范围比较大，比较影响性能<br>应用场景：在数据迁移场景下使用</p><p>行级锁：对表的某条（某些）记录锁定。</p><p>行级锁分为 共享锁 和 排他锁</p><p>共享锁：一个事务在修改记录的时候，另一个事务无法修改记录，但是可以读取。<br>update tb_user set sex&#x3D;’女’ where id &#x3D; 1 lock in share mode;</p><p>排他锁：一个事务在查询&#x2F;修改记录的时候，另一个事务无法修改和读取数据。<br>select * from tb_user where id &#x3D; 1 for update;</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/" rel="tag"># 面试必看</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/08/22/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8B%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8/" rel="prev" title="模块化之消息转换器"><i class="fa fa-chevron-left"></i> 模块化之消息转换器</a></div><div class="post-nav-item"><a href="/2022/08/24/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/Springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86%E4%B9%8B%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/" rel="next" title="Springboot自动装配的原理">Springboot自动装配的原理 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#springcloud%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">1.</span> <span class="nav-text">springcloud常用组件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#springboot%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">springboot的常用注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-number">3.</span> <span class="nav-text">springboot自动装配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#springmvc%E5%92%8Cspringboot%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.</span> <span class="nav-text">springmvc和springboot的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9spring%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">谈谈对spring的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spring-bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">6.</span> <span class="nav-text">spring bean的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spring%E7%9A%84ioc%E3%80%81di%E3%80%81aop%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8Cioc%E5%92%8Cdi%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="nav-number">7.</span> <span class="nav-text">spring的ioc、di、aop分别是什么，ioc和di有什么关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="nav-number">8.</span> <span class="nav-text">什么是事务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">事务的四大特性和隔离级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">10.</span> <span class="nav-text">悲观锁和乐观锁的区别和应用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">11.</span> <span class="nav-text">redis的数据类型，持久化方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF"><span class="nav-number">12.</span> <span class="nav-text">redis缓存穿透、雪崩、击穿</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.</span> <span class="nav-text">java的基本数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#arraylist%E5%92%8Clinkedlist"><span class="nav-number">14.</span> <span class="nav-text">arraylist和linkedlist</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashtable%E5%92%8Chashmap"><span class="nav-number">15.</span> <span class="nav-text">hashtable和hashmap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jvm%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">16.</span> <span class="nav-text">jvm内存溢出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jvm%E8%B0%83%E4%BC%98"><span class="nav-number">17.</span> <span class="nav-text">jvm调优</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">18.</span> <span class="nav-text">创建线程的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">19.</span> <span class="nav-text">线程池有几种</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql%E7%9A%84%E5%BC%95%E6%93%8E%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">20.</span> <span class="nav-text">mysql的引擎有几种</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E8%AE%BE%E8%AE%A1%E8%A1%A8%EF%BC%8C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5"><span class="nav-number">21.</span> <span class="nav-text">项目中有没有设计表，都有哪些字段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sql%E4%BC%98%E5%8C%96"><span class="nav-number">22.</span> <span class="nav-text">sql优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#eureka%E5%92%8Cnacos%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">23.</span> <span class="nav-text">eureka和nacos的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8D%95%E4%BE%8B%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">24.</span> <span class="nav-text">项目中用到什么设计模式，单例有几种</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">25.</span> <span class="nav-text">SpringMVC的执行流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mybatis%E7%9A%84-%E5%92%8C"><span class="nav-number">26.</span> <span class="nav-text">mybatis的$和#</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8es%EF%BC%8Ces%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">27.</span> <span class="nav-text">为什么要用es，es的倒排索引是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rabbitmq-x2F-rocketmq%E3%80%81kafka%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">28.</span> <span class="nav-text">rabbitmq&#x2F;rocketmq、kafka的了解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spring%E4%B8%AD-Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">29.</span> <span class="nav-text">spring中@Autowired和@Resource的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84%E6%98%AFb-%E6%A0%91%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">30.</span> <span class="nav-text">mysql索引数据结构，为什么用的是b+树不用红黑树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql%E5%92%8Credis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">31.</span> <span class="nav-text">mysql和redis如何保证数据一致性</span></a></li></ol><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%85%B7%E9%9A%BE%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="nav-number"></span> <span class="nav-text">扩展具难面试题：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">1、多线程在项目中的使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">2、项目中是否有高并发导致的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">3、线程不安全导致的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">4.</span> <span class="nav-text">4、并发安全的集合有哪些</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81sql%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E3%80%81%E8%A1%8C%E9%94%81%E3%80%81%E8%A1%A8%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">5、sql慢查询优化、行锁、表锁</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">onlyone Mo</p><div class="site-description" itemprop="description">一切刚刚开始！</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:onlyonemomo@outlook.com" title="E-Mail → mailto:onlyonemomo@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div><a target="_blank" class="social-link" href="/atom.xml" style="color:#deb887"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">onlyone Mo</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>
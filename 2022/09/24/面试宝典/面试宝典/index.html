<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"onlyonemomo.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta property="og:type" content="article"><meta property="og:title" content="面试题答案"><meta property="og:url" content="https://onlyonemomo.github.io/2022/09/24/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/index.html"><meta property="og:site_name" content="博客"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-09-24T09:03:39.000Z"><meta property="article:modified_time" content="2022-10-20T06:01:08.463Z"><meta property="article:author" content="onlyone Mo"><meta property="article:tag" content="面试必看"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://onlyonemomo.github.io/2022/09/24/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>面试题答案 | 博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">博客</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">世界好大，修行好难</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">12</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">82</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="comment fa-fw"></i>留言板</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://onlyonemomo.github.io/2022/09/24/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/qiaoba.gif"><meta itemprop="name" content="onlyone Mo"><meta itemprop="description" content="一切刚刚开始！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">面试题答案</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-09-24 17:03:39" itemprop="dateCreated datePublished" datetime="2022-09-24T17:03:39+08:00">2022-09-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-10-20 14:01:08" itemprop="dateModified" datetime="2022-10-20T14:01:08+08:00">2022-10-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/" itemprop="url" rel="index"><span itemprop="name">面试宝典</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="面试宝典"><a href="#面试宝典" class="headerlink" title="面试宝典"></a>面试宝典</h3><h5 id="1、多态的前提"><a href="#1、多态的前提" class="headerlink" title="1、多态的前提"></a>1、多态的前提</h5><blockquote><p>多态是同一个行为具有多种不同表现形式。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">多态的前提：</span><br><span class="line"><span class="code">    1.有继承/实现的关系</span></span><br><span class="line"><span class="code">    2.有方法重写</span></span><br><span class="line"><span class="code">    3.父类引用指向子类对象</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">多态下方法的访问：编译看左边，运行看右边</span></span><br><span class="line"><span class="code">多态下变量的访问：编译看左边，运行看左边（变量没有多态）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">多态的缺点：</span><br><span class="line"><span class="code">    多态下，无法使用子类独有的方法</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">多态的优点：提高代码的扩展性。</span><br><span class="line">定义方法时，如果将父类 或 接口 作为参数，在调用方法时，可以传递任意子类对象极大提高方法的通用性。</span><br></pre></td></tr></table></figure><h5 id="2、方法重写的要求"><a href="#2、方法重写的要求" class="headerlink" title="2、方法重写的要求"></a>2、方法重写的要求</h5><blockquote><p>方法重写：子类继承了父类的某一个方法，对父类的方法进行升级和改造<br>@Override &#x2F;&#x2F;注解, 可以检查重写的语法是否正确</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法重写的要求：</span><br><span class="line">    <span class="number">1.</span>方法名，参数列表要相同</span><br><span class="line">    <span class="number">2.</span>返回值如果是基本类型，必须一样，如果是引用类型，子类可以是更小的类型</span><br><span class="line">    <span class="number">3.</span>重写的方法，权限 大于或等于父类的方法 （<span class="keyword">public</span> &gt; <span class="keyword">protected</span>  &gt; 缺省 &gt;  <span class="keyword">private</span>）</span><br><span class="line">    <span class="number">4.</span>父类私有的方法，不能重写</span><br></pre></td></tr></table></figure><h5 id="3、重载和重写的区别"><a href="#3、重载和重写的区别" class="headerlink" title="3、重载和重写的区别"></a>3、重载和重写的区别</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 重载：</span><br><span class="line">发生在同一个类中，方法名相同，参数列表不一致，构成重载，与返回值类型无关。</span><br><span class="line">参数列表 :<span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> a+b&#125; 方法的参数列表就是(<span class="type">int</span>,<span class="type">int</span>)</span><br><span class="line"><span class="number">2.</span> 重写：</span><br><span class="line">发生在父子类中，方法名.参数列表必须相同，返回值范围小于等于父类，抛出的异</span><br><span class="line">常范围小于等于父类，</span><br></pre></td></tr></table></figure><h5 id="4、泛型的作用-lt-gt-和-的使用场景-和区别"><a href="#4、泛型的作用-lt-gt-和-的使用场景-和区别" class="headerlink" title="4、泛型的作用  &lt;?&gt; 和  的使用场景 和区别"></a>4、泛型的作用 &lt;?&gt; 和<t>的使用场景 和区别</t></h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T</span>：表示确定的类型，最常用的泛型表示方法。 </span><br><span class="line">? ：表示不确定的类型，类似于通配符。</span><br><span class="line"></span><br><span class="line"><span class="built_in">T</span>和? 运用的地方有点不同, ?是定义在引用变量上, <span class="built_in">T</span>是类上或方法上</span><br></pre></td></tr></table></figure><h5 id="5、java集合有哪些数据结构"><a href="#5、java集合有哪些数据结构" class="headerlink" title="5、java集合有哪些数据结构"></a>5、java集合有哪些数据结构</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">栈    先进后出  弹夹</span><br><span class="line">队列  先进先出  排队</span><br><span class="line"></span><br><span class="line">数组  查询快，增删慢 （索引）定义的时候就指定空间  <span class="built_in">ArrayList</span></span><br><span class="line">链表  查询慢，增删快 （节点）空间不受限制   LinkedList</span><br></pre></td></tr></table></figure><h5 id="6、hashmap和currenthashmap的区别"><a href="#6、hashmap和currenthashmap的区别" class="headerlink" title="6、hashmap和currenthashmap的区别"></a>6、hashmap和currenthashmap的区别</h5><blockquote><p>1、HashMap 是<strong>非线程安全</strong>的，HashTable 是线程<strong>安全</strong>的。</p><p>2、HashMap 的键和值都<strong>允许有</strong> <strong>null</strong> <strong>值</strong>存在，而 HashTable 则<strong>不行</strong>。</p><p>3、因为线程安全的问题，HashMap <strong>效率</strong>比 HashTable 的<strong>要高</strong>。</p><p>4、Hashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线 <strong>程环境</strong>，而 Hashtable 适合于多线程环境。一般现在不建议用 HashTable, ① 是 HashTable 是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下， 现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用HashTable。</p></blockquote><h5 id="7、多线程synchronized和lock锁的区别"><a href="#7、多线程synchronized和lock锁的区别" class="headerlink" title="7、多线程synchronized和lock锁的区别"></a>7、多线程synchronized和lock锁的区别</h5><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">synchronized</span>是java关键字，而Lock是java中的一个接口</span><br><span class="line"><span class="number">2</span>、<span class="keyword">synchronized</span>会自动释放锁，而Lock必须手动释放锁</span><br><span class="line"><span class="number">3</span>、<span class="keyword">synchronized</span>是不可中断的，Lock可以中断也可以不中断</span><br><span class="line"><span class="number">4</span>、通过Lock可以知道线程有没有拿到锁，而<span class="keyword">synchronized</span>不能</span><br><span class="line"><span class="number">5</span>、<span class="keyword">synchronized</span>能锁住方法和代码块，而Lock只能锁住代码块</span><br><span class="line"><span class="number">6</span>、Lock可以使用读锁提高多线程读效率</span><br><span class="line"><span class="number">7</span>、<span class="keyword">synchronized</span>是非公平锁，ReentranLock可以控制是否公平锁</span><br></pre></td></tr></table></figure><h5 id="8、volatile的作用"><a href="#8、volatile的作用" class="headerlink" title="8、volatile的作用"></a>8、volatile的作用</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、保证内存可见性</span><br><span class="line"><span class="number">2</span>、禁止指令重排序</span><br><span class="line"><span class="number">3</span>、<span class="keyword">volatile</span>并不能保证原子性</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>应用：</span><br><span class="line">①状态量标记（如上flag）</span><br><span class="line">②懒汉式单例模式</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Singleton</span>():完成<span class="number">3</span>步  分配内存空间<span class="number">1</span>、初始化对象<span class="number">2</span>、将Singleton对象指向分配的内存地址<span class="number">3</span></span><br></pre></td></tr></table></figure><h5 id="9、hashset去重原理"><a href="#9、hashset去重原理" class="headerlink" title="9、hashset去重原理"></a>9、hashset去重原理</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet集合存储自定义元素，需要重写<span class="keyword">equals</span>和hashCode方法，才能根据属性值去重</span><br></pre></td></tr></table></figure><h5 id="10、list、set、map的存储区别"><a href="#10、list、set、map的存储区别" class="headerlink" title="10、list、set、map的存储区别"></a>10、list、set、map的存储区别</h5><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>和<span class="built_in">Set</span>是存储单列数据的集合，<span class="built_in">Map</span>是存储键值对这样的双列数据的集合；</span><br><span class="line"><span class="built_in">List</span>中存储的数据是有顺序的，并且值允许重复；</span><br><span class="line"><span class="built_in">Map</span>中存储的数据是无序的，它的键是不允许重复的，但是值是允许重复的；</span><br><span class="line"><span class="built_in">Set</span>中存储的数据是无顺序的，并且不允许重复，<span class="variable">HashSet</span>是靠<span class="variable">hashCode</span>和<span class="variable">equals</span>确定位置<span class="operator">,</span><span class="variable">TreeSet</span>靠元素实现的<span class="variable">Comparable</span>接口方法或比较器<span class="variable">Comparator</span>确定位置。</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span></span><br><span class="line">存入和取出无序</span><br><span class="line">元素不重复</span><br><span class="line">无索引</span><br></pre></td></tr></table></figure><h5 id="11、cookies和session的区别"><a href="#11、cookies和session的区别" class="headerlink" title="11、cookies和session的区别"></a>11、cookies和session的区别</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cookies是属于<span class="keyword">Session</span>对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“<span class="keyword">Session</span>”则会占用服务器资源。<span class="keyword">Session</span>过多时，会增加服务器压力</span><br><span class="line"></span><br><span class="line"><span class="keyword">Session</span>比Cookie更具有安全性</span><br><span class="line">使用cookie时不可以存入重要信息,以防信息泄露造成损失.</span><br><span class="line"><span class="keyword">session</span> 能够存储任意的 java 对象，cookie 只能存储 String 类型的对象</span><br></pre></td></tr></table></figure><h5 id="12、http和https的区别"><a href="#12、http和https的区别" class="headerlink" title="12、http和https的区别"></a>12、http和https的区别</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">https</span>的端口是<span class="number">443</span>，而<span class="keyword">http</span>的端口是<span class="number">80</span>，且两者的连接方式不同；</span><br><span class="line"><span class="number">2</span>、<span class="keyword">http</span>传输是明文的，而<span class="keyword">https</span>是用ssl进行加密的，<span class="keyword">https</span>的安全性更高；</span><br><span class="line"><span class="number">3</span>、<span class="keyword">https</span>是需要申请证书的，而<span class="keyword">http</span>不需要。</span><br></pre></td></tr></table></figure><h5 id="13、http请求体的请求格式"><a href="#13、http请求体的请求格式" class="headerlink" title="13、http请求体的请求格式"></a>13、http请求体的请求格式</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>、请求行：请求数据的第一行。其中GET表示请求方式， / 表示请求资源路径，HTTP/<span class="number">1</span>,<span class="number">1</span>表示协议版本</span><br><span class="line"><span class="attribute">2</span>、请求头：第二行开始，格式为key：value形式</span><br><span class="line"><span class="attribute">3</span>、请求体：POST请求的最后一部分，存放请求参数</span><br></pre></td></tr></table></figure><h5 id="14、sql语句的执行流程"><a href="#14、sql语句的执行流程" class="headerlink" title="14、sql语句的执行流程"></a>14、sql语句的执行流程</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、最先执行<span class="keyword">from</span> tab；</span><br><span class="line"><span class="number">2</span>、<span class="keyword">where</span>语句是对条件加以限定；</span><br><span class="line"><span class="number">3</span>、分组语句【<span class="keyword">group</span> <span class="keyword">by</span>…… <span class="keyword">having</span>】；</span><br><span class="line"><span class="number">4</span>、聚合函数；</span><br><span class="line"><span class="number">5</span>、<span class="keyword">select</span>语句；</span><br><span class="line"><span class="number">6</span>、<span class="keyword">order</span> <span class="keyword">by</span>排序语句。</span><br></pre></td></tr></table></figure><h5 id="15、ThreadLocal-有两种典型的使用场景"><a href="#15、ThreadLocal-有两种典型的使用场景" class="headerlink" title="15、ThreadLocal 有两种典型的使用场景"></a>15、ThreadLocal 有两种典型的使用场景</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">场景<span class="number">1</span>：</span><br><span class="line">ThreadLocal 用作保存每个线程独享的对象，为每个线程都创建一个副本，这样每个线程都可以修改自己所拥有的副本, 而不会影响其他线程的副本，确保了线程安全。</span><br><span class="line"></span><br><span class="line">场景<span class="number">2</span>：</span><br><span class="line">ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。</span><br><span class="line"></span><br><span class="line">ThreadLocal 使用注意事项</span><br><span class="line">remove</span><br><span class="line"><span class="number">1.</span>要注意使用remove, 如果不清理，会有内存泄露问题</span><br><span class="line"><span class="number">2.</span>要注意remove,一个请求线程中的多个层之间，只需要保证最后一层去清除。否则容易误清。</span><br><span class="line">案例：</span><br><span class="line">LogUtil, 添加日志的功能是用切面方式实现的，在切面中向ThreadLocal里存值，然后启动异步线程去存日志。然后对ThreadLocal做了清理。造成的影响是，这个操作后面的操作都无法获取ThreadLocal里的缓存。比如 userId 等用户信息。</span><br></pre></td></tr></table></figure><h5 id="16、seata的模式"><a href="#16、seata的模式" class="headerlink" title="16、seata的模式"></a>16、seata的模式</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Seata有四种模式: XA、AT(默认)、TCC、Seaga</span></span><br><span class="line">(1)XA：强一致性，基于数据库隔离，无代码侵入，在一阶段不提交事务</span><br><span class="line"></span><br><span class="line">(2)AT：默认模式，基于全局锁隔离，无代码侵入，一阶段提交事务，在提交事务前，会记录undolog日志，性能比XA模式好，二阶段TC通知回滚，则根据undolog回滚，通知提交，则删除undolog日志。</span><br><span class="line"></span><br><span class="line"><span class="section">(3)TCC:性能最好，不需要依赖关系型数据库，但代码入侵读高。Try:冻结可用数据，Confirm:确认提交数据，删除冻结数据  Canel:恢复数据，将冻结数据恢复</span></span><br><span class="line"></span><br><span class="line"><span class="section">(4)Seaga: 用于长事务，例如A项目调另外一个公司的项目接口。</span></span><br></pre></td></tr></table></figure><h5 id="17、sql语句优化"><a href="#17、sql语句优化" class="headerlink" title="17、sql语句优化"></a>17、sql语句优化</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>语句务必指明字段名称（避免直接使用<span class="keyword">select</span> <span class="operator">*</span> ）</span><br><span class="line"><span class="keyword">SQL</span>语句要避免造成索引失效的写法</span><br><span class="line"><span class="keyword">SQL</span>语句中<span class="keyword">IN</span>包含的值不应过多</span><br><span class="line">当只需要一条数据的时候，使用limit <span class="number">1</span></span><br><span class="line">如果排序字段没有用到索引，就尽量少排序</span><br><span class="line">如果限制条件中其他字段没有索引，尽量少用<span class="keyword">or</span></span><br><span class="line">尽量用<span class="keyword">union</span> <span class="keyword">all</span>代替<span class="keyword">union</span></span><br><span class="line">避免在<span class="keyword">where</span>子句中对字段进行<span class="keyword">null</span>值判断</span><br><span class="line">不建议使用<span class="operator">%</span>前缀模糊查询</span><br><span class="line">避免在<span class="keyword">where</span>子句中对字段进行表达式操作</span><br><span class="line"><span class="keyword">Join</span>优化 能用innerjoin 就不用<span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">right</span> <span class="keyword">join</span>，如必须使用 一定要已小表为驱动</span><br></pre></td></tr></table></figure><h5 id="18、如何优雅的管理线程池"><a href="#18、如何优雅的管理线程池" class="headerlink" title="18、如何优雅的管理线程池"></a>18、如何优雅的管理线程池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">手动创建线程池 </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span>;</span><br><span class="line"></span><br><span class="line">这个构造方法有<span class="number">7</span>个参数，我们逐一来进行分析。</span><br><span class="line"><span class="number">1</span>）corePoolSize，线程池中的核心线程数</span><br><span class="line"><span class="number">2</span>）maximumPoolSize，线程池中的最大线程数</span><br><span class="line"><span class="number">3</span>）keepAliveTime，空闲时间，当线程池数量超过核心线程数时，多余的空闲线程存活的时间，</span><br><span class="line">即：这些线程多久被销毁。</span><br><span class="line"><span class="number">4</span>）unit，空闲时间的单位，可以是毫秒、秒、分钟、小时和天，等等</span><br><span class="line"><span class="number">5</span>）workQueue，等待队列，线程池中的线程数超过核心线程数时，任务将放在等待队列，它是一个BlockingQueue类型的对象</span><br><span class="line"><span class="number">6</span>）threadFactory，线程工厂，我们可以使用它来创建一个线程，一般用默认的即可</span><br><span class="line"><span class="number">7</span>）handler，拒绝策略，当线程池和等待队列都满了之后，需要通过该对象的回调函数进行回调处理</span><br></pre></td></tr></table></figure><h5 id="19、docker如何部署到外部服务器"><a href="#19、docker如何部署到外部服务器" class="headerlink" title="19、docker如何部署到外部服务器"></a>19、docker如何部署到外部服务器</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Docker</span>容器迁移到其他服务器的<span class="number">5</span>种方法</span><br><span class="line"></span><br><span class="line"><span class="attribute">1</span>、导出和导入容器</span><br><span class="line"><span class="attribute">2</span>、容器镜像迁移</span><br><span class="line"><span class="attribute">3</span>、保存和加载镜像</span><br><span class="line"><span class="attribute">4</span>、迁移数据卷</span><br><span class="line"><span class="attribute">5</span>、迁移整个Docker容器</span><br></pre></td></tr></table></figure><h5 id="20、redis分布式锁超时"><a href="#20、redis分布式锁超时" class="headerlink" title="20、redis分布式锁超时"></a>20、redis分布式锁超时</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分布式锁不要用于较长时间的任务，如果真的偶尔出现了问题，造成的数据小错乱，可能需要人工介入解决。</span><br></pre></td></tr></table></figure><h5 id="21、mysql索引数据结构，为什么用的是b-树不用红黑树"><a href="#21、mysql索引数据结构，为什么用的是b-树不用红黑树" class="headerlink" title="21、mysql索引数据结构，为什么用的是b+树不用红黑树"></a>21、mysql索引数据结构，为什么用的是b+树不用红黑树</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）Hash哈希，只适合等值查询，不适合范围查询   </span><br><span class="line"><span class="number">2</span>）一般二叉树，可能会特殊化为一个链表，相当于全表扫描</span><br><span class="line"><span class="number">3</span>）红黑树，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了。</span><br><span class="line"><span class="number">4</span>）<span class="selector-tag">B</span>树在范围查询时，存在回旋查找的问题，导致性能不高。<span class="selector-tag">B</span>+树叶子节点是有序链表，更有利于范围查询。</span><br><span class="line"></span><br><span class="line">综上所述，MySQL的索引数据结构最适合采用<span class="selector-tag">B</span>+树来实现。而且为了提高索引前后范围检索效率，MySQL改造了传统的<span class="selector-tag">B</span>+树，形成了双向链指针。</span><br></pre></td></tr></table></figure><h5 id="22、JWT认证和session认证对比？"><a href="#22、JWT认证和session认证对比？" class="headerlink" title="22、JWT认证和session认证对比？"></a>22、JWT认证和session认证对比？</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> HTTP是一种没有状态的协议，</span><br><span class="line"><span class="comment">--服务端为登录的用户生成 Session，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session</span></span><br><span class="line"><span class="comment">--session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。扩展性很低</span></span><br><span class="line"></span><br><span class="line">Token是以<span class="type">JSON</span>加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持</span><br><span class="line">不需要在服务端保存回话信息，特别适用于分布式微服务。有很强的扩展性</span><br></pre></td></tr></table></figure><h5 id="23、什么是无状态服务？有什么好处？"><a href="#23、什么是无状态服务？有什么好处？" class="headerlink" title="23、什么是无状态服务？有什么好处？"></a>23、什么是无状态服务？有什么好处？</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的</span><br><span class="line">(<span class="number">2</span>)无状态协议有两个显著的好处，第一是容易实现高并发；第二是实现诸如代理<span class="regexp">/转发/</span>过滤等机制非常简单而且不容易出错。</span><br></pre></td></tr></table></figure><h5 id="24、JWT"><a href="#24、JWT" class="headerlink" title="24、JWT"></a>24、JWT</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">JWT的构成？</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">JWT由三部分构成：Header </span>(头)、Payload (有效载荷)、 Signature (签名)</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)<span class="keyword">JWT如何做到防篡改？</span></span><br><span class="line"><span class="keyword"></span>signature = 加密算法(header + “.” + payload, 密钥)，然后对比 signature 是否一致，如果一致则说明没有被篡改。</span><br></pre></td></tr></table></figure><h5 id="25、多线程synchronized和lock锁的区别"><a href="#25、多线程synchronized和lock锁的区别" class="headerlink" title="25、多线程synchronized和lock锁的区别"></a>25、多线程synchronized和lock锁的区别</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Lock接口和<span class="keyword">synchronized的区别</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">JDK1.5之前，synchronized性能低，使用Lock提高性能</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">JDK1.6开始，java把synchronized性能做了优化，现在使用synchronized可有一样效果</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">区别<span class="number">1</span>：<span class="keyword">Synchronized </span>是<span class="keyword">Java的一个关键字，而Lock是java.util.concurrent.Locks </span>包下的一个接口；</span><br><span class="line">区别<span class="number">2</span>：<span class="keyword">Synchronized </span>使用过后，会自动释放锁，而Lock需要手动上锁、手动释放锁。（在 finally 块中）</span><br><span class="line">区别<span class="number">3</span>：Lock提供了更多的实现方法，而且 可响应中断、可定时， 而<span class="keyword">synchronized </span>关键字不能响应中断；</span><br><span class="line">区别<span class="number">4</span>：<span class="keyword">synchronized关键字是非公平锁，即，不能保证等待锁的那些线程们的顺序，而Lock的子类ReentrantLock默认是非公平锁，但是可通过一个布尔参数的构造方法实例化出一个公平锁；</span></span><br><span class="line"><span class="keyword"></span>区别<span class="number">5</span>：<span class="keyword">synchronized无法判断，是否已经获取到锁，而Lock通过tryLock()方法可以判断，是否已获取到锁；</span></span><br><span class="line"><span class="keyword"></span>区别<span class="number">6</span>：Lock可以通过分别定义读写锁提高多个线程读操作的效率。</span><br><span class="line">区别<span class="number">7</span>：二者的底层实现不一样：<span class="keyword">synchronized是同步阻塞，采用的是悲观并发策略；Lock是同步非阻塞，采用的是乐观并发策略（底层基于volatile关键字和CAS算法实现）</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="number">1</span>. <span class="keyword">synchronized </span>是内部锁,自动化的上锁与释放锁,而lock是手动的,需要人为的上锁和释放锁,lock比较灵活,但是代码量多</span><br><span class="line"><span class="number">2</span>、lock是一个接口，而<span class="keyword">synchronized是Java中的关键字</span></span><br><span class="line"><span class="keyword"></span><span class="number">3</span>、性能上来说，在资源竞争不激烈的情形下，Lock性能稍微比<span class="keyword">synchronized差点。但是当并发非常激烈的时候，synchronized的性能就会下降几十倍。而ReentrantLock确还能维持常态。</span></span><br></pre></td></tr></table></figure><h5 id="26、创建线程的方式"><a href="#26、创建线程的方式" class="headerlink" title="26、创建线程的方式"></a>26、创建线程的方式</h5><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-  </span>继承Thread类创建线程类 </span><br><span class="line"><span class="bullet">-  </span>通过Runnable接口创建线程类 </span><br><span class="line"><span class="bullet">-  </span>通过Callable和Future创建线程 </span><br></pre></td></tr></table></figure><h5 id="27、SpringMVC执行流程"><a href="#27、SpringMVC执行流程" class="headerlink" title="27、SpringMVC执行流程"></a>27、SpringMVC执行流程</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）处理器映射器，作用：根据用户的url地址匹配到对应Controller的方法</span><br><span class="line"><span class="number">2</span>）处理器适配器，作用：执行Controller的方法，返回结果</span><br><span class="line">执行Controller的方法是否存在异常：</span><br><span class="line">    <span class="number">2.1</span> 没有异常，执行第<span class="number">3</span>步</span><br><span class="line">    <span class="number">2.2</span>  发生异常</span><br><span class="line">        如果自定义异常拦截，执行我们写的异常拦截器方法（<span class="meta">@ExceptionHandler</span>的方）</span><br><span class="line">        如果没有异常拦截，则执行ExceptionHandlerResolver接口的resolveException方法完成异常处理（封装异常数据，转换json，返回页面） </span><br><span class="line">        </span><br><span class="line"><span class="number">3</span>）视图解析器，作用：判断方法是否存在<span class="meta">@ResponseBody</span>（<span class="meta">@RestController</span>）注解</span><br><span class="line">如果方法没有<span class="meta">@ResponseBody</span>（<span class="meta">@RestController</span>）注解，根据返回字符串，拼接视图解析器前缀和后缀，组成页面地址，转发到该页面。</span><br><span class="line">如果方法存在<span class="meta">@ResponseBody</span>（<span class="meta">@RestController</span>）注解，直接将返回值对象转换为json字符串，写回响应体中。</span><br></pre></td></tr></table></figure><h5 id="28、线程运行的6种状态"><a href="#28、线程运行的6种状态" class="headerlink" title="28、线程运行的6种状态"></a>28、线程运行的6种状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">6</span>种状态：</span><br><span class="line">    <span class="number">1.</span>新建状态  NEW</span><br><span class="line">    <span class="number">2.</span>可运行状态 RUNNABLE</span><br><span class="line">    <span class="number">3.</span>阻塞状态  BLOCKED</span><br><span class="line">    <span class="number">4.</span>无限等待状态 WAITING</span><br><span class="line">    <span class="number">5.</span>计时等待  TIMED_WAITING</span><br><span class="line">    <span class="number">6.</span>终止状态  TERMINATED</span><br></pre></td></tr></table></figure><h5 id="29、线程死锁及产生的原因"><a href="#29、线程死锁及产生的原因" class="headerlink" title="29、线程死锁及产生的原因"></a>29、线程死锁及产生的原因</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.线程死锁：</span><br><span class="line"><span class="code">	在多线程程序中，使用了多把锁，造成线程之间相互等待锁，程序无法向下执行。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">2.死锁产生的条件：</span><br><span class="line"><span class="code">    有多个线程</span></span><br><span class="line"><span class="code">    有多把锁</span></span><br><span class="line"><span class="code">    有同步代码块嵌套</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">3.避免死锁：</span><br><span class="line"><span class="code">	开发多线程程序时，应该避免三种条件同时出现在代码中，以免造成线程死锁。</span></span><br></pre></td></tr></table></figure><h5 id="30、Lambda表达式的使用前提"><a href="#30、Lambda表达式的使用前提" class="headerlink" title="30、Lambda表达式的使用前提"></a>30、Lambda表达式的使用前提</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Lambda使用的前提</span><br><span class="line">    ①.方法的参数是接口</span><br><span class="line">    ②.接口中只能有一个抽象方法</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>什么是函数式接口</span><br><span class="line">    接口中有且仅有一个抽象方法，这样的接口称为函数式接口。</span><br><span class="line">    函数式接口可以使用<span class="meta">@FunctionalInterface</span>注解标记。</span><br></pre></td></tr></table></figure><h5 id="31、递归"><a href="#31、递归" class="headerlink" title="31、递归"></a>31、递归</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.什么是递归?</span><br><span class="line"><span class="code">	递归指的是在一个方法中，自己调用自己。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">2.递归注意事项:</span><br><span class="line"><span class="code">    1.递归调用要有结束条件。</span></span><br><span class="line"><span class="code">    2.递归次数不能太多，否则容易有栈溢出异常</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    目标：掌握递归的求和案例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    需求：递归求1-n的和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_GetSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(<span class="number">5</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1-5的和</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          5 +  1-4的和</span></span><br><span class="line"><span class="comment">               4  +  1-3的和</span></span><br><span class="line"><span class="comment">                     3 + 1-2的和</span></span><br><span class="line"><span class="comment">                         2 + 1-1的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + getSum(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="32、Java-的数据结构有哪些"><a href="#32、Java-的数据结构有哪些" class="headerlink" title="32、Java 的数据结构有哪些"></a>32、Java 的数据结构有哪些</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、数组；</span><br><span class="line"><span class="number">2</span>、链表，一种递归的数据结构；</span><br><span class="line"><span class="number">3</span>、栈，按照“后进先出”、“先进后出”的原则来存储数据；</span><br><span class="line"><span class="number">4</span>、队列；</span><br><span class="line"><span class="number">5</span>、树，是由 n（n&gt;<span class="number">0</span>）个有限节点组成的一个具有层次关系的集合；</span><br><span class="line"><span class="number">6</span>、堆；</span><br><span class="line"><span class="number">7</span>、图；</span><br><span class="line"><span class="number">8</span>、哈希表。</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/" rel="tag"># 面试必看</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/09/15/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/014-seata%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E9%9B%86%E6%88%90SOP/" rel="prev" title="014-seata的部署和集成SOP"><i class="fa fa-chevron-left"></i> 014-seata的部署和集成SOP</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8"><span class="nav-number">1.</span> <span class="nav-text">面试宝典</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E5%89%8D%E6%8F%90"><span class="nav-number">1.0.1.</span> <span class="nav-text">1、多态的前提</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">1.0.2.</span> <span class="nav-text">2、方法重写的要求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.3.</span> <span class="nav-text">3、重载和重写的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8-lt-gt-%E5%92%8C-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.4.</span> <span class="nav-text">4、泛型的作用 &lt;?&gt; 和 的使用场景 和区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81java%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.0.5.</span> <span class="nav-text">5、java集合有哪些数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81hashmap%E5%92%8Ccurrenthashmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.6.</span> <span class="nav-text">6、hashmap和currenthashmap的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized%E5%92%8Clock%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.7.</span> <span class="nav-text">7、多线程synchronized和lock锁的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8%E3%80%81volatile%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.0.8.</span> <span class="nav-text">8、volatile的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9%E3%80%81hashset%E5%8E%BB%E9%87%8D%E5%8E%9F%E7%90%86"><span class="nav-number">1.0.9.</span> <span class="nav-text">9、hashset去重原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10%E3%80%81list%E3%80%81set%E3%80%81map%E7%9A%84%E5%AD%98%E5%82%A8%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.10.</span> <span class="nav-text">10、list、set、map的存储区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11%E3%80%81cookies%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.11.</span> <span class="nav-text">11、cookies和session的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12%E3%80%81http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.12.</span> <span class="nav-text">12、http和https的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13%E3%80%81http%E8%AF%B7%E6%B1%82%E4%BD%93%E7%9A%84%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.0.13.</span> <span class="nav-text">13、http请求体的请求格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14%E3%80%81sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.0.14.</span> <span class="nav-text">14、sql语句的执行流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#15%E3%80%81ThreadLocal-%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.0.15.</span> <span class="nav-text">15、ThreadLocal 有两种典型的使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#16%E3%80%81seata%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.0.16.</span> <span class="nav-text">16、seata的模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#17%E3%80%81sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96"><span class="nav-number">1.0.17.</span> <span class="nav-text">17、sql语句优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18%E3%80%81%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.0.18.</span> <span class="nav-text">18、如何优雅的管理线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#19%E3%80%81docker%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2%E5%88%B0%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.0.19.</span> <span class="nav-text">19、docker如何部署到外部服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#20%E3%80%81redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%B6%85%E6%97%B6"><span class="nav-number">1.0.20.</span> <span class="nav-text">20、redis分布式锁超时</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#21%E3%80%81mysql%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84%E6%98%AFb-%E6%A0%91%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">1.0.21.</span> <span class="nav-text">21、mysql索引数据结构，为什么用的是b+树不用红黑树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#22%E3%80%81JWT%E8%AE%A4%E8%AF%81%E5%92%8Csession%E8%AE%A4%E8%AF%81%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="nav-number">1.0.22.</span> <span class="nav-text">22、JWT认证和session认证对比？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#23%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">1.0.23.</span> <span class="nav-text">23、什么是无状态服务？有什么好处？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#24%E3%80%81JWT"><span class="nav-number">1.0.24.</span> <span class="nav-text">24、JWT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#25%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized%E5%92%8Clock%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.25.</span> <span class="nav-text">25、多线程synchronized和lock锁的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#26%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.0.26.</span> <span class="nav-text">26、创建线程的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#27%E3%80%81SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.0.27.</span> <span class="nav-text">27、SpringMVC执行流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#28%E3%80%81%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">1.0.28.</span> <span class="nav-text">28、线程运行的6种状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#29%E3%80%81%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E5%8F%8A%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.0.29.</span> <span class="nav-text">29、线程死锁及产生的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#30%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%89%8D%E6%8F%90"><span class="nav-number">1.0.30.</span> <span class="nav-text">30、Lambda表达式的使用前提</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#31%E3%80%81%E9%80%92%E5%BD%92"><span class="nav-number">1.0.31.</span> <span class="nav-text">31、递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#32%E3%80%81Java-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.0.32.</span> <span class="nav-text">32、Java 的数据结构有哪些</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="onlyone Mo" src="/images/qiaoba.gif"><p class="site-author-name" itemprop="name">onlyone Mo</p><div class="site-description" itemprop="description">一切刚刚开始！</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">82</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:onlyonemomo@outlook.com" title="E-Mail → mailto:onlyonemomo@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div><a target="_blank" class="social-link" href="/atom.xml" style="color:#deb887"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div></div><footer id="footer" role="contentinfo"><span>座右铭：为真不破！</span><br></footer></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">onlyone Mo</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script src="https://onlyonemomo.github.io/js/src/md5.min.js"></script><script>NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '7692141aefcfccce8c80',
      clientSecret: 'ef72903ae1597c3407b83c8fa24fdd6f71641261',
      repo        : 'onlyonemomo.GitHub.io',
      owner       : 'onlyonemomo',
      admin       : ['onlyonemomo'],
      id          : 'd190819c7949055f29114636eee33793',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>
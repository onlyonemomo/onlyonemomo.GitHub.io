<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>进化论是个惊天骗局</title>
    <url>/2022/08/19/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/%E8%BF%9B%E5%8C%96%E8%AE%BA%E6%98%AF%E4%B8%AA%E9%AA%97%E5%B1%80/</url>
    <content><![CDATA[<p>我看了卫斯理系列中的《木炭》，讲的是人的灵魂在木炭中寄存。以前的我是不相信鬼神的，现在的我相信人是不死不灭的。我们这个世界是个表征的世界，解释人类的起源无疑是《进化论》占据很大的话语权。但很多人都不知道的是进化论的作者达尔文根本没有在书中说过人是进化而来的，只是强烈暗示这一结果！</p>
<p>最近韦伯望远镜拍摄了130亿年前的照片，足以证明宇宙的时间是永恒的。可以想象一下，现在有一台照相机能捕摄到你小时候的照片那般震撼，也进一步说明人是不死不灭的。我们日常所说的时间是用来描述物体运动的，并不是宇宙定义的时间。下列是我收集挑战进化论的一些论点，在此之前先看罗翔老师的一个视频。</p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=211870755&bvid=BV11a41187gG&cid=515291490&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
</div>

<h5 id="1、古生物学几大问题无法回答"><a href="#1、古生物学几大问题无法回答" class="headerlink" title="1、古生物学几大问题无法回答:"></a>1、古生物学几大问题无法回答:</h5><p>(1）如果人类是渐变进化而来的，那么目前为止没有发现相关化石，也就是没有进化这个过程。也就直接违反了生物是进化而来的这个理论。</p>
<p>(2）在寒武纪之前的生命是以单细胞和多细胞的形式存在，但寒武纪生命大爆发就出现了很多物种，几乎所有生物的门都在同一时间出现。这就直接反驳达尔文的进化论，物种是从水生到陆生，由简单到复杂，由低级到高级循序渐进的进化而来。</p>
<p>(3）按照目前的理解，生物进化的速度越来越快。但生物学在基因生物这个领域的话，你会发现其实生命越高级它的基因越稳定越不容易发生突变，也就是说它的这种进化速度，其实是应该越高级越慢。可是从化石上来看，从它们其它别的证据上来看，反而好像是越高级它的进化就越快一样，所以说就是进化论本身的论据之间也存在着冲突。</p>
<h5 id="2、埃及金字塔里面的秘密"><a href="#2、埃及金字塔里面的秘密" class="headerlink" title="2、埃及金字塔里面的秘密:"></a>2、埃及金字塔里面的秘密:</h5><p>(1）金字塔的构成: 它大概由230万到250万块巨石构成，每一块巨石大概在3吨到30吨，巨石之间，不知道用了什么样的工艺，使得互相之间压得非常紧，拿一个最锋利的刀片都没有办法插到两块石头中间去，就是这种工艺现在的人都很难造出来。</p>
<p>(2）有一种说法说，当时埃及用了10万奴隶，花了20年时间造了这个金字塔。为什么不可信呢? 因为这个金字塔里面一共有230万到250万块石头，刚才讲过 每块石头3吨到30吨，如果是用了20年的时间，咱们说每年365天，每天从早到晚一分钟都不休息，需要每五分钟放一块石头上去，才能够把这个金字塔在20年造出来。就算是目前的现代人也很难能造得出来!</p>
<h5 id="3、这个金字塔有很多天文学的奇观。"><a href="#3、这个金字塔有很多天文学的奇观。" class="headerlink" title="3、这个金字塔有很多天文学的奇观。"></a>3、这个金字塔有很多天文学的奇观。</h5><p>比如说四个面是对着正东正西正南正北，然后在某一个时刻金字塔上的某一个点，对着天上的某一颗星星等等，就是它整个设计包含了非常精密的数学计算，然后包含了丰富的天文学，包括地球测量，包括在建筑工艺上也是非常先进。</p>
<p>(1）金字塔的底边是一个正方形，这个正方形每边长230.37米。角度51度50分，包括230.37米，或者说觉得没什么奇怪的数字。但是如果用三角函数值计算一下，就会发现，这个金字塔四边的周长，除以金字塔的高度，然后再除以二，结果就是π。这就是说当时建造金字塔的人已经知道了π! 这是四千多年前的古埃及人就懂得使用了，而中国是南北朝的祖冲之才计算出六七位的。</p>
<p>(2) 经线和纬线相交的地方就是这个吉萨金字塔。吉萨金字塔的高度是146.8米，如果把这个高度乘以10亿，就是地球到太阳的距离。这个金字塔的重量大概是590万吨，如果乘以1000万亿就是地球的重量，非常不可思议的一个整数倍1000万亿。高度是10亿， 重量是1000万亿倍。</p>
<h5 id="4、石油越来越多反而冲击了进化论"><a href="#4、石油越来越多反而冲击了进化论" class="headerlink" title="4、石油越来越多反而冲击了进化论:"></a>4、石油越来越多反而冲击了进化论:</h5><p>(1) 全球的石油储量到底有多少? 在2004年，埃克森美孚 ExxonMobil统计说全球的石油储量大概在1717亿吨。这个《Science》 科学杂志，美国最权威的科学期刊，它的统计数据更乐观一些，说全球大概有4000亿吨石油储量。</p>
<p>(2) 众所周知，石油是由动物的尸体在地底下转化而来的，植物则变成炭。在2018年4月份有三个科学家做了一个研究，这个研究发表在美国的科学院，就是叫 Proceedings of National Academy of America。National Academy of America 可以译为美国的科学院，相当于中国的中科院，Proceedings 指的是他们的杂志——学术期刊。也就是相当于中国中科院这样一个级别的美国科学院，它的学术期刊里边登了三个科学家的文章。</p>
<p>3.1 这三个科学家花了很多很多年的时间，去统计全世界所有地球表面上的生物所含碳的含量到底有多少，后来发现这个碳的含量大概在5500万亿吨。5500万亿吨是个什么概念呢？就是说地球上主要的碳存在于植物之中，植物中含有4万5千亿吨碳。当然我们知道植物是不会变成石油的，因为它埋到地下就变成煤了，煤是这么来的。那么动物有多少呢？经过他们的计算发现动物的含碳量大概是20亿吨。20亿吨的全世界所有活着的动物，不管是陆地上的还是海洋上的，加一块儿20亿吨。</p>
<p>3.2 如果要产生4000亿吨石油的话，需要把现在地球上所有的动物全部灭绝，而且一点儿不能糟践，不能说腐烂了、分解了、什么之类的不行，一点不糟践的转化成为石油，那也不过就是20亿吨。如果要产生4000亿吨石油的话，需要把地球上的生物毁灭200遍，所有的生物毁灭200遍。</p>
<p>这样计算的话，平均每一百万年就得来场灭世浩劫，才能产生这么多石油，那么生物明显就无法进化了。目前来说石油还在源源不断被发现，很显然进化论无法解释这一点。</p>
<h5 id="5、还有一些不解之谜"><a href="#5、还有一些不解之谜" class="headerlink" title="5、还有一些不解之谜:"></a>5、还有一些不解之谜:</h5><p>(1) 比如说在非洲加蓬共和国有一个奥克洛矿区，这个奥克洛矿区发现了一个20亿年以前的核反应堆，而且这个核反应堆运转了50万年。核反应堆不可能是自然形成的，稍有不慎就炸了。</p>
<p>(2)NASA在2006年刊登了一篇文章。当时是访问了一个NASA的科学家，他说NASA从1972年开始到1977年 5年的时间，观察月亮上的地震，其实这个不应该叫做Earthquake了，Earthquake是地震，它应该叫Moonquake，就是月震。</p>
<p>地球发生地震的时候，由于地球是一个实心球体，所以地球一震之后地震波在地表的传播，最多不过半分钟就不见了，因为被地表吸收了。而当月球发生地震的时候，月震波在月球上可以传递长达10分钟之久。当时那科学家说了一句话，他说这个月球 ring like a bell，说月亮就像是一个钟一样敲起来，10分钟的时间余音不绝，余音袅袅，所以月球是空心的。</p>
<p>从道理上来讲，一个陨石如果落到地球上来，它砸出来那个坑应该是比较浅。为什么呢？因为地球上有空气，当大的小行星或者是一些什么样的小的天体，比如说一公里两公里的小天体掉到地球上来的时候，它在跟空气的摩擦当中，会起到一种好像是风力刹车的作用，能够让它速度有所减低，而月球没有空气，所以说，如果是一些天体砸到月球上，砸出的坑应该更深，但是实际上砸出的坑都很浅，所以就有人说实际上月球有一个金属的外壳，非常坚硬，所以才能够保证这个坑砸出的这么浅。</p>
<p>月亮的重量非常可疑! 我们看月亮它是地球直径的1&#x2F;4，计算体积的话它和一个球体的直径的立方成正比，这么算下来月球的质量应该是地球的1&#x2F;64，如果它们构成是同样的质地就是1&#x2F;64。但是月球比这个轻，它是地球质量的1&#x2F;81。这样一轻就有一个想法，其实是两个答案了。第一个答案就是月球的土壤密度比地球的要小，这是一种解释；还有一种解释更不可思议，就是月球是空心的，别看它那么大，因为它空所以它轻。</p>
<p>小结：我希望大家能用我“<strong>浅谈ADE效应</strong>”那篇文章一样，<strong>我们要以一个什么都不知道的人为出发点，然后以其个人的智力来挖掘与确定的知识</strong>。知识论的思考规则是：</p>
<blockquote>
<p>(1)拒绝既定的现象。<br>(2)拒绝确定的教条。<br>(3)拒绝过去的权威。<br>(4)只接受个人理性验证为实的真理。</p>
</blockquote>
<p>为什么进化论遭受如此大的挑战还仍然是主流？因为是要理论才能打败理论，不是日常的他说错就可以推翻他的理论，这也是中国人惯有的思维。就像曾经的<code>燃素理论</code>一样，后面出现<code>氧化反应理论</code>才彻底击败<code>燃素理论</code>。</p>
]]></content>
      <categories>
        <category>三千世界</category>
      </categories>
      <tags>
        <tag>进化论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈“ADE效应”陷阱</title>
    <url>/2022/08/16/%E6%B5%85%E8%B0%88%E2%80%9CADE%E6%95%88%E5%BA%94%E2%80%9D%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<p><strong>导语：</strong>ADE即抗体依赖增强。之前开发的登革病毒疫苗，还是西尼罗病毒疫苗，都被发现具有很强的ADE 效应，即针对E蛋白产生的抗体，会通过抗体的Fc受体结合巨噬细胞，并进入巨噬细胞，从而导致严重的细胞因子风暴。 这一ADE效应导致接种过西尼罗病毒疫苗的人反而更容易感染其他黄病毒（登革病毒、寨卡病毒！ 科学家早在1979年发表的《Nature》文章中就研究了黄病毒的 ADE 效应（Antibody-mediated enhancement of flavivirus replication in macrophage-like cell lines. Nature 1979）</p>
<p><strong>正文：</strong>通过导语可知，我们原有的观念就发生了颠覆。我们一直以为打了疫苗就可以有抗体抵御病毒攻击，可事实却相反！这就是“ADE效应“。我们的生活中也常常陷入“ADE效应陷阱”，像心理疾病一样，去看心理医生往往病情无法减轻，甚至可能更加重病情，但我们通过森田疗法（也称〃放弃治疗〃）常常有意想不到的效果！</p>
<h3 id="1、生活中有哪些ADE效应陷阱？"><a href="#1、生活中有哪些ADE效应陷阱？" class="headerlink" title="1、生活中有哪些ADE效应陷阱？"></a>1、生活中有哪些ADE效应陷阱？</h3><p><strong>心理疾病的ADE效应陷阱：</strong>根据传统认知，我们不能讳疾忌医，生病就应该去看医生。但是心理疾病确实一大反例，例如森田正马，“上学时，医生诊断为神经衰弱和脚气病，经常服药治疗，大学一年级时，父母因农忙，两个月忘记了给森田寄生活费，森田误以为是父母不支持他上学，感到很气愤，甚至想到当着父母的面自杀，于是暗下决心，豁出去拼命地学习，要干出个样子来让家里人看看，在这时期什么药也不吃了，放弃一切治疗，不顾一切地拼命学习，考完试后，取得了想不到的好成绩，不知什么时候，神经衰弱和脚气病等症状不知不觉也消失了。”</p>
<p><strong>古典文学的ADE效应陷阱：</strong>人们常说，要多读点书，可是有的书越读越困惑。胡适编写的《中国古代哲学 简史》里面就举例了大量的伪篇。“汉代的书，如贾谊的《新书》，董仲舒的《春秋繁露》，都有后人增加 的痕迹。又如王充的《论衡》，是汉代一部奇书，但其中如《乱龙篇》极力为董仲舒作土龙求雨一事辩护，与全书的宗旨恰相反。篇末又有”论衡终之，故曰 乱龙。乱者，终也“ 的话，全无道理。明是后人假造 的。此外重复的话极多。伪造的书定不止这一篇。又 如仲长统的《昌言》，乃是中国政治哲学史上有数的书，如今已失，仅存三篇魏晋人的书，散失更多。 《三国志》、《晋书》、《世说新语》所称各书，今 所存的，不过几部书。如《世说新语》说魏晋注《庄 子》的有几十家，今但有郭象注完全存在。” </p>
<p><strong>新闻的ADE效应陷阱：</strong>美国的总统拜登，在演讲中频频出错，就如同一个老年痴呆一样。本来是竞选总统的，但是他竟然说成竞选参议员，更有甚者认为美国白宫里面的总统并不是拜登。给大家普及一下，美国总统身份验证需要46项生物信息，包括指纹，笔迹等。拜登总统是一个老的政治家，政治家在公共场所 的所言所行都是有深意的。顺便说一下，<strong>政治没有巧合！</strong>由此可见，人们并不具备辨别假新闻的能力。</p>
<p><strong>体育上的ADE效应陷阱：</strong>我们的乒乓球很厉害，为什 么足球这么差劲？大家都在责怪足球运动员拿高薪， 却没有成就。大家可以看一下国外有哪些乒乓球俱乐部吗？足球的俱乐部我倒是知道很多，例如：皇家马德里足球俱乐部、拜仁慕尼黑俱乐部、巴塞罗那足球俱乐部、曼彻斯特联足球俱乐部、切尔西足球俱乐部 等。乒乓球就是一个业余活动，怎么能跟人家专业的比呢？我相信还有人不服气，我再说一个例子。我们知道学术界最高奖项是诺贝尔奖，但是很多人说受外国势力控制。那菲尔兹奖（全世界最高的数学奖）呢？ 只要你能证明得了数学，就可以获奖了。这个总不能再受外国势力控制了吧！中国一个人都没能获得过这个奖项，倒是奥数经常碾压外国人。</p>
<p><strong>逻辑上的ADE效应陷阱：</strong>由于我们受到意识形态影响太深，明明一些没有逻辑的话，却认为很有道理。例 如，“落后就要挨打”，为什么落后就要挨打呢？有人公然地说，“穷是原罪”，而希特勒的口号是，“让每一 户德国人餐桌上都有面包和牛奶”。</p>
<p><strong>小结：</strong>像生活中诸如此类地ADE效应很普遍，但大多数的人都深陷〃ADE效应陷阱〃里面无法自拔。由于填鸭式地教育的影响，我们明明知道这些不合理却无法跳出这个思想的沼泽，更无法有力的还击这些人。</p>
<h3 id="2-如何确定百分百正确的知识？"><a href="#2-如何确定百分百正确的知识？" class="headerlink" title="2.如何确定百分百正确的知识？"></a>2.如何确定百分百正确的知识？</h3><p><strong>”如何确定百分百正确的知识？“</strong>相信很多人说，这不可能获得百分百正确的知识。就算是牛顿的经典力学，也被爱因斯坦的相对论击败。这里我想引用一个小故事说明，“某高校的课堂上，有个教授问女学生， 你愿意接受你的男朋友一年365天，364天都是爱着你 的，另外一天是爱着别人的吗？女生思索了一下，然后坚定地说，不行！他必须365天中每一分钟都是爱着我的。”虽然明知道她的男朋友不可能每一分钟都是爰着她的，但她仍然这样要求。这就是在追求百分百确定的知识！</p>
<p><strong>”如何确定百分百正确的知识？“</strong>是笛卡尔提出来的。 笛卡尔提出来这个问题，引爆了欧洲的讨论，从而开创现代文明。人民从此告别了旧时代，迎接新科学。 顺带一提，数学的演绎推理便是他开创的。科学有可能会出错，但是数学永远不会出错！</p>
<h5 id="2-1、-笛卡尔知识论的问题：如何获得100-确定的知识？"><a href="#2-1、-笛卡尔知识论的问题：如何获得100-确定的知识？" class="headerlink" title="2.1、 笛卡尔知识论的问题：如何获得100%确定的知识？"></a>2.1、 笛卡尔知识论的问题：如何获得100%确定的知识？</h5><blockquote>
<p><strong>(1)拒绝既定的现象</strong><br><strong>(2)拒绝确定的教条</strong><br><strong>(3)拒绝过去的权威</strong><br><strong>(4)只接受个人理性验证为实的真理</strong></p>
</blockquote>
<p>笛卡尔有一天晚上连续做了三个梦，梦中梦。由此<strong>方法论</strong>就诞生了。例如《楚门的世界》，便是根据笛卡尔的方法论而拍摄的。在这里我想用一个例子来说明，100%确定知识的运用！像传销1040阳关工程， 他们所用的手法都是很低级的。他们使用心灵的复杂学习即**”谎言说一千遍便成真的”**，非常好破解。投资本来就是有赔有赚的，他们说投资就能获得高回报， 明显违背了市场的运行。又如六合彩百分百”特码”诈 骗，骗子往五百多万的手机号分为49的倍数，发一条 “特码”信息。连续四次便有49个人连续中4次特码，接下来骗子便打电话索要好处费。因为人民缺乏这个知识论的思维，认为人家真的能掌握特码信息。</p>
<h5 id="2-2、-如何建立自己的体系"><a href="#2-2、-如何建立自己的体系" class="headerlink" title="2.2、 如何建立自己的体系"></a>2.2、 如何建立自己的体系</h5><p>在讲完笛卡尔的100%确定的知识，就涉及到了如何建立自己的体系。攻防是一体的，道高一尺魔高一 丈。我们用笛卡尔获取知识的方法去思考规则：</p>
<blockquote>
<p><strong>a.拒绝偏见，获得【清晰与明确的知识】</strong><br><strong>b.分析细部来解决问题</strong><br><strong>c.从简而繁，由浅入深来构建解决问题的秩序</strong><br><strong>d.全面的确定没有遗漏应当检视的对象</strong></p>
</blockquote>
<p>规则的目的，运用理智，找出事物的方法。方法的目的在于挖掘事物，找出它们，并确定所找出的为真。 除非清晰地认知，否则不接受任何事物为真，甚至怀疑原有已经接受事物地真实性。<strong>我们要以一个什么都 不知道的人为出发点，然后以其个人的智力来挖掘与确定的知识。</strong>在信息大爆炸的时代，如何获取真实的信息尤为重要。例如我们日常下载的软件，如何确保不是盗版的？如Python下载，官网下载速度极慢，我想到其他的网站或者共享盘下载。如何保证下载的是官网的，而不是被人动了手脚？这时候我们可以校验它的MD5&#x2F;SHA1。</p>
<p>又如目前的区块链技术，到底是这个世界的未来，还是一波炒作的概念捞钱的手段。这就需要我们凭借自己的个人智力来挖掘这个区块链到底是什么？为什么这么多人推崇，有人这么多人诋毁？</p>
<p><strong>在建立体系的关键</strong>，在于必须有一个公共的标准。如果不是这样，就不能对事物有一个公正的判断。但是”公正“从何而来？答曰：来自一个共同的标准。我们要用一个同样的标准、一个客观的标准，一个大家乐于接受的标准。这样我们才能揭穿假象，辨别实情，回答种种的污蔑。例如，对待近代史的人物评判，这个标准是爰国的还是卖国的，是民主的还是走向专制 的。我相信这个标准是大家都乐于接受和认同的。回想过去，每当我与别人争论的时候，盖因〃批判的武器 〃，而不会受到〃武器的批判〃，才会使我落入敌人语言上的”圈套“。</p>
]]></content>
      <categories>
        <category>三千世界</category>
      </categories>
      <tags>
        <tag>知识论</tag>
      </tags>
  </entry>
  <entry>
    <title>30道高频面试题答案</title>
    <url>/2022/08/24/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/30%E9%81%93%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/</url>
    <content><![CDATA[<h5 id="springcloud常用组件"><a href="#springcloud常用组件" class="headerlink" title="springcloud常用组件"></a>springcloud常用组件</h5><p>Eureka：服务注册和发现，由Netflix开源</p>
<p>Nacos：服务注册和发现，还有配置管理功能，由阿里巴巴开源</p>
<p>SpringCloudGateway：微服务网关，实现微服务统一路由，统一鉴权，跨域，限流等功能</p>
<p>Feign：微服务之间远程调用，由Netflix开源</p>
<p>Ribbon：负载均衡组件，在网关路由和Feign远程调用过程中的底层都会用到Ribbon做负载均衡。</p>
<h5 id="springboot的常用注解"><a href="#springboot的常用注解" class="headerlink" title="springboot的常用注解"></a>springboot的常用注解</h5><ul>
<li>@SpringBootApplication：SpringBoot项目最核心的主键。每个SpringBoot启动类上都有，用于引导SpringBoot项目启动加载。</li>
<li>@ComponentScan：用于扫描Spring的组件，并将其放入IOC容器。</li>
<li>@Configuration：声明该类为配置类</li>
<li>@ConditionOnClass：一般和@Configuration注解同时使用，项目中导入了@ConditionOnClass声明的类，@Configuration中的@Bean才会构建。</li>
<li>@ControllerAdvice和@RestControllerAdvice：声明该类为全局异常拦截类。</li>
</ul>
<h5 id="springboot自动装配"><a href="#springboot自动装配" class="headerlink" title="springboot自动装配"></a>springboot自动装配</h5><ul>
<li>在启动类启动时加载@SpringBootApplication注解</li>
<li>在@SpringBootApplication注解里面包含三个注解：@ComponentScan，@Configuration，@EnableAutoConfiguration</li>
<li>@Configuration表明启动类是一个配置类</li>
<li>@ComponentScan自动扫描启动类所在目录及子目录在Spring组件，让其实例化</li>
<li>@EnableAutoConfiguration注解里面包含AutoConfigurationImportSelector配置类<br>在AutoConfigurationImportSelecto配置类中会读取springboot自动配置包中的META-INF的spring.factories文件</li>
<li>该spring.factories文件包含一百多个SpringBoot写好的自动配置类，但这些自动配置类并不是默认生效的，而是根据环境中导入starter启动器依赖及自动配置类上@ConditionalOnClass注解来决定该配置类是否生效。一旦自动配置类生效了，里面@Bean注解会把创建实例放入IOC容器，我们在项目中就可以随时使用@Autowired进行注入并使用</li>
</ul>
<h5 id="springmvc和springboot的关系"><a href="#springmvc和springboot的关系" class="headerlink" title="springmvc和springboot的关系"></a>springmvc和springboot的关系</h5><p> Spring MVC提供了一种轻度耦合的方式来开发web应用。它是Spring的一个模块，是一个web层框架。 </p>
<p> Spring Boot实现了自动配置，降低了Spring项目搭建的复杂度。 </p>
<p> Spring Boot 只是 辅助你简化Spring项目搭建过程的 ，如果搭建的是Web项目，Web层采用SpringMVC，那么SpringMVC的工作原理还是和原来一样的，并没有因为用了SpringBoot而被改变。</p>
<h5 id="谈谈对spring的理解"><a href="#谈谈对spring的理解" class="headerlink" title="谈谈对spring的理解"></a>谈谈对spring的理解</h5><p>Spring的核心组件是：IOC（控制翻转）、DI（依赖注入）和AOP（面向切面编程）</p>
<ul>
<li>IOC意思是控制反转，IOC让对 象的创建不用去new了，可以由spring根据我们提供的配置文件自动生产，我们需要对象的时候， 直接从Spring容器中获取即可。</li>
<li>DI的意思是依赖注入，意思是程序在运行时依赖Ioc容器来动态注入对象需要的对象。 </li>
<li>AOP，一般称为面向切面编程，可以方便将项目中与核心业务无关的代码进行抽取分离，最大程度地解耦。SpringAOP的底层一般采用JDK动态代理或者CGLIB动态代理实现。</li>
</ul>
<h5 id="spring-bean的生命周期"><a href="#spring-bean的生命周期" class="headerlink" title="spring bean的生命周期"></a>spring bean的生命周期</h5><ul>
<li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li>
<li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li>
<li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li>
<li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li>
<li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li>
<li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li>
<li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li>
<li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li>
<li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li>
</ul>
<h5 id="spring的ioc、di、aop分别是什么，ioc和di有什么关系"><a href="#spring的ioc、di、aop分别是什么，ioc和di有什么关系" class="headerlink" title="spring的ioc、di、aop分别是什么，ioc和di有什么关系"></a>spring的ioc、di、aop分别是什么，ioc和di有什么关系</h5><ul>
<li><p>IOC意思是控制反转，IOC让对 象的创建不用去new了，可以由spring根据我们提供的配置文件自动生产，我们需要对象的时候， 直接从Spring容器中获取即可。</p>
</li>
<li><p>DI的意思是依赖注入，意思是程序在运行时依赖Ioc容器来动态注入对象需要的对象。 </p>
</li>
<li><p>AOP，一般称为面向切面编程，可以方便将项目中与核心业务无关的代码进行抽取分离，最大程度地解耦。SpringAOP的底层一般采用JDK动态代理或者CGLIB动态代理实现。</p>
</li>
<li><p>IOC侧重于构建对象上的解耦，对象构建交给SpringIOC容器构建。</p>
</li>
<li><p>DI侧重于使用对象上的解耦，需要使用什么对象从SpringIOC容器获取。</p>
</li>
</ul>
<h5 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h5><p>事务是一组原子操作单元，从数据库角度说，就是一组SQL指令，要么全部执行成功，若因为某个原因其中一条指令执行有错误，则撤销先前执行过的所有SQL指令。更简答的说就是：SQL要么全部执行成功，要么撤销不执行。 </p>
<h5 id="事务的四大特性和隔离级别"><a href="#事务的四大特性和隔离级别" class="headerlink" title="事务的四大特性和隔离级别"></a>事务的四大特性和隔离级别</h5><p><strong>事务特性</strong> </p>
<ul>
<li><p><strong>原子性</strong>：即不可分割性，事务要么全部被执行，要么就全部不被执行。 </p>
</li>
<li><p><strong>一致性</strong>：事务的执行使得数据库从一种正确状态转换成另一种正确状态 </p>
</li>
<li><p><strong>隔离性</strong>：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务， </p>
</li>
<li><p><strong>持久性</strong>：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处 </p>
<p>理结果也会得到保存。</p>
</li>
</ul>
<p><strong>隔离级别</strong> </p>
<p>（1）<strong>读未提交</strong>（read Uncommited）: </p>
<p>在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项目中基本不 怎么用， 安全性太差； </p>
<p>(2) <strong>读已提交</strong>（read commited）: </p>
<p>这是大多数数据库默认的隔离级别，但是不是MySQL的默认隔离级别；这个隔离级别满足了简单的隔离 要求：一个事务只能看见已经提交事务所做的改变，所以会避免脏读问题； 由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读和虚读等问题</p>
<p>(3) <strong>可重复读</strong>（Repeatable read）： 这是MySQL的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取到一样的数 据；不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读 取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发生幻读。</p>
<p>(4**)** <strong>可串行化</strong>（serializable）： 事物的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每 个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争，一般为了提升程序的吞吐量不会采用这个；</p>
<h5 id="悲观锁和乐观锁的区别和应用场景"><a href="#悲观锁和乐观锁的区别和应用场景" class="headerlink" title="悲观锁和乐观锁的区别和应用场景"></a>悲观锁和乐观锁的区别和应用场景</h5><p>什么是悲观锁：</p>
<ul>
<li>总是假设最坏的情况，<strong>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上</strong> <strong>锁</strong>，这样别人想拿这个数据就会阻塞直到它拿到锁。</li>
</ul>
<p>悲观锁的应用场景： </p>
<ul>
<li>关系数据库的行级锁和表级锁等。</li>
</ul>
<p>什么是乐观锁：</p>
<p>总是假设最好的情况，<strong>每次去拿数据的时候都认为别人不会修改，所以不会上锁</strong>，但是在更新的时候会判断在此期间别人有没有去更新这个数据。</p>
<p>乐观锁的实现方式： </p>
<ul>
<li>可以使用<strong>版本号机制</strong>和CAS算法实现 版本号机制 在数据表中加入一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version 指会加一。当线程A要重新更新数据值时，在读取数据的时候也会读取version值，在提交更新 时，若刚才读取到的version值与当前数据库中的version值相等才更新，否则重新更新操作，直到 更新成功。</li>
</ul>
<p>悲观锁与乐观锁的应用差别：</p>
<ul>
<li><strong>乐观锁</strong>适用于写少读多的场景。这样可以省去了锁的开销，加 大了系统的整个<strong>吞吐量</strong>。</li>
<li><strong>悲观锁</strong>更适合读少写多的场景。因为如果在写多的场景下使用乐观锁，会导致应用会不断的进行重试，这样反倒是降低了性能，所以一般写多的场景下更适合才用<strong>悲观锁</strong>。</li>
</ul>
<h5 id="redis的数据类型，持久化方式"><a href="#redis的数据类型，持久化方式" class="headerlink" title="redis的数据类型，持久化方式"></a>redis的数据类型，持久化方式</h5><p>redis有5种数据类型：</p>
<ul>
<li>String</li>
<li>Set</li>
<li>List</li>
<li>Hash</li>
<li>SortedSet</li>
</ul>
<p>Redis持久化方式：</p>
<p>有两种，分别是RDB和AOF。RDB原理是对整个当前内存数据进行快照备份，体积小。AOF原理是每条操作指令都会持久化到文件，导致文件体积比较大RDB的两次备份时间间隔最短1分钟，时间长，容易导致数据丢失。而AOF默认间隔1秒1次，时间短，数据完整性高！恢复速度上来说，RDB比AOF稍快一些，因为体积小。</p>
<h5 id="redis缓存穿透、雪崩、击穿"><a href="#redis缓存穿透、雪崩、击穿" class="headerlink" title="redis缓存穿透、雪崩、击穿"></a>redis缓存穿透、雪崩、击穿</h5><p>什么是缓存雪崩：</p>
<p>缓存雪崩，即缓<strong>存同一时间大面积的失效</strong>，这个时候又来了一波 请求，结果请求都怼到数据库上，从而导致数据库连接异常。 </p>
<p>缓存雪崩解决方案： </p>
<p>1、给缓存的<strong>失效时间，加上一个随机值，避免集体失效</strong>。 </p>
<p>2、使用互斥锁，但是该方案吞吐量明显下降了。 </p>
<p>3、搭建 redis 集群</p>
<p>缓存击穿和缓存雪崩类似的，雪崩的大面积的key失效，击穿一般是个别key失效，解决办法可以和雪崩一样答。</p>
<p>什么是缓存穿透：</p>
<p><strong>缓存穿透，即黑客故意去请求缓存中不存在的数据</strong>，导致所有的请求都怼到数据库上，从而数据库连接 异常。 </p>
<p>缓存穿透解决方案： </p>
<p>1、利用互斥锁，缓存失效的时候，先去获得锁，得到锁了， 再去请求数据库。没得到锁，则休眠一段时间重试 </p>
<p>2、采用异步更新策略，无论 key 是否取到值，都直接返回， value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程 去读数据库，更新缓存。</p>
<h5 id="java的基本数据类型"><a href="#java的基本数据类型" class="headerlink" title="java的基本数据类型"></a>java的基本数据类型</h5><p> <strong>字节型（byte）、短整型（short）、整型（int）、长整型（long）、单精度浮点型（float）和双精度浮点型（double）、布尔型（boolean）、字符型（char）</strong> </p>
<h5 id="arraylist和linkedlist"><a href="#arraylist和linkedlist" class="headerlink" title="arraylist和linkedlist"></a>arraylist和linkedlist</h5><p>arraylist和linkedlist作用 </p>
<p>ArrayList和LinkedList都是实现了List接口的容器类，用于存储一系列的对象引用。他们都可以对元素的 </p>
<p>增删改查进行操作。 对于ArrayList<strong>，它在集合的末尾删除或添加元素所用的时间是一致的，但是在列表中间的部分添加或删*除时</strong>所用<strong>时间就会大大增加</strong>。但是它在根据索引<strong>查找元素</strong>的时候<strong>速度很快</strong>。 </p>
<p>对于LinkedList则相反<strong>，它在</strong>插入、删除<strong>集合中任何位置的元素所</strong>花费的时间都是一样<strong>的，但是它查</strong>询一个元素<strong>的时候却</strong>比较慢。 </p>
<p>arraylist和linkedlist区别 </p>
<p>1**.ArrayList<strong>是实现了</strong>基于动态数组<strong>的数据结构，</strong>LinkedList<strong>是</strong>基于链表**结构。 </p>
<p>2.对于<strong>随机访问</strong>的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。 </p>
<p>3.对于新增和删除操作add和remove<strong>，</strong>LinkedList比较占优势，因为ArrayList要移动数据。 </p>
<h5 id="hashtable和hashmap"><a href="#hashtable和hashmap" class="headerlink" title="hashtable和hashmap"></a>hashtable和hashmap</h5><p>1、HashMap 是<strong>非线程安全</strong>的，HashTable 是线程<strong>安全</strong>的。 </p>
<p>2、HashMap 的键和值都<strong>允许有</strong> <strong>null</strong> <strong>值</strong>存在，而 HashTable 则<strong>不行</strong>。 </p>
<p>3、因为线程安全的问题，HashMap <strong>效率</strong>比 HashTable 的<strong>要高</strong>。 </p>
<p>4、Hashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线 <strong>程环境</strong>，而 Hashtable 适合于多线程环境。一般现在不建议用 HashTable, ① 是 HashTable 是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下， 现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用HashTable。 </p>
<h5 id="jvm内存溢出"><a href="#jvm内存溢出" class="headerlink" title="jvm内存溢出"></a>jvm内存溢出</h5><p> 在Java程序中，出现内存溢出的原因也有很多，常见的有堆内存溢出，直接内存溢出，永久区&#x2F;元空间溢出 </p>
<p>1）堆内存溢出：</p>
<p> 堆溢出这种是最常见的一种，在Java中堆是重要的一个空间，Java的大量对象都是直接在堆上分配的(参考<strong>内存分配</strong>)。当大量对象占据了堆空间而且都是强引用，使之始终无法被回收，当所有对象大小之和大于参数<code>-Xmx</code>指定的值时，就会出现溢出了。 </p>
<p>如何处理</p>
<ul>
<li>首选检查代码是否存在循环或者死循环，是否能够不断的创建对象。</li>
<li>查看启动参数<code>-Xmx</code>和<code>-Xms</code> 设置的堆内存是否过小，不足以加载服务中的所有类，可以适当增加。</li>
<li>检查代码中是否存在数据库查询，没有分页一次性返回大量数据。</li>
<li>还可以通过MAT或者<strong>VisualVM工具</strong>分析，找到占用大量堆空间的对象，然后做出合理优化。</li>
</ul>
<p>2）<strong>直接内存溢出</strong></p>
<p>这个问题遇到的一般比较少，直接内存不是运行时数据区的一部分。</p>
<p>Java中NIO(New IO)是支持直接使用直接内存的，可以直接获取一块堆外空间使用，而这块空间是直接向操作系统申请的。直接内存的申请速度一般比堆内存慢，但是其访问速度要快于堆内存，所以如果存在可复用且经常被访问的空间，使用直接内存可以提高系统的性能。但是直接内存没有被Java完全托管，使用不当容易出现溢出的问题。</p>
<p>如何处理：</p>
<ul>
<li>检查程序中使用直接内存的代码是否恰当。</li>
<li>检查参数-Xmx和-XX:MaxDirectMemorySize 的大小是否合理，可以根据实际情况调整其大小。</li>
</ul>
<p>3）永久区&#x2F;元空间溢出 </p>
<p>这种错误是永久代或者元空间溢出，在jdk1.8之前会出现这种错误，之后hotspot用元空间代替了永久代来存储class信息。如果一个系统在不断的创建新的类(不是对象实例)，那么最终会导致元空间溢出的。</p>
<p>如何处理：</p>
<ul>
<li>增加元空间的大小，设置其对应参数的值 <code>-XX:MaxMetaspaceSize=512m</code></li>
<li>减少系统需要的类的数量，检查是否有不需要的类并且清除掉。</li>
<li>使用ClassLoader合理的装载各个类，并定期进行回收。</li>
</ul>
<h5 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h5><p>调优目的：</p>
<p> 对JVM内容的系统级的调优主要的目的是减少GC的频率和Full GC的次数。 </p>
<p>调优步骤：</p>
<p>a. 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</p>
<p>b. 确定jvm调优量化目标；</p>
<p>c. 确定jvm调优参数（根据历史jvm参数来调整）；</p>
<p>d. 调优一台服务器，对比观察调优前后的差异；</p>
<p>e. 不断的分析和调整，知道找到合适的jvm参数配置；</p>
<p>f. 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</p>
<p>调优常见参数：<br>1）设定堆内存大小（比较常用的）<br>-Xmx：堆内存最大限制。</p>
<p>2）设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代<br>-XX:NewSize：新生代大小<br>-XX:NewRatio  新生代和老生代占比<br>-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比</p>
<p>3）设定垃圾回收器算法<br>年轻代用  -XX:+UseParNewGC<br>年老代用-XX:+UseConcMarkSweepGC</p>
<h5 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h5><ul>
<li>继承Thread类创建线程类 </li>
<li>通过Runnable接口创建线程类 </li>
<li>通过Callable和Future创建线程</li>
</ul>
<h5 id="线程池有几种"><a href="#线程池有几种" class="headerlink" title="线程池有几种"></a>线程池有几种</h5><ol>
<li><p><strong>newCachedThreadPool</strong>：创建一个<strong>可进行缓存重复利用的线程池</strong> </p>
</li>
<li><p><strong>newFixedThreadPool</strong>：创建一个可重用<strong>固定线程数的线程池</strong>，以共享的无界队列方式来运行这些</p>
</li>
</ol>
<p>线程，线程池中的线程处于一定的量，可以很好的控制线程的并发量 </p>
<ol start="3">
<li><strong>newSingleThreadExecutor</strong>：创建一个使用单个 worker 线程的Executor ，以无界队列方式来运行</li>
</ol>
<p>该线程。线程池中<strong>最多执行一个线程，之后提交的线程将会排在队列中以此执行</strong> </p>
<ol start="4">
<li><strong>newSingleThreadScheduledExecutor</strong>：创建<strong>一个单线程</strong>执行程序，它可安排在<strong>给定延迟后运行命</strong></li>
</ol>
<p><strong>令或者定期执行</strong> </p>
<ol start="5">
<li><p><strong>newScheduledThreadPool</strong>：创建一个线程池，它可安排在给<strong>定延迟后运行命令或者定期的执行</strong> </p>
</li>
<li><p><strong>newWorkStealingPool</strong>：创建一个带并<strong>行级别的线程池</strong>，并行级别决定了同<strong>一时刻</strong>最多有<strong>多</strong>少个</p>
</li>
</ol>
<p><strong>线程在执行</strong>，如不传并行级别参数，将默认为当前系统的<strong>CPU核心数</strong>*2</p>
<h5 id="mysql的引擎有几种"><a href="#mysql的引擎有几种" class="headerlink" title="mysql的引擎有几种"></a>mysql的引擎有几种</h5><p>InnoDB：MySQL默认存储引擎。支持事务。支持行级锁和表级锁。索引采用聚簇索引（索引和数据存储在一个文件，提升查询性能）。</p>
<p>MyISAM：不支持事务。仅仅支持表级锁。索引采用非聚簇索引（索引和数据分开存储，查询性能差一些）。</p>
<h5 id="项目中有没有设计表，都有哪些字段"><a href="#项目中有没有设计表，都有哪些字段" class="headerlink" title="项目中有没有设计表，都有哪些字段"></a>项目中有没有设计表，都有哪些字段</h5><p>根据自己项目自由发挥</p>
<h5 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h5><p>首先开启数据库慢查询日志，定位到查询效率比较低的sql , 找出对应的sql语句并进行分析</p>
<p>1.表设计是否规范，是否符合三范式的标准</p>
<p>(1)第一范式：保证原子性(不可拆分)</p>
<p>(2)第二范式：每张表都有主键</p>
<p>(3)第三范式(每一列都有主键相关)</p>
<p>2.查看数据表中是否存在大量的冗余字段，字段数据类型是否合理</p>
<p>3.尽可能的使用varchar代替char 建表数据类型，能用数值的绝对不用字符存储</p>
<p>4.尽量避免null值，使用默认值替代空值，数值型可以使用0，字符型可以使用空字符串</p>
<p>查看sql语句是否规范：</p>
<p>(1)避免使用关键字：or ，in，not in ，!&#x3D;，&lt;&gt;，避免使用select *</p>
<p>(2)尽量避免子查询，大部分子查询都可以连接查询</p>
<p>(3)用到or的地方可以使用union去代替实现</p>
<p>(4)用到in的地方可以使用exists去代替</p>
<p>分析sql的索引是否可以用上：</p>
<p>(1) explain查询sql的执行计划,重点关注的几个列就是，type是不是全表扫描</p>
<p>(2)看一下索引是否能够用的上,主要看key使用的是哪个索引</p>
<p>(3)看一下rows扫描行数是不是很大</p>
<h5 id="eureka和nacos的区别"><a href="#eureka和nacos的区别" class="headerlink" title="eureka和nacos的区别"></a>eureka和nacos的区别</h5><p>1）Nacos可以实现服务注册发现，也可以做配置管理；Eureka只能做服务注册发现。<br>2）Nacos临时实例心跳不正常会被剔除，非临时实例（永久实例）则不会被剔除；而Eureka只能注册临时实例，实例失效会被剔除（Eureka不支持永久实例）<br>3）Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式；而Eureka只有心跳模式；<br>4）Nacos支持服务列表变更的消息主动通知模式，服务列表更新更及时，减少服务调用失败的机率；而Eureka采用被动定时服务列表拉取更新；</p>
<h5 id="项目中用到什么设计模式，单例有几种"><a href="#项目中用到什么设计模式，单例有几种" class="headerlink" title="项目中用到什么设计模式，单例有几种"></a>项目中用到什么设计模式，单例有几种</h5><ul>
<li>单例设计模式 </li>
<li>代理模式 </li>
<li>装饰者</li>
<li>工厂模式</li>
<li>建造者模式</li>
</ul>
<p>单例有懒汉式 和 饿汉式</p>
<h5 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h5><ol>
<li><p>用户发送请求到前端控制器（DispatcherServlet）</p>
</li>
<li><p>前端控制器（DispatcherServlet）收到请求调用处理器映射器（HandlerMapping），去查找处理器 （Handler） </p>
</li>
<li><p>处理器映射器（HandlerMapping）找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </p>
</li>
<li><p>前端控制器（DispatcherServlet）调用处理器映射器（HandlerMapping） </p>
</li>
<li><p>处理器适配器（HandlerAdapter）去调用自定义的处理器类(Controller，也叫后端控制器)。 自定义的处理器类(Controller，也叫后端控制器)将得到的参数进行处理并返回结果给处理器映 射器（HandlerMapping） </p>
</li>
<li><p>处理器适配器（HandlerAdapter）将得到的结果返回给前端控制器（DispatcherServlet） </p>
</li>
<li><p>DispatcherServlet(前端控制器)将ModelAndView传给视图解析器(ViewReslover) </p>
</li>
<li><p>视图解析器(ViewReslover)将得到的参数从逻辑视图转换为物理视图并返回给前端控制器</p>
</li>
</ol>
<p>（DispatcherServlet） </p>
<ol start="9">
<li><p>前端控制器（DispatcherServlet）调用物理视图进行渲染并返回 </p>
</li>
<li><p>前端控制器（DispatcherServlet）将渲染后的结果返回</p>
</li>
</ol>
<h5 id="mybatis的-和"><a href="#mybatis的-和" class="headerlink" title="mybatis的$和#"></a>mybatis的$和#</h5><p><strong>1， #是一个占位符，$是拼接符。</strong></p>
<p> #是一个占位符，$是拼接符。</p>
<p><strong>（1）</strong>使用#parameterName方式引用参数的时候，Mybatis会把传入的参数当成是一个字符串，自动添加双引号。</p>
<p>（2）使用$parameterName引用参数时，不做任何处理，直接将值拼接在sql语句中。</p>
<p><strong>2，使用 # 能够防止sql注入，$不能避免注入攻击。</strong></p>
<p>   #的方式引用参数，mybatis会先对sql语句进行预编译，然后再引用值，能够有效防止sql注入，提高安全性。$的方式引用参数，sql语句不进行预编译。</p>
<h5 id="为什么要用es，es的倒排索引是什么"><a href="#为什么要用es，es的倒排索引是什么" class="headerlink" title="为什么要用es，es的倒排索引是什么"></a>为什么要用es，es的倒排索引是什么</h5><p>为什么用ES？</p>
<p>1）MySQL的海量数据时，搜索效率比较低，而Elasticsearch采用倒排索引法检测数据，从而效率更高。<br>2）MySQL的搜索功能比较弱，只有like这种模糊搜索，而Elasticsearch拥有大量复杂搜索的API，更加适合数据搜索场景</p>
<p>ES的倒排索引：</p>
<p>1）首先，Elasticsearch将文档数据进行索引构建。将文档数据需要分词的字段内容使用分词器进行分词，并记录每个词条和原文档的出现位置和出现频率等信息，构建出文档的索引库。<br>2）然后，用户搜索时，可以对关键词进行分词，使用分词后词条来匹配索引库，在索引库匹配到记录后，通过文档位置频率信息，反查具体的文档数据。</p>
<h5 id="rabbitmq-x2F-rocketmq、kafka的了解"><a href="#rabbitmq-x2F-rocketmq、kafka的了解" class="headerlink" title="rabbitmq&#x2F;rocketmq、kafka的了解"></a>rabbitmq&#x2F;rocketmq、kafka的了解</h5><p>RabbitMQ：<br>优势：<br>1）支持语言非常广<br>2）稳定性很好，采用Erlang语言开发<br>3）吞吐量不算低，万级<br>4）RabbitMQ官方提供7种消息发送模式，开发者轻松选择合适的模式进行开发即可<br>缺点：<br>1）采用Erlang，太小众，研究源码很难</p>
<p>Kafka：<br>优势：<br>1）高吞吐量，百万级<br>2）稳定性好，采用zookeeper进行注册（Zookeep采用CP模式，高一致模式）<br>3）可以应用在大数据数据处理领域（KafkaStream）<br>缺点：<br>1）支持的开发语言比较少<br>2）耦合zk，依赖zookeeper进行注册</p>
<h5 id="spring中-Autowired和-Resource的区别"><a href="#spring中-Autowired和-Resource的区别" class="headerlink" title="spring中@Autowired和@Resource的区别"></a>spring中@Autowired和@Resource的区别</h5><ul>
<li>@Autowired是Spring的，@Resource是javax包下的 </li>
<li>@Autowired默认按类型匹配，@Resource默认按名称匹配 </li>
<li>@Autowired和@Qualifier一起用，@Resource单独用</li>
</ul>
<h5 id="mysql索引数据结构，为什么用的是b-树不用红黑树"><a href="#mysql索引数据结构，为什么用的是b-树不用红黑树" class="headerlink" title="mysql索引数据结构，为什么用的是b+树不用红黑树"></a>mysql索引数据结构，为什么用的是b+树不用红黑树</h5><p>1）Hash哈希，只适合等值查询，不适合范围查询<br>2）一般二叉树，可能会特殊化为一个链表，相当于全表扫描<br>3）红黑树，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了。<br>4）B树在范围查询时，存在回旋查找的问题，导致性能不高。B+树叶子节点是有序链表，更有利于范围查询。</p>
<p>综上所述，MySQL的索引数据结构最适合采用B+树来实现。而且为了提高索引前后范围检索效率，MySQL改造了传统的B+树，形成了双向链指针。</p>
<h5 id="mysql和redis如何保证数据一致性"><a href="#mysql和redis如何保证数据一致性" class="headerlink" title="mysql和redis如何保证数据一致性"></a>mysql和redis如何保证数据一致性</h5><p>1）缓存延迟双删 </p>
<ul>
<li><p>先删除缓存</p>
</li>
<li><p>写数据库</p>
</li>
</ul>
<p>休眠 500 毫秒，然后删除缓存</p>
<p>这样，读取脏数据的时间最多只有500毫秒。关键是如何确定睡眠时间？ 延迟时间的目的是为了保证读请求结束，写请求可以删除读请求引起的缓存脏数据。 因此，我们需要自己评估项目的数据读取业务逻辑的耗时，在读取时间的基础上加上几百毫秒的延迟时间。</p>
<p>2）删除缓存重试机制</p>
<p>缓存删除失败怎么办？比如延迟双删的第二次删除失败，说明脏数据无法删除。 使用重试机制保证缓存删除成功。 比如重试3次，失败3次，就会将日志记录到数据库中，并发出警告进行人工干预。 在高并发场景下，重试最好采用异步方式，比如向MQ中间件发送消息，实现异步解耦。</p>
<p>3）读取 bin-log 异步删除</p>
<ul>
<li><p>更新数据库。</p>
</li>
<li><p>数据库会将操作信息记录在bin-log日志中。</p>
</li>
<li><p>使用 canal 订阅 bin-log 日志获取目标数据和密钥。</p>
</li>
<li><p>缓存删除系统获取canal数据，解析目标key，尝试删除缓存。</p>
</li>
<li><p>如果删除失败，将消息发送到消息队列。</p>
</li>
<li><p>缓存删除系统再次从消息队列中获取数据，再次执行删除操作。</p>
</li>
</ul>
<h4 id="扩展具难面试题："><a href="#扩展具难面试题：" class="headerlink" title="扩展具难面试题："></a>扩展具难面试题：</h4><h5 id="1、多线程在项目中的使用场景"><a href="#1、多线程在项目中的使用场景" class="headerlink" title="1、多线程在项目中的使用场景"></a>1、多线程在项目中的使用场景</h5><ul>
<li>多线程批量导入MySQL数据到ES</li>
<li>CRM采用异步线程执行多个统计SQL</li>
</ul>
<h5 id="2、项目中是否有高并发导致的问题"><a href="#2、项目中是否有高并发导致的问题" class="headerlink" title="2、项目中是否有高并发导致的问题"></a>2、项目中是否有高并发导致的问题</h5><ul>
<li>mysql和redis数据一致性问题</li>
<li>ThreadLocal存储登录用户ID</li>
</ul>
<h5 id="3、线程不安全导致的问题"><a href="#3、线程不安全导致的问题" class="headerlink" title="3、线程不安全导致的问题"></a>3、线程不安全导致的问题</h5><p>共享数据安全问题（分布式锁解决）</p>
<h5 id="4、并发安全的集合有哪些"><a href="#4、并发安全的集合有哪些" class="headerlink" title="4、并发安全的集合有哪些"></a>4、并发安全的集合有哪些</h5><p>ConcurrentHashMap</p>
<p>CopyOnWriteArrayList</p>
<h5 id="5、sql慢查询优化、行锁、表锁"><a href="#5、sql慢查询优化、行锁、表锁" class="headerlink" title="5、sql慢查询优化、行锁、表锁"></a>5、sql慢查询优化、行锁、表锁</h5><p>1)避免回表查询</p>
<p>2)联合索引</p>
<p>3)避免索引失效</p>
<p>4）使用执行计划优化</p>
<p>表级锁：对整个表记录锁定，一个事务修改表数据的时候，另一个事务无法修改表数据。</p>
<p>语法：<br>  lock table tb_user read local;<br>  update tb_user ssss<br>  insert into tb_user<br>  unlock;</p>
<p>特点：锁定范围比较大，比较影响性能<br>应用场景：在数据迁移场景下使用</p>
<p>行级锁：对表的某条（某些）记录锁定。</p>
<p>行级锁分为 共享锁 和 排他锁</p>
<p>共享锁：一个事务在修改记录的时候，另一个事务无法修改记录，但是可以读取。<br>      update tb_user set sex&#x3D;’女’ where id &#x3D; 1 lock in share mode;</p>
<p>排他锁：一个事务在查询&#x2F;修改记录的时候，另一个事务无法修改和读取数据。<br>      select * from tb_user where id &#x3D; 1 for update;</p>
]]></content>
      <categories>
        <category>面试宝典</category>
      </categories>
      <tags>
        <tag>面试必看</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化之消息转换器</title>
    <url>/2022/08/22/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8%E4%B9%8B%E6%8A%8A%E8%BF%94%E5%9B%9E%E6%9D%A5%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90json%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>导读</strong>：所谓模块化是针对在项目里面出现的各种问题，提供的一个模板操作，跟SOP很相似，用于指导和规范日常的工作流程。对于程序开发者来说，建立项目模块化系统，有助于提高开发效率。</p>
<p>这个是把数据库的数据通过对象返给前端，会出现下列没有转换的现象</p>
<p><img src="https://img-blog.csdnimg.cn/a9d34256a5d4452fbd615663473e8f89.png#pic_center" alt="在这里插入图片描述"></p>
<p>这个需要我们加入消息转换器进行转换，把Java对象转为json字符串，在配置类加入这段代码就可以解决了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展mvc框架的消息转换器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;开始扩展消息转换器...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个消息转化器对象</span></span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="comment">//设置对象转换器，可以将Java对象转为json字符串</span></span><br><span class="line">    converter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自己的转换器放入spring MVC框架的容器中</span></span><br><span class="line">    converters.add(<span class="number">0</span>,converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>项目模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化之自定义注解</title>
    <url>/2022/08/22/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8C%96/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>导读</strong>：所谓模块化是针对在项目里面出现的各种问题，提供的一个模板操作，跟SOP很相似，用于指导和规范日常的工作流程。对于程序开发者来说，建立项目模块化系统，有助于提高开发效率。</p>
<p><strong>自定义注解就是一个标记，需要通过具体的代码去实现这个注解的用途。</strong></p>
<h5 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h5><h6 id="先定义一个自定义注解"><a href="#先定义一个自定义注解" class="headerlink" title="先定义一个自定义注解"></a>先定义一个自定义注解</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IgnoreToken &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="拦截器写逻辑"><a href="#拦截器写逻辑" class="headerlink" title="拦截器写逻辑"></a>拦截器写逻辑</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断当前被拦截的Controller方法上是否加入了IgnoreToken注解</span></span><br><span class="line"><span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod)handler;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasMethodAnnotation</span> <span class="operator">=</span> handlerMethod.hasMethodAnnotation(IgnoreToken.class);</span><br><span class="line"><span class="keyword">if</span> (hasMethodAnnotation)&#123;</span><br><span class="line">    <span class="comment">//加入了IgnoreToken注解，直接放行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是一个判断Controller方法上是否加入了IgnoreToken注解，如果加入了IgnoreToken注解，直接放行。</p>
]]></content>
      <categories>
        <category>项目模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>状态码大全</title>
    <url>/2022/08/22/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h3 id="一、状态码大类"><a href="#一、状态码大类" class="headerlink" title="一、状态码大类"></a>一、状态码大类</h3><table>
<thead>
<tr>
<th>状态码分类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td>
</tr>
<tr>
<td>2xx</td>
<td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td>
</tr>
<tr>
<td>3xx</td>
<td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td>
</tr>
<tr>
<td>4xx</td>
<td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td>
</tr>
<tr>
<td>5xx</td>
<td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td>
</tr>
</tbody></table>
<p>状态码大全：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a> </p>
<h3 id="二、常见的响应状态码"><a href="#二、常见的响应状态码" class="headerlink" title="二、常见的响应状态码"></a>二、常见的响应状态码</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>英文描述</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td><strong><code>OK</code></strong></td>
<td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td>
</tr>
<tr>
<td>302</td>
<td><strong><code>Found</code></strong></td>
<td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td>
</tr>
<tr>
<td>304</td>
<td><strong><code>Not Modified</code></strong></td>
<td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td>
</tr>
<tr>
<td>400</td>
<td><strong><code>Bad Request</code></strong></td>
<td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td>
</tr>
<tr>
<td>403</td>
<td><strong><code>Forbidden</code></strong></td>
<td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td>
</tr>
<tr>
<td>404</td>
<td><strong><code>Not Found</code></strong></td>
<td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td>
</tr>
<tr>
<td>428</td>
<td><strong><code>Precondition Required</code></strong></td>
<td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td>
</tr>
<tr>
<td>429</td>
<td><strong><code>Too Many Requests</code></strong></td>
<td><strong>太多请求</strong>，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用</td>
</tr>
<tr>
<td>431</td>
<td><strong><code> Request Header Fields Too Large</code></strong></td>
<td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td>
</tr>
<tr>
<td>405</td>
<td><strong><code>Method Not Allowed</code></strong></td>
<td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td>
</tr>
<tr>
<td>500</td>
<td><strong><code>Internal Server Error</code></strong></td>
<td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td>
</tr>
<tr>
<td>503</td>
<td><strong><code>Service Unavailable</code></strong></td>
<td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td>
</tr>
<tr>
<td>511</td>
<td><strong><code>Network Authentication Required</code></strong></td>
<td><strong>客户端需要进行身份验证才能获得网络访问权限</strong></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>通往java之路</category>
      </categories>
      <tags>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA安装SOP</title>
    <url>/2022/08/21/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/IDEA%E5%AE%89%E8%A3%85SOP/</url>
    <content><![CDATA[<p><strong>导语</strong>：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助于快速配置相关属性，提高开发效率。</p>
<p>可以自行到官方网站自行下载，网址为：<a href="https://www.jetbrains.com/idea">https://www.jetbrains.com/idea</a><br>本文演示的IDEA版本为 IntelliJ IDEA 2021.1.1 x64</p>
<h3 id="2、安装IDEA图解"><a href="#2、安装IDEA图解" class="headerlink" title="2、安装IDEA图解"></a>2、安装IDEA图解</h3><h5 id="2-1双击安装包，点击next"><a href="#2-1双击安装包，点击next" class="headerlink" title="2.1双击安装包，点击next"></a>2.1双击安装包，点击next</h5><p><img src="https://img-blog.csdnimg.cn/a7f6748c720e4376a9cba9ce1ea34eca.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2-2点击修改Browse修改安装路径，然后点击next"><a href="#2-2点击修改Browse修改安装路径，然后点击next" class="headerlink" title="2.2点击修改Browse修改安装路径，然后点击next"></a>2.2点击修改Browse修改安装路径，然后点击next</h5><p><strong>注意：安装路径不能有中文或者有空格</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2d3f5fa9867142519722d211ed7246a1.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2-3-看图勾选，然后点击next"><a href="#2-3-看图勾选，然后点击next" class="headerlink" title="2.3 看图勾选，然后点击next"></a>2.3 看图勾选，然后点击next</h5><p><img src="https://img-blog.csdnimg.cn/1a18d151e1d248dd85e2f02481fc9e53.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2-4-点击Install-准备安装"><a href="#2-4-点击Install-准备安装" class="headerlink" title="2.4 点击Install , 准备安装"></a>2.4 点击Install , 准备安装</h5><p><img src="https://img-blog.csdnimg.cn/a10206a5482a405dbed1709807fc2148.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2-5等进度条读取完毕之后，会有最终页面提示，然后点击Finish"><a href="#2-5等进度条读取完毕之后，会有最终页面提示，然后点击Finish" class="headerlink" title="2.5等进度条读取完毕之后，会有最终页面提示，然后点击Finish"></a>2.5等进度条读取完毕之后，会有最终页面提示，然后点击Finish</h5><p><img src="https://img-blog.csdnimg.cn/ace584d408134e2ca1dba53bc96757ac.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2-6-第一次启动会询问，是否导入一些设置-选择第二个不导入，保持默认设置，再点OK"><a href="#2-6-第一次启动会询问，是否导入一些设置-选择第二个不导入，保持默认设置，再点OK" class="headerlink" title="2.6 第一次启动会询问，是否导入一些设置.选择第二个不导入，保持默认设置，再点OK"></a>2.6 第一次启动会询问，是否导入一些设置.选择第二个不导入，保持默认设置，再点OK</h5><p><img src="https://img-blog.csdnimg.cn/9ee3da7f4f7a410b86278db672ccc19e.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2-7-选择背景主题"><a href="#2-7-选择背景主题" class="headerlink" title="2.7 选择背景主题"></a>2.7 选择背景主题</h5><p><strong>建议选择白色，代码错了可以很清晰看出</strong>,选择完毕，继续next<br><img src="https://img-blog.csdnimg.cn/681e6d68384b4fddb270d17fdc864b52.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2-8-本界面让我们购买Idea"><a href="#2-8-本界面让我们购买Idea" class="headerlink" title="2.8 本界面让我们购买Idea"></a>2.8 本界面让我们购买Idea</h5><p>因为我们是学习阶段，所以可以使用免费30天<br>点击第一排第二个。Evaluate for free</p>
<p><img src="https://img-blog.csdnimg.cn/83808e04f2ab46ec846cdf8de2a88bff.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2-9-点击蓝色的Evaluate-就可以开始免费试用30天了"><a href="#2-9-点击蓝色的Evaluate-就可以开始免费试用30天了" class="headerlink" title="2.9 点击蓝色的Evaluate , 就可以开始免费试用30天了"></a>2.9 点击蓝色的Evaluate , 就可以开始免费试用30天了</h5><p><img src="https://img-blog.csdnimg.cn/35ef673b5b6543128799423e1c3e43fa.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2-10-当看到这个界面，就表示idea已经安装成功了"><a href="#2-10-当看到这个界面，就表示idea已经安装成功了" class="headerlink" title="2.10  当看到这个界面，就表示idea已经安装成功了"></a>2.10  当看到这个界面，就表示idea已经安装成功了</h5><p><img src="https://img-blog.csdnimg.cn/46ea26c1c72e4154b4a73f1e7477a2c0.png#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>SOP操作手册</category>
      </categories>
      <tags>
        <tag>SOP</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK环境变量配置SOP</title>
    <url>/2022/08/21/SOP%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/JDK%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AESOP/</url>
    <content><![CDATA[<p><strong>导语</strong>：所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。对于程序开发者来说，建立SOP系统，有助于快速配置相关属性，提高开发效率。</p>
<h3 id="1、按下Win键-E，找到计算机"><a href="#1、按下Win键-E，找到计算机" class="headerlink" title="1、按下Win键+E，找到计算机"></a>1、按下Win键+E，找到计算机</h3><p><img src="https://img-blog.csdnimg.cn/2d617c7031754c3d8b3f978337fbb87a.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2、鼠标右键点击计算机，选择属性"><a href="#2、鼠标右键点击计算机，选择属性" class="headerlink" title="2、鼠标右键点击计算机，选择属性"></a>2、鼠标右键点击计算机，选择属性</h3><p><img src="https://img-blog.csdnimg.cn/c9c27ce5def84d608c5928a72c9012ba.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3、点击高级系统设置"><a href="#3、点击高级系统设置" class="headerlink" title="3、点击高级系统设置"></a>3、点击高级系统设置</h3><p><img src="https://img-blog.csdnimg.cn/b4a03f99534b4d3db1d2265cad7b0063.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="3-1-选择高级，再点击里面的环境变量"><a href="#3-1-选择高级，再点击里面的环境变量" class="headerlink" title="3.1 选择高级，再点击里面的环境变量"></a>3.1 选择高级，再点击里面的环境变量</h5><p><img src="https://img-blog.csdnimg.cn/4ea8ce67b314490faf4417ce576564bd.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="3-2点击系统变量下面的新建"><a href="#3-2点击系统变量下面的新建" class="headerlink" title="3.2点击系统变量下面的新建"></a>3.2点击系统变量下面的新建</h5><p><img src="https://img-blog.csdnimg.cn/136e14532ff54910b871d2bab44611f7.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>会弹出这样的界面</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/d4ea8d3f73594ec7a5ac590a29e42681.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>变量名后面输入:  JAVA_HOME </p>
<p>变量值后面：把JDk的安装路径复制过来<br><strong>注意：不带bin目录</strong><br>操作完点击确定</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/175b1648b9444544b2e48d2d926009c4.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>选择Path<br>此处还是要选择下方<strong>系统变量</strong>中的Path<br>点击编辑</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/01faadb81bc34130bfeaa65ef8d52f24.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>在弹出的页面中点击编辑文本 （<strong>也可以点击新建，输入完之后点上移到第一个</strong>）<br><img src="https://img-blog.csdnimg.cn/be00c89975764c2e9d2e789404a67d6e.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>点击完毕后之后会弹出这样的页面</p>
<p><strong>注意：里面的很多内容不能删除</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/8c837453c884422fbe8f6b6f505bccc6.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>在变量值的最前面输入：**%JAVA_HOME%\bin; **<br>其中使用两个百分号包住 JAVA_HOME,表示引用了 JAVA_HOME 里面的值。<br>分号，表示多个环境变量之间的间隔。<strong>一定不能漏</strong><br><strong>注意：所以符号一定要是英文状态下的。</strong><br><img src="https://img-blog.csdnimg.cn/18e13a8e04034928a83896a0d277199d.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="4、打开CMD，输入java回车。"><a href="#4、打开CMD，输入java回车。" class="headerlink" title="4、打开CMD，输入java回车。"></a>4、打开CMD，输入java回车。</h3><p><img src="https://img-blog.csdnimg.cn/36e5efc2260e4392868ac2ff1317053e.png#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>SOP操作手册</category>
      </categories>
      <tags>
        <tag>SOP</tag>
      </tags>
  </entry>
  <entry>
    <title>畅聊教育</title>
    <url>/2022/08/18/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/%E7%95%85%E8%81%8A%E6%95%99%E8%82%B2/</url>
    <content><![CDATA[<p><strong>导语</strong>：我记得每次跟朋友争论教育的时候，她每次就说了一句“中国现在能有这样的成就不是发展的很好吗”? 我无法反驳此言论，但心中颇为不服，通过不断的去学习，我终于明白什么是教育！</p>
<h3 id="一、教育发展史"><a href="#一、教育发展史" class="headerlink" title="一、教育发展史"></a>一、教育发展史</h3><p>要想反驳这些人的言论，就得运用上知识论的内容，我们要以一个什么都不知道的人为出发点，然后以其个人的智力来挖掘与确定的知识。首先就得从教育发展史出发，对比各国的教育差异！</p>
<h5 id="普鲁士教育"><a href="#普鲁士教育" class="headerlink" title="普鲁士教育"></a>普鲁士教育</h5><p>现代教育体制的起源就是普鲁士教育改革，普鲁士也是全世界第一个实施了义务教育的国家。普鲁士教育的核心是什么？就是集体观念，中规中矩，服从，专业技能强。工业文明之后只要采用普鲁士教育这个模范的几乎是后来工业革命的大赢家，包括美国。</p>
<p>其中德国和日本是深受普鲁士教育的影响，所以会出现德国人的严谨，日本的匠人精神都来源于此! 接下来谈一下日本：日本的教育过去那是完全是一个封建皇权教育，日本后来的脱亚入欧的杂种思想，和所谓“心近中国，身在欧洲”的日本文化。它的教育就是这样的，它佩服德国，它学的普鲁士，它回去带了普鲁士，日本才实现了跟德国特别一样的这种行为和社会文化结果。</p>
<h5 id="芬兰教育"><a href="#芬兰教育" class="headerlink" title="芬兰教育"></a>芬兰教育</h5><p>在第二次工业文明之后，教育最为突出的是芬兰。<strong>芬兰教育是什么教育</strong>？它打破了普鲁士教育上很多的所谓的“把人训练成机器”。芬兰教育它把它人性化。芬兰学校，基本上不考试，最后就一个国家考试，一关就过；中间避免考试，避免人与人之间的恶性竞争，避免人给人打标签、打评分，因为人在不同的环境下、不同的时间下会有不同的表现。评分、考试是奴役和老师和学生之间恶性循环的最糟糕的东西。</p>
<p>芬兰，这个享有“世界第一教育之国”称号！芬兰的教育水平、科技水平始终居于世界前列。只有500多万人的小国，却在20项关键科技领域，有17项排名世界前十。从这里就可以看得出第一次工业文明和第二次工业文明教育的转变。</p>
<h5 id="美国的教育"><a href="#美国的教育" class="headerlink" title="美国的教育"></a>美国的教育</h5><p>美国教育又是怎么样的呢？答曰:美国的基础教育很差，但成年教育非常好，职业教育是规划特别好的。</p>
<p>为什么就成年教育最好呢？是因为美国是个移民国家，所有美国的教育最重要的好是因为美国是移民带来的，而不是它所谓的教育的优越性。它是享受了普鲁士的初期幼儿园这个教育成功的最后的收割者。</p>
<h3 id="二、教育的核心"><a href="#二、教育的核心" class="headerlink" title="二、教育的核心"></a>二、教育的核心</h3><p>2004年，美国的一个“死亡谷”，从不长一棵树，突然之间就下起了一场雨。这片沙漠从那天开始就逐渐长出来参天大树，自成一个生态圈。有一位科学家去考察，说这里的环境就适合长出花草树木。教育也同样如此，需要一个环境，什么环境就适合长什么。国内有个比喻，老师就像辛勤园丁一样。老师的作用是帮助健康的树苗茁壮的成长，进而帮助它选择合适的环境。</p>
<h6 id="教育的作用"><a href="#教育的作用" class="headerlink" title="教育的作用"></a>教育的作用</h6><p><strong>教育的作用是认知文明和创造文明的</strong>。从普鲁士教育到芬兰教育的转变，代表着文明的进化。第一次工业文明的主流是普鲁士教育，第二次工业文明的教育以芬兰为主。第一次工业文明需要的是廉价的劳动力，第二次工业文明需要的是创新型的人才。每一次文明的进化是伴随着教育的改变，相辅相成的。</p>
<h6 id="教育的终极目的"><a href="#教育的终极目的" class="headerlink" title="教育的终极目的"></a>教育的终极目的</h6><p>高中时期，我班主任在课堂讲素质教育的时候，极其狂妄的说：”就算是大学的教授来也讲不明白什么是素质教育“！这里就引发我的思考，教育的终极目的是什么？今天我可以回复我班主任当时的素质教育的问题了，教育的终极目的是，”<strong>分真假，辨善恶，知荣辱，识廉耻</strong>“！这十二个字也是我对素质教育的诠释。</p>
<p>当今社会的教育都是功能性教育、欲望的教育和欲望满足的工具。每当我和别人交流的时候，他们的嘴里只会吐出“搞钱”两个字。但你要是问他，财富从何而来？谈话就戛然而止了。<strong>这个世界是很现实的，它也很客观、很科学、也很公平。所有的爱和情、金钱、尊严，它只追求强者；只跟高尚者，只跟有信仰的人、有理想的人；它只往高处走，不往低处流</strong>。一个人连财富的来源都不明白，怎么能搞得到钱呢？就算你偶然之间天降横财，你能守得住吗？我曾经看过一篇报道中彩票的人大多最后面的结局是妻离子散，家破人亡。所以你没有钱是老天对你的一种保护！</p>
<h6 id="第三次世界文明即将诞生"><a href="#第三次世界文明即将诞生" class="headerlink" title="第三次世界文明即将诞生"></a>第三次世界文明即将诞生</h6><p>第一次工业文明的教育是以普鲁士教育为主，第二次工业文明开始倒向芬兰式教育，也就是通识教育。目前新的教育体系已经开始显露出来了，就是教育的终极目的”<strong>分真假，辨善恶，知荣辱，识廉耻</strong>“。</p>
<p><strong>未完待续…….</strong></p>
]]></content>
      <categories>
        <category>三千世界</category>
      </categories>
  </entry>
  <entry>
    <title>详解缓存穿透、缓存雪崩、缓存击穿</title>
    <url>/2022/08/17/%E9%80%9A%E5%BE%80java%E4%B9%8B%E8%B7%AF/%E8%AF%A6%E8%A7%A3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
    <content><![CDATA[<p><strong>导语</strong>：当我们使用缓存时，目标通常有两个：第一，提升响应效率和并发量；第二，减轻数据库的压力。<strong>缓存穿透</strong>、<strong>缓存雪崩</strong>和<strong>缓存击穿</strong>的发生，都是因为在某些特殊情况下，缓存失去了预期的功能所致。当缓存失效或没有抵挡住流量，流量直接涌入到数据库，在高并发的情况下，可能直接击垮数据库，导致整个系统崩溃！</p>
<h3 id="一、什么叫缓存穿透？"><a href="#一、什么叫缓存穿透？" class="headerlink" title="一、什么叫缓存穿透？"></a>一、什么叫缓存穿透？</h3><h5 id="缓存穿透的定义"><a href="#缓存穿透的定义" class="headerlink" title="缓存穿透的定义"></a>缓存穿透的定义</h5><p>用户访问的数据既不在缓存当中，也不在数据库中。出于容错的考虑，如果从底层数据库查询不到数据，则不写入缓存。这就导致每次请求都会到底层数据库进行查询，缓存也失去了意义。当高并发或有人利用不存在的Key频繁攻击时，数据库的压力骤增，甚至崩溃，这就是<strong>缓存穿透</strong>！</p>
<p><strong>造成缓存穿透的场景一般有两类</strong>：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(1)</span>原来数据是存在的，但由于某些原因（误删除、主动清理等）在缓存和数据库层面被删除了，但前端或前置的应用程序依旧保有这些数据；</span><br><span class="line"></span><br><span class="line"><span class="comment">(2)</span>恶意攻击行为，利用不存在的Key或者恶意尝试导致产生大量不存在的业务数据请求</span><br></pre></td></tr></table></figure>

<h5 id="常用的解决方案"><a href="#常用的解决方案" class="headerlink" title="常用的解决方案"></a>常用的解决方案</h5><h6 id="方案一：缓存空值（null）或默认值"><a href="#方案一：缓存空值（null）或默认值" class="headerlink" title="方案一：缓存空值（null）或默认值"></a>方案一：缓存空值（null）或默认值</h6><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">分析业务请求，如果是正常业务请求时发生缓存穿透现象，可针对相应的业务数据，在数据库查询不存在时，将其缓存为空值（<span class="built_in">null</span>）或默认值。需要注意的是，针对空值的缓存失效时间不宜过长，一般设置为<span class="number">5</span>分钟之内。当数据库被写入或更新该<span class="built_in">key</span>的新数据时，缓存必须同时被刷新，避免数据不一致。</span><br></pre></td></tr></table></figure>



<h6 id="方案二：业务逻辑前置校验"><a href="#方案二：业务逻辑前置校验" class="headerlink" title="方案二：业务逻辑前置校验"></a>方案二：业务逻辑前置校验</h6><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">在业务请求的入口处进行数据合法性校验，检查请求参数是否合理、是否包含非法值、是否恶意请求等，提前有效阻断非法请求。比如，根据年龄查询时，请求的年龄为<span class="string">-10</span>岁，这显然是不合法的请求参数，直接在参数校验时进行判断返回。</span><br></pre></td></tr></table></figure>



<h6 id="方案三：使用布隆过滤器请求白名单"><a href="#方案三：使用布隆过滤器请求白名单" class="headerlink" title="方案三：使用布隆过滤器请求白名单"></a>方案三：使用布隆过滤器请求白名单</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">在写入数据时，使用布隆过滤器进行标记（相当于设置白名单），业务请求发现缓存中无对应数据时，可先通过查询布隆过滤器判断数据是否在白名单内，如果不在白名单内，则直接返回空或失败。</span><br></pre></td></tr></table></figure>



<h6 id="方案四：用户黑名单限制"><a href="#方案四：用户黑名单限制" class="headerlink" title="方案四：用户黑名单限制"></a>方案四：用户黑名单限制</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">当发生异常情况时，实时监控访问的对象和数据，分析用户行为，针对故意请求、爬虫或攻击者，进行特定用户的限制；</span><br></pre></td></tr></table></figure>

<h3 id="二、什么叫缓存雪崩？"><a href="#二、什么叫缓存雪崩？" class="headerlink" title="二、什么叫缓存雪崩？"></a>二、什么叫缓存雪崩？</h3><h5 id="缓存雪崩的定义"><a href="#缓存雪崩的定义" class="headerlink" title="缓存雪崩的定义"></a>缓存雪崩的定义</h5><p>当缓存中大量热点缓存采用了相同的实效时间，就会导致缓存在某一个时刻同时失效，请求全部转发到数据库，从而导致数据库压力骤增，甚至宕机。从而形成一系列的连锁反应，造成系统崩溃等情况，这就是<strong>缓存雪崩</strong>！由于某些原因导致缓存服务宕机、挂掉或不响应，也同样会导致流量直接转移到数据库。</p>
<p>缓存雪崩的场景通常有两个:</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(1)</span>大量热点key同时过期；</span><br><span class="line"><span class="comment">(2)</span>缓存服务故障；</span><br></pre></td></tr></table></figure>

<h5 id="缓存雪崩的解决方案"><a href="#缓存雪崩的解决方案" class="headerlink" title="缓存雪崩的解决方案"></a>缓存雪崩的解决方案</h5><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、通常的解决方案是将<span class="keyword">key</span>的过期时间后面加上一个随机数（比如随机<span class="number">1</span>-<span class="number">5</span>分钟），让<span class="keyword">key</span>均匀的失效。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、考虑用队列或者锁的方式，保证缓存单线程写，但这种方案可能会影响并发量。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、热点数据可以考虑不失效，后台异步更新缓存，适用于不严格要求缓存一致性的场景。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、双<span class="keyword">key</span>策略，主<span class="keyword">key</span>设置过期时间，备<span class="keyword">key</span>不设置过期时间，当主<span class="keyword">key</span>失效时，直接返回备<span class="keyword">key</span>值。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、构建缓存高可用集群（针对缓存服务故障情况）。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、当缓存雪崩发生时，服务熔断、限流、降级等措施保障。</span><br></pre></td></tr></table></figure>

<h3 id="三、什么叫缓存击穿"><a href="#三、什么叫缓存击穿" class="headerlink" title="三、什么叫缓存击穿?"></a>三、什么叫缓存击穿?</h3><h5 id="缓存击穿的定义"><a href="#缓存击穿的定义" class="headerlink" title="缓存击穿的定义"></a>缓存击穿的定义</h5><p>缓存雪崩是指只大量热点key同时失效的情况，如果是单个热点key，在不停的扛着大并发，在这个key失效的瞬间，持续的大并发请求就会击破缓存，直接请求到数据库，好像蛮力击穿一样。这种情况就是<strong>缓存击穿</strong>!</p>
<p>从定义上可以看出，缓存击穿和缓存雪崩很类似，只不过是缓存击穿是一个热点key失效，而缓存雪崩是大量热点key失效。因此，可以将缓存击穿看作是缓存雪崩的一个子集</p>
<h5 id="缓存击穿的解决方案"><a href="#缓存击穿的解决方案" class="headerlink" title="缓存击穿的解决方案:"></a>缓存击穿的解决方案:</h5><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、使用互斥锁（Mutex <span class="keyword">Key</span>），只让一个线程构建缓存，其他线程等待构建缓存执行完毕，重新从缓存中获取数据。单机通过synchronized或lock来处理，分布式环境采用分布式锁。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、热点数据不设置过期时间，后台异步更新缓存，适用于不严格要求缓存一致性的场景。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、”提前“使用互斥锁（Mutex <span class="keyword">Key</span>）：在value内部设置一个比缓存（Redis）过期时间短的过期时间标识，当异步线程发现该值快过期时，马上延长内置的这个时间，并重新从数据库加载数据，设置到缓存中去。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>通往java之路</category>
      </categories>
  </entry>
  <entry>
    <title>胡适给儿子的一封信</title>
    <url>/2022/08/17/%E4%B8%89%E5%8D%83%E4%B8%96%E7%95%8C/%E8%83%A1%E9%80%82%E7%BB%99%E5%84%BF%E5%AD%90%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/</url>
    <content><![CDATA[<p>我养育你，并非恩情，</p>
<p>只是血缘使然的生物本能。</p>
<p>所以，我既然无恩于你，</p>
<p>你便无需报答我。</p>
<p>反而，我要感谢你，</p>
<p>因为有你的参与，我的生命才更完整。</p>
<p>我只是碰巧成为了你的父亲，</p>
<p>你只是碰巧成为了我的女儿和儿子。</p>
<p>我不是你的前传，</p>
<p>你也不是我的续篇。</p>
<p>你是独立的个体，</p>
<p>是与我不同的灵魂。</p>
<p>你并不因我而来，</p>
<p>你是因对生命的渴望而来。</p>
<p>你是自由的，我是爱你的。</p>
<p>但我绝不会“以爱之名”，去掌控你的人生。</p>
]]></content>
      <categories>
        <category>三千世界</category>
      </categories>
      <tags>
        <tag>教育</tag>
      </tags>
  </entry>
</search>
